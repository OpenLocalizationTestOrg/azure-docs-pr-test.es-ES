---
title: "Creación de particiones y escalado horizontal en Azure Cosmos DB | Microsoft Docs"
description: "Obtenga información sobre cómo funciona la creación de particiones en Azure Cosmos DB, cómo configurar la creación de particiones y las claves de partición y cómo seleccionar la clave de partición correcta para su aplicación."
services: cosmos-db
author: arramac
manager: jhubbard
editor: monicar
documentationcenter: 
ms.assetid: cac9a8cd-b5a3-4827-8505-d40bb61b2416
ms.service: cosmos-db
ms.workload: data-services
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 05/10/2017
ms.author: arramac
ms.custom: H1Hack27Feb2017
ms.openlocfilehash: e2d2847276e553d7511241ff323c3e00aad8e5c9
ms.sourcegitcommit: 02e69c4a9d17645633357fe3d46677c2ff22c85a
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/03/2017
---
# <a name="how-to-partition-and-scale-in-azure-cosmos-db"></a><span data-ttu-id="c8638-103">Cómo particionar y escalar en Azure Cosmos DB</span><span class="sxs-lookup"><span data-stu-id="c8638-103">How to partition and scale in Azure Cosmos DB</span></span>

<span data-ttu-id="c8638-104">[Microsoft Azure Cosmos DB](https://azure.microsoft.com/services/cosmos-db/) es un servicio de base de datos distribuido de varios modelos global diseñado para ayudarle a lograr un rendimiento rápido y predecible. Además, permite escalar sin problemas a medida que la aplicación crece.</span><span class="sxs-lookup"><span data-stu-id="c8638-104">[Microsoft Azure Cosmos DB](https://azure.microsoft.com/services/cosmos-db/) is a global distributed, multi-model database service designed to help you achieve fast, predictable performance and scale seamlessly along with your application as it grows.</span></span> <span data-ttu-id="c8638-105">En este artículo se proporciona información general sobre el funcionamiento de las particiones para todos los modelos de datos en Azure Cosmos DB y se describe cómo se pueden configurar los contenedores de Azure Cosmos DB para escalar de forma eficaz las aplicaciones.</span><span class="sxs-lookup"><span data-stu-id="c8638-105">This article provides an overview of how partitioning works for all the data models in Azure Cosmos DB, and describes how you can configure Azure Cosmos DB containers to effectively scale your applications.</span></span>

<span data-ttu-id="c8638-106">Las particiones y las claves de partición también se explican en este vídeo de Azure Friday con Scott Hanselman y Shireesh Thota, Administrador de ingeniería principal de Azure Cosmos DB.</span><span class="sxs-lookup"><span data-stu-id="c8638-106">Partitioning and partition keys are also covered in this Azure Friday video with Scott Hanselman and Azure Cosmos DB Principal Engineering Manager, Shireesh Thota.</span></span>

> [!VIDEO https://channel9.msdn.com/Shows/Azure-Friday/Azure-DocumentDB-Elastic-Scale-Partitioning/player]
> 

## <a name="partitioning-in-azure-cosmos-db"></a><span data-ttu-id="c8638-107">Creación de particiones en Azure Cosmos DB</span><span class="sxs-lookup"><span data-stu-id="c8638-107">Partitioning in Azure Cosmos DB</span></span>
<span data-ttu-id="c8638-108">Azure Cosmos DB permite almacenar y consultar datos sin esquemas con un tiempo de respuesta de milisegundos y a cualquier escala.</span><span class="sxs-lookup"><span data-stu-id="c8638-108">In Azure Cosmos DB, you can store and query schema-less data with order-of-millisecond response times at any scale.</span></span> <span data-ttu-id="c8638-109">Cosmos DB proporciona contenedores para el almacenamiento de datos llamados **colecciones (para el documento), grafos o tablas**.</span><span class="sxs-lookup"><span data-stu-id="c8638-109">Cosmos DB provides containers for storing data called **collections (for document), graphs, or tables**.</span></span> <span data-ttu-id="c8638-110">Los contenedores son recursos lógicos y pueden abarcar uno o varios servidores o particiones físicos.</span><span class="sxs-lookup"><span data-stu-id="c8638-110">Containers are logical resources and can span one or more physical partitions or servers.</span></span> <span data-ttu-id="c8638-111">Cosmos DB determina el número de particiones en función del tamaño de almacenamiento y el procesamiento aprovisionado del contenedor.</span><span class="sxs-lookup"><span data-stu-id="c8638-111">The number of partitions is determined by Cosmos DB based on the storage size and the provisioned throughput of the container.</span></span> <span data-ttu-id="c8638-112">Todas las particiones de Cosmos DB tienen una cantidad fija de almacenamiento con respaldo SSD asociado y se replican para ofrecer una alta disponibilidad.</span><span class="sxs-lookup"><span data-stu-id="c8638-112">Every partition in Cosmos DB has a fixed amount of SSD-backed storage associated with it, and is replicated for high availability.</span></span> <span data-ttu-id="c8638-113">Azure Cosmos DB se encarga de administrar las particiones de principio a fin, por lo que no tendrá que escribir ningún código complejo ni administrar ninguna partición.</span><span class="sxs-lookup"><span data-stu-id="c8638-113">Partition management is fully managed by Azure Cosmos DB, and you do not have to write complex code or manage your partitions.</span></span> <span data-ttu-id="c8638-114">Los contenedores de Cosmos DB son ilimitados en términos de almacenamiento y rendimiento.</span><span class="sxs-lookup"><span data-stu-id="c8638-114">Cosmos DB containers are unlimited in terms of storage and throughput.</span></span> 

![horizontal](./media/introduction/azure-cosmos-db-partitioning.png) 

<span data-ttu-id="c8638-116">La partición es transparente para la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c8638-116">Partitioning is transparent to your application.</span></span> <span data-ttu-id="c8638-117">Cosmos DB admite lecturas y escrituras rápidas, consultas, lógica transaccional, niveles de coherencia y control de acceso muy detallado a través de métodos o API para un recurso de contenedor único.</span><span class="sxs-lookup"><span data-stu-id="c8638-117">Cosmos DB supports fast reads and writes, queries, transactional logic, consistency levels, and fine-grained access control via methods/APIs to a single container resource.</span></span> <span data-ttu-id="c8638-118">El servicio controla la distribución de datos por las distintas particiones, así como el enrutamiento de las solicitudes de consulta a la partición correcta.</span><span class="sxs-lookup"><span data-stu-id="c8638-118">The service handles distributing data across partitions and routing query requests to the right partition.</span></span> 

<span data-ttu-id="c8638-119">¿Cómo funciona la creación de particiones?</span><span class="sxs-lookup"><span data-stu-id="c8638-119">How does partitioning work?</span></span> <span data-ttu-id="c8638-120">Cada elemento debe tener una clave de partición y una clave de fila que lo identifiquen de forma única.</span><span class="sxs-lookup"><span data-stu-id="c8638-120">Each item must have a partition key and a row key, which uniquely identify it.</span></span> <span data-ttu-id="c8638-121">La clave de partición ejerce de partición lógica para sus datos y proporciona a Cosmos DB un límite natural para distribuir datos entre las particiones.</span><span class="sxs-lookup"><span data-stu-id="c8638-121">Your partition key acts as a logical partition for your data, and provides Cosmos DB with a natural boundary for distributing data across partitions.</span></span> <span data-ttu-id="c8638-122">En resumen, la creación de particiones funciona en Azure Cosmos DB de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="c8638-122">In brief, here is how partitioning works in Azure Cosmos DB:</span></span>

* <span data-ttu-id="c8638-123">Usted aprovisiona un contenedor de Cosmos DB con el rendimiento de las solicitudes/s `T`</span><span class="sxs-lookup"><span data-stu-id="c8638-123">You provision a Cosmos DB container with `T` requests/s throughput</span></span>
* <span data-ttu-id="c8638-124">Entre bambalinas, Cosmos DB aprovisiona las particiones necesarias para atender las solicitudes/s `T`.</span><span class="sxs-lookup"><span data-stu-id="c8638-124">Behind the scenes, Cosmos DB provisions partitions needed to serve `T` requests/s.</span></span> <span data-ttu-id="c8638-125">Si `T` es superior al rendimiento máximo por partición `t`, Cosmos DB aprovisiona las particiones `N` = `T/t`</span><span class="sxs-lookup"><span data-stu-id="c8638-125">If `T` is higher than the maximum throughput per partition `t`, then Cosmos DB provisions `N` = `T/t` partitions</span></span>
* <span data-ttu-id="c8638-126">Cosmos DB asigna el espacio clave de los hash de clave de partición uniformemente en las particiones `N`.</span><span class="sxs-lookup"><span data-stu-id="c8638-126">Cosmos DB allocates the key space of partition key hashes evenly across the `N` partitions.</span></span> <span data-ttu-id="c8638-127">De este modo, cada partición (partición física) hospeda valores de clave de partición 1-N (particiones lógicas)</span><span class="sxs-lookup"><span data-stu-id="c8638-127">So, each partition (physical partition) hosts 1-N partition key values (logical partitions)</span></span>
* <span data-ttu-id="c8638-128">Cuando una partición física `p` alcanza su límite de almacenamiento, Cosmos DB divide `p` sin problemas en dos nuevas particiones, `p1` y `p2`. Asimismo, distribuye los valores correspondientes a aproximadamente la mitad de las claves a cada una de las particiones.</span><span class="sxs-lookup"><span data-stu-id="c8638-128">When a physical partition `p` reaches its storage limit, Cosmos DB seamlessly splits `p` into two new partitions `p1` and `p2` and distributes values corresponding to roughly half the keys to each of the partitions.</span></span> <span data-ttu-id="c8638-129">Esta operación de división es invisible para la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c8638-129">This split operation is invisible to your application.</span></span>
* <span data-ttu-id="c8638-130">De forma similar, si el rendimiento que aprovisiona es superior al rendimiento `t*N`, Cosmos DB divide una o varias de sus particiones para respaldar el rendimiento más alto</span><span class="sxs-lookup"><span data-stu-id="c8638-130">Similarly, when you provision throughput higher than `t*N` throughput, Cosmos DB splits one or more of your partitions to support the higher throughput</span></span>

<span data-ttu-id="c8638-131">La semántica para claves de partición es ligeramente diferente a fin de coincidir con la semántica de cada API, como se muestra en la siguiente tabla:</span><span class="sxs-lookup"><span data-stu-id="c8638-131">The semantics for partition keys are slightly different to match the semantics of each API, as shown in the following table:</span></span>

| <span data-ttu-id="c8638-132">API</span><span class="sxs-lookup"><span data-stu-id="c8638-132">API</span></span> | <span data-ttu-id="c8638-133">Partition Key</span><span class="sxs-lookup"><span data-stu-id="c8638-133">Partition Key</span></span> | <span data-ttu-id="c8638-134">Row Key</span><span class="sxs-lookup"><span data-stu-id="c8638-134">Row Key</span></span> |
| --- | --- | --- |
| <span data-ttu-id="c8638-135">DocumentDB</span><span class="sxs-lookup"><span data-stu-id="c8638-135">DocumentDB</span></span> | <span data-ttu-id="c8638-136">ruta de acceso de clave de partición personalizada</span><span class="sxs-lookup"><span data-stu-id="c8638-136">custom partition key path</span></span> | <span data-ttu-id="c8638-137">`id` fija</span><span class="sxs-lookup"><span data-stu-id="c8638-137">fixed `id`</span></span> | 
| <span data-ttu-id="c8638-138">MongoDB</span><span class="sxs-lookup"><span data-stu-id="c8638-138">MongoDB</span></span> | <span data-ttu-id="c8638-139">clave de partición personalizada</span><span class="sxs-lookup"><span data-stu-id="c8638-139">custom shard key</span></span>  | <span data-ttu-id="c8638-140">`_id` fija</span><span class="sxs-lookup"><span data-stu-id="c8638-140">fixed `_id`</span></span> | 
| <span data-ttu-id="c8638-141">Grafo</span><span class="sxs-lookup"><span data-stu-id="c8638-141">Graph</span></span> | <span data-ttu-id="c8638-142">propiedad de clave de partición personalizada</span><span class="sxs-lookup"><span data-stu-id="c8638-142">custom partition key property</span></span> | <span data-ttu-id="c8638-143">`id` fija</span><span class="sxs-lookup"><span data-stu-id="c8638-143">fixed `id`</span></span> | 
| <span data-ttu-id="c8638-144">Tabla</span><span class="sxs-lookup"><span data-stu-id="c8638-144">Table</span></span> | <span data-ttu-id="c8638-145">`PartitionKey` fija</span><span class="sxs-lookup"><span data-stu-id="c8638-145">fixed `PartitionKey`</span></span> | <span data-ttu-id="c8638-146">`RowKey` fija</span><span class="sxs-lookup"><span data-stu-id="c8638-146">fixed `RowKey`</span></span> | 

<span data-ttu-id="c8638-147">Cosmos DB usa la creación de particiones basada en hash.</span><span class="sxs-lookup"><span data-stu-id="c8638-147">Cosmos DB uses hash-based partitioning.</span></span> <span data-ttu-id="c8638-148">Al escribir un elemento, Cosmos DB aplica un algoritmo hash al valor de clave de partición y usa el resultado al que se ha aplicado un algoritmo hash para determinar en qué partición se va a almacenar el elemento.</span><span class="sxs-lookup"><span data-stu-id="c8638-148">When you write an item, Cosmos DB hashes the partition key value and use the hashed result to determine which partition to store the item in.</span></span> <span data-ttu-id="c8638-149">Cosmos DB almacena todos los elementos con la misma clave de partición en la misma partición física.</span><span class="sxs-lookup"><span data-stu-id="c8638-149">Cosmos DB stores all items with the same partition key in the same physical partition.</span></span> <span data-ttu-id="c8638-150">La elección de la clave de partición es una decisión importante que debe realizarse en el tiempo de diseño.</span><span class="sxs-lookup"><span data-stu-id="c8638-150">The choice of the partition key is an important decision that you have to make at design time.</span></span> <span data-ttu-id="c8638-151">Debe elegir un nombre de propiedad que tenga una amplia gama de valores e incluso patrones de acceso.</span><span class="sxs-lookup"><span data-stu-id="c8638-151">You must pick a property name that has a wide range of values and has even access patterns.</span></span>

> [!NOTE]
> <span data-ttu-id="c8638-152">Se recomienda tener una clave de partición con muchos valores distintos (como mínimo varios centenares o miles).</span><span class="sxs-lookup"><span data-stu-id="c8638-152">It is a best practice to have a partition key with many distinct values (100s-1000s at a minimum).</span></span>
>

<span data-ttu-id="c8638-153">Los contenedores de Azure Cosmos DB se pueden crear como "fijos" o "ilimitados".</span><span class="sxs-lookup"><span data-stu-id="c8638-153">Azure Cosmos DB containers can be created as "fixed" or "unlimited."</span></span> <span data-ttu-id="c8638-154">Los contenedores de tamaño fijo tienen un límite máximo de 10 GB y un rendimiento de 10 000 RU/s.</span><span class="sxs-lookup"><span data-stu-id="c8638-154">Fixed-size containers have a maximum limit of 10 GB and 10,000 RU/s throughput.</span></span> <span data-ttu-id="c8638-155">Algunas API permiten que la clave de partición se omita para los contenedores de tamaño fijo.</span><span class="sxs-lookup"><span data-stu-id="c8638-155">Some APIs allow the partition key to be omitted for fixed-size containers.</span></span> <span data-ttu-id="c8638-156">Para crear un contenedor como ilimitado, debe especificar un rendimiento mínimo de 2500 RU/s.</span><span class="sxs-lookup"><span data-stu-id="c8638-156">To create a container as unlimited, you must specify a minimum throughput of 2500 RU/s.</span></span>

## <a name="partitioning-and-provisioned-throughput"></a><span data-ttu-id="c8638-157">Creación de particiones y procesamiento aprovisionado</span><span class="sxs-lookup"><span data-stu-id="c8638-157">Partitioning and provisioned throughput</span></span>
<span data-ttu-id="c8638-158">Cosmos DB se ha diseñado para ofrecer un rendimiento predecible.</span><span class="sxs-lookup"><span data-stu-id="c8638-158">Cosmos DB is designed for predictable performance.</span></span> <span data-ttu-id="c8638-159">Al crear un contenedor, reserva rendimiento en términos de **[unidades de solicitud](request-units.md) (RU) por segundo con un complemento potencial para RU por minuto**.</span><span class="sxs-lookup"><span data-stu-id="c8638-159">When you create a container, you reserve throughput in terms of **[request units](request-units.md) (RU) per second with a potential add-on for RU per minute**.</span></span> <span data-ttu-id="c8638-160">A cada solicitud se le asigna una carga de unidad de solicitud proporcional a la cantidad de recursos del sistema, como la CPU, la memoria y la E/S consumidas por la operación.</span><span class="sxs-lookup"><span data-stu-id="c8638-160">Each request is assigned a request unit charge that is proportionate to the amount of system resources like CPU, Memory, and IO consumed by the operation.</span></span> <span data-ttu-id="c8638-161">Una lectura de un documento de 1 KB con coherencia de sesión consume una unidad de solicitud.</span><span class="sxs-lookup"><span data-stu-id="c8638-161">A read of a 1-KB document with Session consistency consumes one request unit.</span></span> <span data-ttu-id="c8638-162">Una lectura es 1 RU independientemente del número de elementos almacenados o del número de solicitudes que se ejecutan de manera simultánea.</span><span class="sxs-lookup"><span data-stu-id="c8638-162">A read is 1 RU regardless of the number of items stored or the number of concurrent requests running at the same time.</span></span> <span data-ttu-id="c8638-163">Los elementos más grandes exigen unidades de solicitud mayores en función del tamaño.</span><span class="sxs-lookup"><span data-stu-id="c8638-163">Larger items require higher request units depending on the size.</span></span> <span data-ttu-id="c8638-164">Si se conoce el tamaño de las entidades y el número de lecturas que soportará la aplicación, se puede aprovisionar la cantidad exacta de procesamiento requerido para las necesidades de lectura de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c8638-164">If you know the size of your entities and the number of reads you need to support for your application, you can provision the exact amount of throughput required for your application's read needs.</span></span> 

> [!NOTE]
> <span data-ttu-id="c8638-165">Para alcanzar el rendimiento total del contenedor, debe elegirse una clave de partición que permita distribuir uniformemente las solicitudes entre algunos valores de clave de partición definidos.</span><span class="sxs-lookup"><span data-stu-id="c8638-165">To achieve the full throughput of the container, you must choose a partition key that allows you to evenly distribute requests among some distinct partition key values.</span></span>
> 
> 

<a name="designing-for-partitioning"></a>
## <a name="working-with-the-azure-cosmos-db-apis"></a><span data-ttu-id="c8638-166">Uso de las API de Azure Cosmos DB</span><span class="sxs-lookup"><span data-stu-id="c8638-166">Working with the Azure Cosmos DB APIs</span></span>
<span data-ttu-id="c8638-167">Puede usar Azure Portal o la CLI de Azure para crear contenedores y escalarlos en cualquier momento.</span><span class="sxs-lookup"><span data-stu-id="c8638-167">You can use the Azure portal or Azure CLI to create containers and scale them at any time.</span></span> <span data-ttu-id="c8638-168">En esta sección se muestra cómo crear contenedores y se especifica la definición de clave de partición y rendimiento en cada una de las API admitidas.</span><span class="sxs-lookup"><span data-stu-id="c8638-168">This section shows how to create containers and specify the throughput and partition key definition in each of the supported APIs.</span></span>

### <a name="documentdb-api"></a><span data-ttu-id="c8638-169">API de DocumentDB</span><span class="sxs-lookup"><span data-stu-id="c8638-169">DocumentDB API</span></span>
<span data-ttu-id="c8638-170">En el ejemplo siguiente se muestra cómo crear un contenedor (colección) mediante la API de DocumentDB.</span><span class="sxs-lookup"><span data-stu-id="c8638-170">The following sample shows how to create a container (collection) using the DocumentDB API.</span></span> <span data-ttu-id="c8638-171">Puede encontrar más información en [Creación de particiones con API de DocumentDB](partition-data.md).</span><span class="sxs-lookup"><span data-stu-id="c8638-171">You can find more details in [Partitioning with DocumentDB API](partition-data.md).</span></span>

```csharp
DocumentClient client = new DocumentClient(new Uri(endpoint), authKey);
await client.CreateDatabaseAsync(new Database { Id = "db" });

DocumentCollection myCollection = new DocumentCollection();
myCollection.Id = "coll";
myCollection.PartitionKey.Paths.Add("/deviceId");

await client.CreateDocumentCollectionAsync(
    UriFactory.CreateDatabaseUri("db"),
    myCollection,
    new RequestOptions { OfferThroughput = 20000 });
```

<span data-ttu-id="c8638-172">Puede leer un elemento (documento) mediante el método `GET` de la API de REST o mediante `ReadDocumentAsync` en uno de los SDK.</span><span class="sxs-lookup"><span data-stu-id="c8638-172">You can read an item (document) using the `GET` method in the REST API or using `ReadDocumentAsync` in one of the SDKs.</span></span>

```csharp
// Read document. Needs the partition key and the ID to be specified
DeviceReading document = await client.ReadDocumentAsync<DeviceReading>(
  UriFactory.CreateDocumentUri("db", "coll", "XMS-001-FE24C"), 
  new RequestOptions { PartitionKey = new PartitionKey("XMS-0001") });
```

### <a name="mongodb-api"></a><span data-ttu-id="c8638-173">MongoDB API</span><span class="sxs-lookup"><span data-stu-id="c8638-173">MongoDB API</span></span>
<span data-ttu-id="c8638-174">Con la API de MongoDB, puede crear una colección particionada mediante la herramienta, el controlador o el SDK que prefiera.</span><span class="sxs-lookup"><span data-stu-id="c8638-174">With the MongoDB API, you can create a sharded collection through your favorite tool, driver, or SDK.</span></span> <span data-ttu-id="c8638-175">En este ejemplo, usamos el shell de Mongo para crear la colección.</span><span class="sxs-lookup"><span data-stu-id="c8638-175">In this example, we use the Mongo Shell for the collection creation.</span></span>

<span data-ttu-id="c8638-176">En el shell de Mongo:</span><span class="sxs-lookup"><span data-stu-id="c8638-176">In the Mongo Shell:</span></span>

```
db.runCommand( { shardCollection: "admin.people", key: { region: "hashed" } } )
```
    
<span data-ttu-id="c8638-177">Resultados:</span><span class="sxs-lookup"><span data-stu-id="c8638-177">Results:</span></span>

```JSON
{
    "_t" : "ShardCollectionResponse",
    "ok" : 1,
    "collectionsharded" : "admin.people"
}
```

### <a name="table-api"></a><span data-ttu-id="c8638-178">Table API</span><span class="sxs-lookup"><span data-stu-id="c8638-178">Table API</span></span>

<span data-ttu-id="c8638-179">Con Table API, especifica el rendimiento de las tablas en la configuración appSettings de su aplicación:</span><span class="sxs-lookup"><span data-stu-id="c8638-179">With the Table API, you specify the throughput for tables in the appSettings configuration for your application:</span></span>

```xml
<configuration>
    <appSettings>
      <!--Table creation options -->
      <add key="TableThroughput" value="700"/>
    </appSettings>
</configuration>
```

<span data-ttu-id="c8638-180">A continuación, crea una tabla mediante el SDK de Azure Table Storage.</span><span class="sxs-lookup"><span data-stu-id="c8638-180">Then you create a table using the Azure Table storage SDK.</span></span> <span data-ttu-id="c8638-181">La clave de partición se crea implícitamente como el valor `PartitionKey`.</span><span class="sxs-lookup"><span data-stu-id="c8638-181">The partition key is implicitly created as the `PartitionKey` value.</span></span> 

```csharp
CloudTableClient tableClient = storageAccount.CreateCloudTableClient();

CloudTable table = tableClient.GetTableReference("people");
table.CreateIfNotExists();
```

<span data-ttu-id="c8638-182">Puede recuperar una sola entidad mediante el siguiente fragmento de código:</span><span class="sxs-lookup"><span data-stu-id="c8638-182">You can retrieve a single entity using the following snippet:</span></span>

```csharp
// Create a retrieve operation that takes a customer entity.
TableOperation retrieveOperation = TableOperation.Retrieve<CustomerEntity>("Smith", "Ben");

// Execute the retrieve operation.
TableResult retrievedResult = table.Execute(retrieveOperation);
```
<span data-ttu-id="c8638-183">Consulte [Developing with the Table API](tutorial-develop-table-dotnet.md) (Desarrollo con Table API) para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="c8638-183">See [Developing with the Table API](tutorial-develop-table-dotnet.md) for more details.</span></span>

### <a name="graph-api"></a><span data-ttu-id="c8638-184">API Graph</span><span class="sxs-lookup"><span data-stu-id="c8638-184">Graph API</span></span>

<span data-ttu-id="c8638-185">Con la API Graph, debe usar Azure Portal o la CLI de Azure para crear contenedores.</span><span class="sxs-lookup"><span data-stu-id="c8638-185">With the Graph API, you must use the Azure portal or CLI to create containers.</span></span> <span data-ttu-id="c8638-186">De forma alternativa, como Azure Cosmos DB tiene varios modelos, puede usar uno de los otros modelos para crear y escalar el contenedor de grafos.</span><span class="sxs-lookup"><span data-stu-id="c8638-186">Alternatively, since Azure Cosmos DB is multi-model, you can use one of the other models to create and scale your graph container.</span></span>

<span data-ttu-id="c8638-187">Puede leer cualquier vértice o borde mediante el id. y la clave de partición en Gremlin.</span><span class="sxs-lookup"><span data-stu-id="c8638-187">You can read any vertex or edge using the partition key and id in Gremlin.</span></span> <span data-ttu-id="c8638-188">Por ejemplo, para un grafo con la región ("EE. UU.") como clave de partición y "Seattle" como clave de fila, puede encontrar un vértice mediante la siguiente sintaxis:</span><span class="sxs-lookup"><span data-stu-id="c8638-188">For example, for a graph with region ("USA") as the partition key, and "Seattle" as the row key, you can find a vertex using the following syntax:</span></span>

```
g.V(['USA', 'Seattle'])
```

<span data-ttu-id="c8638-189">Al igual que con los bordes, puede hacer referencia a un borde mediante la clave de partición y la clave de fila.</span><span class="sxs-lookup"><span data-stu-id="c8638-189">Same with edges, you can reference an edge using the partition key and row key.</span></span>

```
g.E(['USA', 'I5'])
```

<span data-ttu-id="c8638-190">Consulte [Gremlin support for Cosmos DB](gremlin-support.md) (Compatibilidad con Gremlin para Cosmos DB) para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="c8638-190">See [Gremlin support for Cosmos DB](gremlin-support.md) for more details.</span></span>


<a name="designing-for-partitioning"></a>
## <a name="designing-for-partitioning"></a><span data-ttu-id="c8638-191">Diseño de la creación de particiones</span><span class="sxs-lookup"><span data-stu-id="c8638-191">Designing for partitioning</span></span>
<span data-ttu-id="c8638-192">Para escalar de forma eficaz con Azure Cosmos DB, debe elegir una buena clave de partición al crear el contenedor.</span><span class="sxs-lookup"><span data-stu-id="c8638-192">To scale effectively with Azure Cosmos DB, you need to pick a good partition key when you create your container.</span></span> <span data-ttu-id="c8638-193">Existen dos consideraciones clave cuando se trata de elegir una clave de partición:</span><span class="sxs-lookup"><span data-stu-id="c8638-193">There are two key considerations for choosing a partition key:</span></span>

* <span data-ttu-id="c8638-194">**Límite de consulta y transacciones**: la elección de una clave de partición debe equilibrar la necesidad de permitir el uso de transacciones frente a la necesidad de distribuir las entidades en varias claves de partición para garantizar que la solución sea escalable.</span><span class="sxs-lookup"><span data-stu-id="c8638-194">**Boundary for query and transactions**: Your choice of partition key should balance the need to enable the use of transactions against the requirement to distribute your entities across multiple partition keys to ensure a scalable solution.</span></span> <span data-ttu-id="c8638-195">En un extremo, se puede establecer la misma clave de partición para todos los elementos, pero esto puede limitar la escalabilidad de su solución.</span><span class="sxs-lookup"><span data-stu-id="c8638-195">At one extreme, you could set the same partition key for all your items, but this may limit the scalability of your solution.</span></span> <span data-ttu-id="c8638-196">En el otro extremo, se puede asignar una clave de partición única para cada elemento, que podría ser altamente escalable, pero podría impedir el uso de transacciones entre documentos a través de desencadenadores y procedimientos almacenados.</span><span class="sxs-lookup"><span data-stu-id="c8638-196">At the other extreme, you could assign a unique partition key for each item, which would be highly scalable but would prevent you from using cross document transactions via stored procedures and triggers.</span></span> <span data-ttu-id="c8638-197">Una clave de partición idónea es la que permite usar consultas eficaces y que tiene suficiente cardinalidad para asegurar que la solución es escalable.</span><span class="sxs-lookup"><span data-stu-id="c8638-197">An ideal partition key is one that enables you to use efficient queries and that has sufficient cardinality to ensure your solution is scalable.</span></span> 
* <span data-ttu-id="c8638-198">**Sin cuellos de botella de rendimiento y almacenamiento**: es importante elegir una propiedad que permita la distribución de las escrituras en diversos valores definidos.</span><span class="sxs-lookup"><span data-stu-id="c8638-198">**No storage and performance bottlenecks**: It is important to pick a property that allows writes to be distributed across various distinct values.</span></span> <span data-ttu-id="c8638-199">Las solicitudes dirigidas a la misma clave de partición no pueden superar el rendimiento de una sola partición y se limitan.</span><span class="sxs-lookup"><span data-stu-id="c8638-199">Requests to the same partition key cannot exceed the throughput of a single partition, and are throttled.</span></span> <span data-ttu-id="c8638-200">Por tanto, es importante elegir una clave de partición que no dé como resultado "zonas activas" dentro de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c8638-200">So it is important to pick a partition key that does not result in "hot spots" within your application.</span></span> <span data-ttu-id="c8638-201">Puesto que todos los datos de una clave de una sola partición deben almacenarse en una partición, también se recomienda evitar claves de partición que tengan grandes volúmenes de datos para el mismo valor.</span><span class="sxs-lookup"><span data-stu-id="c8638-201">Since all the data for a single partition key must be stored within a partition, it is also recommended to avoid partition keys that have high volumes of data for the same value.</span></span> 

<span data-ttu-id="c8638-202">Echemos un vistazo a algunos escenarios en el mundo real, así como a las buenas claves de partición de cada uno de ellos:</span><span class="sxs-lookup"><span data-stu-id="c8638-202">Let's look at a few real-world scenarios, and good partition keys for each:</span></span>
* <span data-ttu-id="c8638-203">Si implementa un back-end de perfil de usuario, el identificador de usuario es una buena elección para la clave de partición.</span><span class="sxs-lookup"><span data-stu-id="c8638-203">If you’re implementing a user profile backend, then the user ID is a good choice for partition key.</span></span>
* <span data-ttu-id="c8638-204">Si almacena datos IoT, como el estado del dispositivo, un identificador de dispositivo es una buena elección para la clave de partición.</span><span class="sxs-lookup"><span data-stu-id="c8638-204">If you’re storing IoT data for example, device state, a device ID is a good choice for partition key.</span></span>
* <span data-ttu-id="c8638-205">Si usa Azure Cosmos DB para registrar datos de serie temporal, el nombre de host o el identificador de proceso son una buena elección para la clave de partición.</span><span class="sxs-lookup"><span data-stu-id="c8638-205">If you’re using Azure Cosmos DB for logging time-series data, then the hostname or process ID is a good choice for partition key.</span></span>
* <span data-ttu-id="c8638-206">Si tiene una arquitectura multiempresa, el identificador del inquilino es una buena elección para la clave de partición.</span><span class="sxs-lookup"><span data-stu-id="c8638-206">If you have a multi-tenant architecture, the tenant ID is a good choice for partition key.</span></span>

<span data-ttu-id="c8638-207">En algunos casos de uso, como IoT y los perfiles de usuario, la clave de partición podría ser igual que su identificador (clave de documento).</span><span class="sxs-lookup"><span data-stu-id="c8638-207">In some use cases like IoT and user profiles, the partition key might be the same as your id (document key).</span></span> <span data-ttu-id="c8638-208">En otros, como en los datos de serie temporal, la clave de partición será diferente del identificador.</span><span class="sxs-lookup"><span data-stu-id="c8638-208">In others like the time series data, you might have a partition key that’s different than the id.</span></span>

### <a name="partitioning-and-loggingtime-series-data"></a><span data-ttu-id="c8638-209">Creación de particiones, registro y datos de serie temporal</span><span class="sxs-lookup"><span data-stu-id="c8638-209">Partitioning and logging/time-series data</span></span>
<span data-ttu-id="c8638-210">Uno de los casos de uso más comunes de Cosmos DB es el registro y telemetría.</span><span class="sxs-lookup"><span data-stu-id="c8638-210">One of the common use cases of Cosmos DB is for logging and telemetry.</span></span> <span data-ttu-id="c8638-211">Es importante elegir una buena clave de partición, ya que es posible que necesite leer y escribir grandes volúmenes de datos.</span><span class="sxs-lookup"><span data-stu-id="c8638-211">It is important to pick a good partition key since you might need to read/write vast volumes of data.</span></span> <span data-ttu-id="c8638-212">La opción depende de las tasas de lectura y escritura y de los tipos de consultas que espera ejecutar.</span><span class="sxs-lookup"><span data-stu-id="c8638-212">The choice depends on your read and write rates and kinds of queries you expect to run.</span></span> <span data-ttu-id="c8638-213">Estas son algunas sugerencias sobre cómo elegir una buena clave de partición.</span><span class="sxs-lookup"><span data-stu-id="c8638-213">Here are some tips on how to choose a good partition key.</span></span>

* <span data-ttu-id="c8638-214">Si el caso de uso implica una pequeña tasa de escrituras que se acumulan durante un largo período de tiempo y necesita consultar por intervalos de marcas de tiempo y otros filtros, el uso de un resumen de la marca de tiempo (por ejemplo, la fecha) como clave de partición es un buen enfoque.</span><span class="sxs-lookup"><span data-stu-id="c8638-214">If your use case involves a small rate of writes accumulating over a long period of time, and need to query by ranges of timestamps and other filters, then using a rollup of the timestamp, for example,  date as a partition key is a good approach.</span></span> <span data-ttu-id="c8638-215">Esto le permite consultar todos los datos para una fecha desde una sola partición.</span><span class="sxs-lookup"><span data-stu-id="c8638-215">This allows you to query over all the data for a date from a single partition.</span></span> 
* <span data-ttu-id="c8638-216">Si la carga de trabajo tiene muchas operaciones de escritura, lo que es más común, debe usar una clave de partición que no se base en la marca de tiempo para que Cosmos DB pueda distribuir escrituras uniformemente en varias particiones.</span><span class="sxs-lookup"><span data-stu-id="c8638-216">If your workload is written heavy, which is more common, you should use a partition key that’s not based on timestamp so that Cosmos DB can distribute writes evenly across various partitions.</span></span> <span data-ttu-id="c8638-217">En este caso, un nombre de host, identificador de proceso, identificador de actividad u otra propiedad con cardinalidad elevada, es una buena elección.</span><span class="sxs-lookup"><span data-stu-id="c8638-217">Here a hostname, process ID, activity ID, or another property with high cardinality is a good choice.</span></span> 
* <span data-ttu-id="c8638-218">Un tercer enfoque es un híbrido donde tiene varios contenedores, uno para cada día o mes, y la clave de partición es una propiedad pormenorizada como nombre de host.</span><span class="sxs-lookup"><span data-stu-id="c8638-218">A third approach is a hybrid one where you have multiple containers, one for each day/month and the partition key is a granular property like hostname.</span></span> <span data-ttu-id="c8638-219">Esto tiene la ventaja de que se pueden establecer distintos niveles de rendimiento en función de la ventana de tiempo; por ejemplo, el contenedor para el mes actual se aprovisiona con un mayor rendimiento, ya que sirve lecturas y escrituras, mientras que los meses anteriores se aprovisionan con menor rendimiento, ya que solo sirven lecturas.</span><span class="sxs-lookup"><span data-stu-id="c8638-219">This has the benefit that you can set different throughput based on the time window, for example, the container for the current month is provisioned with higher throughput since it serves reads and writes, whereas previous months with lower throughput since they only serve reads.</span></span>

### <a name="partitioning-and-multi-tenancy"></a><span data-ttu-id="c8638-220">Creación de particiones y arquitectura multiempresa</span><span class="sxs-lookup"><span data-stu-id="c8638-220">Partitioning and multi-tenancy</span></span>
<span data-ttu-id="c8638-221">Si implementa una aplicación multiinquilino mediante Cosmos DB, hay dos patrones populares: una clave de partición por inquilino y un contenedor por inquilino.</span><span class="sxs-lookup"><span data-stu-id="c8638-221">If you are implementing a multi-tenant application using Cosmos DB, there are two popular patterns – one partition key per tenant, and one container per tenant.</span></span> <span data-ttu-id="c8638-222">Estas son las ventajas y desventajas de cada uno:</span><span class="sxs-lookup"><span data-stu-id="c8638-222">Here are the pros and cons for each:</span></span>

* <span data-ttu-id="c8638-223">Una clave de partición por inquilino: en este modelo, los inquilinos se colocan en un solo contenedor.</span><span class="sxs-lookup"><span data-stu-id="c8638-223">One Partition Key per tenant: In this model, tenants are collocated within a single container.</span></span> <span data-ttu-id="c8638-224">Por su parte, las consultas e inserciones de elementos dentro de un único inquilino pueden realizarse en una sola partición.</span><span class="sxs-lookup"><span data-stu-id="c8638-224">But queries and inserts for items within a single tenant can be performed against a single partition.</span></span> <span data-ttu-id="c8638-225">También se puede implementar la lógica transaccional en todos los elementos de un inquilino.</span><span class="sxs-lookup"><span data-stu-id="c8638-225">You can also implement transactional logic across all items within a tenant.</span></span> <span data-ttu-id="c8638-226">Puesto que varios inquilinos comparten un contenedor, se pueden ahorrar costos de almacenamiento y rendimiento mediante la agrupación de los recursos para los inquilinos en un solo contenedor, en lugar de aprovisionar capacidad de aumento adicional para cada inquilino.</span><span class="sxs-lookup"><span data-stu-id="c8638-226">Since multiple tenants share a container, you can save storage and throughput costs by pooling resources for tenants within a single container rather than provisioning extra headroom for each tenant.</span></span> <span data-ttu-id="c8638-227">El inconveniente es que no es posible aislar el procesamiento por inquilino.</span><span class="sxs-lookup"><span data-stu-id="c8638-227">The drawback is that you do not have performance isolation per tenant.</span></span> <span data-ttu-id="c8638-228">Así, los incrementos de rendimiento y procesamiento se aplican a todo el contenedor, frente a los incrementos destinados a los inquilinos.</span><span class="sxs-lookup"><span data-stu-id="c8638-228">Performance/throughput increases apply to the entire container vs targeted increases for tenants.</span></span>
* <span data-ttu-id="c8638-229">Un contenedor por inquilino: cada inquilino tiene su propio contenedor.</span><span class="sxs-lookup"><span data-stu-id="c8638-229">One Container per tenant: Each tenant has its own container.</span></span> <span data-ttu-id="c8638-230">En este modelo es posible reservar procesamiento por inquilino.</span><span class="sxs-lookup"><span data-stu-id="c8638-230">In this model, you can reserve performance per tenant.</span></span> <span data-ttu-id="c8638-231">Con el nuevo modelo de precios de aprovisionamiento de Cosmos DB, este modelo es más rentable para las aplicaciones multiempresa con un número pequeño de inquilinos.</span><span class="sxs-lookup"><span data-stu-id="c8638-231">With Cosmos DB's new provisioning pricing model, this model is more cost-effective for multi-tenant applications with a few tenants.</span></span>

<span data-ttu-id="c8638-232">También puede usar un enfoque de combinación o niveles que coloca los inquilinos pequeños y migra los inquilinos más grandes a su propio contenedor.</span><span class="sxs-lookup"><span data-stu-id="c8638-232">You can also use a combination/tiered approach that collocates small tenants and migrates larger tenants to their own container.</span></span>

## <a name="next-steps"></a><span data-ttu-id="c8638-233">Pasos siguientes</span><span class="sxs-lookup"><span data-stu-id="c8638-233">Next steps</span></span>
<span data-ttu-id="c8638-234">En este artículo, hemos proporcionado información general a fin de dar una idea de los conceptos y procedimientos recomendados para crear particiones con cualquier API de Azure Cosmos DB.</span><span class="sxs-lookup"><span data-stu-id="c8638-234">In this article, we provided an overview for an overview of concepts and best practices for partitioning with any Azure Cosmos DB API.</span></span> 

* <span data-ttu-id="c8638-235">Información sobre el [procesamiento aprovisionado en Azure Cosmos DB](request-units.md)</span><span class="sxs-lookup"><span data-stu-id="c8638-235">Learn about [provisioned throughput in Azure Cosmos DB](request-units.md)</span></span>
* <span data-ttu-id="c8638-236">Información sobre la [distribución global en Azure Cosmos DB](distribute-data-globally.md)</span><span class="sxs-lookup"><span data-stu-id="c8638-236">Learn about [global distribution in Azure Cosmos DB](distribute-data-globally.md)</span></span>



