---
title: Uso de la biblioteca de clientes de Elastic Database con Entity Framework | Microsoft Docs
description: "Uso de la biblioteca de cliente de Base de datos elástica y Entity Framework para la codificación de bases de datos"
services: sql-database
documentationcenter: 
manager: jhubbard
author: torsteng
editor: 
ms.assetid: b9c3065b-cb92-41be-aa7f-deba23e7e159
ms.service: sql-database
ms.custom: scale out apps
ms.workload: sql-database
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 03/06/2017
ms.author: torsteng
ms.openlocfilehash: 2f0bff394c1e11a270cb324be5a1a45e9e531d7f
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 07/11/2017
---
# <a name="elastic-database-client-library-with-entity-framework"></a><span data-ttu-id="32931-103">Biblioteca de cliente de base de datos elástica con Entity Framework</span><span class="sxs-lookup"><span data-stu-id="32931-103">Elastic Database client library with Entity Framework</span></span>
<span data-ttu-id="32931-104">Este documento muestra los cambios que es necesario realizar en una aplicación de Entity Framework para su integración con las [herramientas de Base de datos elástica](sql-database-elastic-scale-introduction.md).</span><span class="sxs-lookup"><span data-stu-id="32931-104">This document shows the changes in an Entity Framework application that are needed to integrate with the [Elastic Database tools](sql-database-elastic-scale-introduction.md).</span></span> <span data-ttu-id="32931-105">Se centra en la composición de la [administración de mapas de particiones](sql-database-elastic-scale-shard-map-management.md) y el [enrutamiento dependiente de los datos](sql-database-elastic-scale-data-dependent-routing.md) con el enfoque **Code First** de Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="32931-105">The focus is on composing [shard map management](sql-database-elastic-scale-shard-map-management.md) and [data-dependent routing](sql-database-elastic-scale-data-dependent-routing.md) with the Entity Framework **Code First** approach.</span></span> <span data-ttu-id="32931-106">El tutorial [Code First – Nueva base de datos](http://msdn.microsoft.com/data/jj193542.aspx) para EF sirve como ejemplo en ejecución en este documento.</span><span class="sxs-lookup"><span data-stu-id="32931-106">The [Code First - New Database](http://msdn.microsoft.com/data/jj193542.aspx) tutorial for EF serves as our running example throughout this document.</span></span> <span data-ttu-id="32931-107">El código de ejemplo que acompaña a este documento forma parte del conjunto de ejemplos de las herramientas de bases de datos elásticas en los ejemplos de código de Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="32931-107">The sample code accompanying this document is part of elastic database tools' set of samples in the Visual Studio Code Samples.</span></span>

## <a name="downloading-and-running-the-sample-code"></a><span data-ttu-id="32931-108">Descarga y ejecución del código de ejemplo</span><span class="sxs-lookup"><span data-stu-id="32931-108">Downloading and Running the Sample Code</span></span>
<span data-ttu-id="32931-109">Para descargar el código de este artículo:</span><span class="sxs-lookup"><span data-stu-id="32931-109">To download the code for this article:</span></span>

* <span data-ttu-id="32931-110">Se requiere Visual Studio 2012 o posterior.</span><span class="sxs-lookup"><span data-stu-id="32931-110">Visual Studio 2012 or later is required.</span></span> 
* <span data-ttu-id="32931-111">Descargue el [ ejemplo Elastic DB Tools for Azure SQL - Entity Framework Integration (Herramientas de Elastic DB para SQL Azure: Integración con Entity Framework)](https://code.msdn.microsoft.com/windowsapps/Elastic-Scale-with-Azure-bae904ba) de MSDN.</span><span class="sxs-lookup"><span data-stu-id="32931-111">Download the [Elastic DB Tools for Azure SQL - Entity Framework Integration sample](https://code.msdn.microsoft.com/windowsapps/Elastic-Scale-with-Azure-bae904ba) from MSDN.</span></span> <span data-ttu-id="32931-112">Descomprima el ejemplo en una ubicación de su elección.</span><span class="sxs-lookup"><span data-stu-id="32931-112">Unzip the sample to a location of your choosing.</span></span>
* <span data-ttu-id="32931-113">Inicie Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="32931-113">Start Visual Studio.</span></span> 
* <span data-ttu-id="32931-114">En Visual Studio, seleccione Archivo -> Abrir proyecto/solución.</span><span class="sxs-lookup"><span data-stu-id="32931-114">In Visual Studio, select File -> Open Project/Solution.</span></span> 
* <span data-ttu-id="32931-115">En el cuadro de diálogo **Abrir proyecto**, vaya al ejemplo que descargó y seleccione **EntityFrameworkCodeFirst.sln** para abrir el ejemplo.</span><span class="sxs-lookup"><span data-stu-id="32931-115">In the **Open Project** dialog, navigate to the sample you downloaded and select **EntityFrameworkCodeFirst.sln** to open the sample.</span></span> 

<span data-ttu-id="32931-116">Para ejecutar el ejemplo, debe crear tres bases de datos vacías en Base de datos SQL de Azure:</span><span class="sxs-lookup"><span data-stu-id="32931-116">To run the sample, you need to create three empty databases in Azure SQL Database:</span></span>

* <span data-ttu-id="32931-117">Base de datos de administrador de mapas de particiones</span><span class="sxs-lookup"><span data-stu-id="32931-117">Shard Map Manager database</span></span>
* <span data-ttu-id="32931-118">Base de datos de partición 1</span><span class="sxs-lookup"><span data-stu-id="32931-118">Shard 1 database</span></span>
* <span data-ttu-id="32931-119">Base de datos de partición 2</span><span class="sxs-lookup"><span data-stu-id="32931-119">Shard 2 database</span></span>

<span data-ttu-id="32931-120">Cuando haya creado estas bases de datos, rellene los marcadores de posición en **Program.cs** con el nombre del servidor de Base de datos SQL de Azure, los nombres de base de datos y las credenciales para conectarse a las bases de datos.</span><span class="sxs-lookup"><span data-stu-id="32931-120">Once you have created these databases, fill in the place holders in **Program.cs** with your Azure SQL DB server name, the database names and your credentials to connect to the databases.</span></span> <span data-ttu-id="32931-121">Compile la solución en Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="32931-121">Build the solution in Visual Studio.</span></span> <span data-ttu-id="32931-122">Visual Studio descargará los paquetes de NuGet necesarios para la biblioteca de cliente de bases de datos elásticas, Entity Framework y control de errores transitorios como parte del proceso de compilación.</span><span class="sxs-lookup"><span data-stu-id="32931-122">Visual Studio will download the required NuGet packages for the elastic database client library, Entity Framework, and Transient Fault handling as part of the build process.</span></span> <span data-ttu-id="32931-123">Asegúrese de que la restauración de paquetes de NuGet está habilitada para la solución.</span><span class="sxs-lookup"><span data-stu-id="32931-123">Make sure that restoring NuGet packages is enabled for your solution.</span></span> <span data-ttu-id="32931-124">Puede habilitar esta configuración haciendo clic con el botón derecho en el archivo de solución en el Explorador de soluciones de Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="32931-124">You can enable this setting by right-clicking on the solution file in the Visual Studio Solution Explorer.</span></span> 

## <a name="entity-framework-workflows"></a><span data-ttu-id="32931-125">Flujos de trabajo de Entity Framework</span><span class="sxs-lookup"><span data-stu-id="32931-125">Entity Framework workflows</span></span>
<span data-ttu-id="32931-126">Los desarrolladores de Entity Framework se basan en uno de los cuatro flujos de trabajo siguientes para compilar aplicaciones y garantizar la persistencia de los objetos de la aplicación:</span><span class="sxs-lookup"><span data-stu-id="32931-126">Entity Framework developers rely on one of the following four workflows to build applications and to ensure persistence for application objects:</span></span> 

* <span data-ttu-id="32931-127">**Code First (nueva base de datos)**: el desarrollador de EF crea el modelo en el código de aplicación y luego EF genera la base de datos a partir de él.</span><span class="sxs-lookup"><span data-stu-id="32931-127">**Code First (New Database)**: The EF developer creates the model in the application code and then EF generates the database from it.</span></span> 
* <span data-ttu-id="32931-128">**Code First (base de datos existente)**: el desarrollador permite que EF genere el código de aplicación para el modelo de una base de datos existente.</span><span class="sxs-lookup"><span data-stu-id="32931-128">**Code First (Existing Database)**: The developer lets EF generate the application code for the model from an existing database.</span></span>
* <span data-ttu-id="32931-129">**Model First**: el desarrollador crea el modelo en el diseñador de EF y luego EF crea la base de datos a partir del modelo.</span><span class="sxs-lookup"><span data-stu-id="32931-129">**Model First**: The developer creates the model in the EF designer and then EF creates the database from the model.</span></span>
* <span data-ttu-id="32931-130">**Database First**: el desarrollador usa las herramientas de EF para deducir el modelo a partir de una base de datos existente.</span><span class="sxs-lookup"><span data-stu-id="32931-130">**Database First**: The developer uses EF tooling to infer the model from an existing database.</span></span> 

<span data-ttu-id="32931-131">Todos estos métodos se basan en la clase DbContext para administrar de forma transparente las conexiones de base de datos y el esquema de base de datos de una aplicación.</span><span class="sxs-lookup"><span data-stu-id="32931-131">All these approaches rely on the DbContext class to transparently manage database connections and database schema for an application.</span></span> <span data-ttu-id="32931-132">Como se explica con más detalle más adelante en el documento, diferentes constructores de la clase base DbContext permiten distintos niveles de control sobre la creación de la conexión, el arranque de base de datos y la creación del esquema.</span><span class="sxs-lookup"><span data-stu-id="32931-132">As we will discuss in more detail later in the document, different constructors on the DbContext base class allow for different levels of control over connection creation, database bootstrapping and schema creation.</span></span> <span data-ttu-id="32931-133">Los problemas surgen principalmente del hecho de que la administración de conexiones de base de datos proporcionada por EF interfiere con la funcionalidad de administración de conexiones de las interfaces de enrutamiento dependientes de datos proporcionadas por la biblioteca de cliente de bases de datos elásticas.</span><span class="sxs-lookup"><span data-stu-id="32931-133">Challenges arise primarily from the fact that the database connection management provided by EF intersects with the connection management capabilities of the data dependent routing interfaces provided by the elastic database client library.</span></span> 

## <a name="elastic-database-tools-assumptions"></a><span data-ttu-id="32931-134">Suposiciones de herramientas de bases de datos elásticas</span><span class="sxs-lookup"><span data-stu-id="32931-134">Elastic database tools assumptions</span></span>
<span data-ttu-id="32931-135">Para definiciones de términos, consulte el [Glosario de herramientas de Base de datos elástica](sql-database-elastic-scale-glossary.md).</span><span class="sxs-lookup"><span data-stu-id="32931-135">For term definitions, see [Elastic Database tools glossary](sql-database-elastic-scale-glossary.md).</span></span>

<span data-ttu-id="32931-136">Con la biblioteca de cliente de bases de datos elásticas, se definen particiones de los datos de la aplicación, denominadas shardlets.</span><span class="sxs-lookup"><span data-stu-id="32931-136">With elastic database client library, you define partitions of your application data called shardlets.</span></span> <span data-ttu-id="32931-137">Los shardlets se identifican mediante una clave de particionamiento y se asignan a bases de datos específicas.</span><span class="sxs-lookup"><span data-stu-id="32931-137">Shardlets are identified by a sharding key and are mapped to specific databases.</span></span> <span data-ttu-id="32931-138">Una aplicación puede tener tantas bases de datos como sea necesario y distribuir los shardlets para proporcionar suficiente capacidad o rendimiento en función de los requisitos del negocio actuales.</span><span class="sxs-lookup"><span data-stu-id="32931-138">An application may have as many databases as needed and distribute the shardlets to provide enough capacity or performance given current business requirements.</span></span> <span data-ttu-id="32931-139">La asignación de valores de clave de particionamiento a las bases de datos se almacena en un mapa de particiones que proporcionan las API de cliente de bases de datos elásticas.</span><span class="sxs-lookup"><span data-stu-id="32931-139">The mapping of sharding key values to the databases is stored by a shard map provided by the elastic database client APIs.</span></span> <span data-ttu-id="32931-140">A esta capacidad la denominamos **Administración de mapas de particiones**o, para abreviar, SMM.</span><span class="sxs-lookup"><span data-stu-id="32931-140">We call this capability **Shard Map Management**, or SMM for short.</span></span> <span data-ttu-id="32931-141">El mapa de particiones también funciona como el agente de conexiones de base de datos para las solicitudes que llevan una clave de particionamiento.</span><span class="sxs-lookup"><span data-stu-id="32931-141">The shard map also serves as the broker of database connections for requests that carry a sharding key.</span></span> <span data-ttu-id="32931-142">A esta capacidad nos referimos como **enrutamiento dependiente de datos**.</span><span class="sxs-lookup"><span data-stu-id="32931-142">We refer to this capability as **data-dependent routing**.</span></span> 

<span data-ttu-id="32931-143">El Administrador de mapas de particiones protege a los usuarios de vistas incoherentes en datos de shardlet que se pueden producir cuando se producen operaciones de administración de shardlets simultáneas (por ejemplo, la reubicación de datos de una partición a otra).</span><span class="sxs-lookup"><span data-stu-id="32931-143">The shard map manager protects users from inconsistent views into shardlet data that can occur when concurrent shardlet management operations (such as relocating data from one shard to another) are happening.</span></span> <span data-ttu-id="32931-144">Para ello, los mapas de particiones administrados por la biblioteca de cliente negocian las conexiones de base de datos de una aplicación.</span><span class="sxs-lookup"><span data-stu-id="32931-144">To do so, the shard maps managed by the client library broker the database connections for an application.</span></span> <span data-ttu-id="32931-145">Esto permite que la funcionalidad de asignación de mapas elimine automáticamente una conexión de base de datos cuando las operaciones de administración de particiones puedan afectar al shardlet para el que se ha creado la conexión.</span><span class="sxs-lookup"><span data-stu-id="32931-145">This allows the shard map functionality to automatically kill a database connection when shard management operations could impact the shardlet that the connection has been created for.</span></span> <span data-ttu-id="32931-146">Este enfoque debe integrarse con parte de la funcionalidad de EF, como la creación de nuevas conexiones a partir de otra existente, para comprobar la existencia de la base de datos.</span><span class="sxs-lookup"><span data-stu-id="32931-146">This approach needs to integrate with some of EF’s functionality, such as creating new connections from an existing one to check for database existence.</span></span> <span data-ttu-id="32931-147">En general, hemos observado que los constructores de DbContext estándar solo funcionan de forma confiable con las conexiones de base de datos cerradas que pueden clonarse para el funcionamiento de EF.</span><span class="sxs-lookup"><span data-stu-id="32931-147">In general, our observation has been that the standard DbContext constructors only work reliably for closed database connections that can safely be cloned for EF work.</span></span> <span data-ttu-id="32931-148">En lugar de ello, el principio de diseño de la base de datos elástica solo negocia conexiones abiertas.</span><span class="sxs-lookup"><span data-stu-id="32931-148">The design principle of elastic database instead is to only broker opened connections.</span></span> <span data-ttu-id="32931-149">Se podría pensar que cerrando una conexión negociada por la biblioteca de cliente antes de entregarla a DbContext de EF resolvería este problema.</span><span class="sxs-lookup"><span data-stu-id="32931-149">One might think that closing a connection brokered by the client library before handing it over to the EF DbContext may solve this issue.</span></span> <span data-ttu-id="32931-150">Sin embargo, al cerrar la conexión y depender de EF para volver a abrirla, se renuncia a las comprobaciones de validación y coherencia que realiza la biblioteca.</span><span class="sxs-lookup"><span data-stu-id="32931-150">However, by closing the connection and relying on EF to re-open it, one foregoes the validation and consistency checks performed by the library.</span></span> <span data-ttu-id="32931-151">Sin embargo, la funcionalidad de migraciones de EF usa estas conexiones para administrar el esquema de base de datos subyacente de forma transparente a la aplicación.</span><span class="sxs-lookup"><span data-stu-id="32931-151">The migrations functionality in EF, however, uses these connections to manage the underlying database schema in a way that is transparent to the application.</span></span> <span data-ttu-id="32931-152">Idealmente, desearíamos conservar y combinar todas estas funcionalidades de la biblioteca de cliente de bases de datos elásticas y EF en la misma aplicación.</span><span class="sxs-lookup"><span data-stu-id="32931-152">Ideally, we would like to retain and combine all these capabilities from both the elastic database client library and EF in the same application.</span></span> <span data-ttu-id="32931-153">En la siguiente sección se describen estas propiedades y los requisitos con más detalle.</span><span class="sxs-lookup"><span data-stu-id="32931-153">The following section discusses these properties and requirements in more detail.</span></span> 

## <a name="requirements"></a><span data-ttu-id="32931-154">Requisitos</span><span class="sxs-lookup"><span data-stu-id="32931-154">Requirements</span></span>
<span data-ttu-id="32931-155">Cuando se trabaja con la biblioteca de cliente de bases de datos elásticas y las API de Entity Framework, queremos conservar las propiedades siguientes:</span><span class="sxs-lookup"><span data-stu-id="32931-155">When working with both the elastic database client library and Entity Framework APIs, we want to retain the following properties:</span></span> 

* <span data-ttu-id="32931-156">**Escalado horizontal**: es necesario poder agregar o quitar bases de datos de la capa de datos de la aplicación particionada cuando las demandas de capacidad de la aplicación lo requieran.</span><span class="sxs-lookup"><span data-stu-id="32931-156">**Scale-out**: To add or remove databases from the data tier of the sharded application as necessary for the capacity demands of the application.</span></span> <span data-ttu-id="32931-157">Esto se traduce en control sobre la creación y eliminación de bases de datos y el uso de las API del administrador de mapas de particiones de bases de datos elásticas para administrar bases de datos y las asignaciones de shardlets.</span><span class="sxs-lookup"><span data-stu-id="32931-157">This means control over the the creation and deletion of databases and using the elastic database shard map manager APIs to manage databases, and mappings of shardlets.</span></span> 
* <span data-ttu-id="32931-158">**Coherencia**: la aplicación emplea particionamiento y usa la funcionalidad de enrutamiento dependiente de datos de Escalado elástico.</span><span class="sxs-lookup"><span data-stu-id="32931-158">**Consistency**: The application employs sharding, and uses the data dependent routing capabilities of the client library.</span></span> <span data-ttu-id="32931-159">Para evitar daños o resultados de la consulta incorrectos, las conexiones se negocian mediante el administrador de mapas de particiones.</span><span class="sxs-lookup"><span data-stu-id="32931-159">To avoid corruption or wrong query results, connections are brokered through the shard map manager.</span></span> <span data-ttu-id="32931-160">También mantiene la validación y la coherencia.</span><span class="sxs-lookup"><span data-stu-id="32931-160">This also retains validation and consistency.</span></span>
* <span data-ttu-id="32931-161">**Code First**: permite conservar la ventaja del paradigma de Code First de EF.</span><span class="sxs-lookup"><span data-stu-id="32931-161">**Code First**: To retain the convenience of EF’s code first paradigm.</span></span> <span data-ttu-id="32931-162">En Code First, las clases de la aplicación se asignan de manera transparente a las estructuras de base de datos subyacente.</span><span class="sxs-lookup"><span data-stu-id="32931-162">In Code First, classes in the application are mapped transparently to the underlying database structures.</span></span> <span data-ttu-id="32931-163">El código de aplicación interactúa con DbSets que enmascaran la mayoría de los aspectos implicados en el procesamiento de la base de datos subyacente.</span><span class="sxs-lookup"><span data-stu-id="32931-163">The application code interacts with DbSets that mask most aspects involved in the underlying database processing.</span></span>
* <span data-ttu-id="32931-164">**Esquema**: Entity Framework controla la creación del esquema de base de datos inicial y la evolución del esquema posterior a través de migraciones.</span><span class="sxs-lookup"><span data-stu-id="32931-164">**Schema**: Entity Framework handles initial database schema creation and subsequent schema evolution through migrations.</span></span> <span data-ttu-id="32931-165">Al conservar estas capacidades, la adaptación de la aplicación se simplifica a medida que los datos evolucionan.</span><span class="sxs-lookup"><span data-stu-id="32931-165">By retaining these capabilities, adapting your app is easy as the data evolves.</span></span> 

<span data-ttu-id="32931-166">Las instrucciones siguientes indican cómo satisfacer estos requisitos para las aplicaciones de Code First con las herramientas de bases de datos elásticas.</span><span class="sxs-lookup"><span data-stu-id="32931-166">The following guidance instructs how to satisfy these requirements for Code First applications using elastic database tools.</span></span> 

## <a name="data-dependent-routing-using-ef-dbcontext"></a><span data-ttu-id="32931-167">Enrutamiento dependiente de datos con DbContext de EF</span><span class="sxs-lookup"><span data-stu-id="32931-167">Data dependent routing using EF DbContext</span></span>
<span data-ttu-id="32931-168">Las conexiones de base de datos con Entity Framework se suelen administrar mediante subclases de **DbContext**.</span><span class="sxs-lookup"><span data-stu-id="32931-168">Database connections with Entity Framework are typically managed through subclasses of **DbContext**.</span></span> <span data-ttu-id="32931-169">Cree estas subclases basándose en **DbContext**.</span><span class="sxs-lookup"><span data-stu-id="32931-169">Create these subclasses by deriving from **DbContext**.</span></span> <span data-ttu-id="32931-170">Aquí es donde define los **DbSets** que implementan las colecciones de objetos CLR con respaldo de base de datos para la aplicación.</span><span class="sxs-lookup"><span data-stu-id="32931-170">This is where you define your **DbSets** that implement the database-backed collections of CLR objects for your application.</span></span> <span data-ttu-id="32931-171">En el contexto de enrutamiento dependiente de datos, podemos identificar varias propiedades útiles que no necesariamente se incluyen en otros escenarios de aplicación EF Code First:</span><span class="sxs-lookup"><span data-stu-id="32931-171">In the context of data dependent routing, we can identify several helpful properties that do not necessarily hold for other EF code first application scenarios:</span></span> 

* <span data-ttu-id="32931-172">La base de datos ya existe y se ha registrado en el mapa de particiones de bases de datos elásticas.</span><span class="sxs-lookup"><span data-stu-id="32931-172">The database already exists and has been registered in the elastic database shard map.</span></span> 
* <span data-ttu-id="32931-173">El esquema de la aplicación ya se ha implementado en la base de datos (que se explica más adelante).</span><span class="sxs-lookup"><span data-stu-id="32931-173">The schema of the application has already been deployed to the database (explained below).</span></span> 
* <span data-ttu-id="32931-174">Las conexiones de enrutamiento dependiente de datos con la base de datos se negocian con el mapa de particiones.</span><span class="sxs-lookup"><span data-stu-id="32931-174">Data-dependent routing connections to the database are brokered by the shard map.</span></span> 

<span data-ttu-id="32931-175">Para integrar **DbContexts** con enrutamiento dependiente de datos para escalado horizontal:</span><span class="sxs-lookup"><span data-stu-id="32931-175">To integrate **DbContexts** with data-dependent routing for scale-out:</span></span>

1. <span data-ttu-id="32931-176">Cree conexiones de base de datos física a través de las interfaces de cliente de bases de datos elásticas del administrador de mapas de particiones.</span><span class="sxs-lookup"><span data-stu-id="32931-176">Create physical database connections through the elastic database client interfaces of the shard map manager,</span></span> 
2. <span data-ttu-id="32931-177">Ajuste la conexión con la subclase **DbContext** .</span><span class="sxs-lookup"><span data-stu-id="32931-177">Wrap the connection with the **DbContext** subclass</span></span>
3. <span data-ttu-id="32931-178">Transfiera la conexión a las clases base **DbContext** para asegurarse de que también se produce todo el procesamiento del lado EF.</span><span class="sxs-lookup"><span data-stu-id="32931-178">Pass the connection down into the **DbContext** base classes to ensure all the processing on the EF side happens as well.</span></span> 

<span data-ttu-id="32931-179">En el ejemplo de código siguiente se muestra este método.</span><span class="sxs-lookup"><span data-stu-id="32931-179">The following code example illustrates this approach.</span></span> <span data-ttu-id="32931-180">(Este código también se encuentra en el proyecto de Visual Studio adjunto).</span><span class="sxs-lookup"><span data-stu-id="32931-180">(This code is also in the accompanying Visual Studio project)</span></span>

    public class ElasticScaleContext<T> : DbContext
    {
    public DbSet<Blog> Blogs { get; set; }
    …

        // C'tor for data dependent routing. This call will open a validated connection 
        // routed to the proper shard by the shard map manager. 
        // Note that the base class c'tor call will fail for an open connection
        // if migrations need to be done and SQL credentials are used. This is the reason for the 
        // separation of c'tors into the data-dependent routing case (this c'tor) and the internal c'tor for new shards.
        public ElasticScaleContext(ShardMap shardMap, T shardingKey, string connectionStr)
            : base(CreateDDRConnection(shardMap, shardingKey, connectionStr), 
            true /* contextOwnsConnection */)
        {
        }

        // Only static methods are allowed in calls into base class c'tors.
        private static DbConnection CreateDDRConnection(
        ShardMap shardMap, 
        T shardingKey, 
        string connectionStr)
        {
            // No initialization
            Database.SetInitializer<ElasticScaleContext<T>>(null);

            // Ask shard map to broker a validated connection for the given key
            SqlConnection conn = shardMap.OpenConnectionForKey<T>
                                (shardingKey, connectionStr, ConnectionOptions.Validate);
            return conn;
        }    

## <a name="main-points"></a><span data-ttu-id="32931-181">Puntos principales</span><span class="sxs-lookup"><span data-stu-id="32931-181">Main points</span></span>
* <span data-ttu-id="32931-182">Un nuevo constructor reemplaza al constructor predeterminado en la subclase DbContext</span><span class="sxs-lookup"><span data-stu-id="32931-182">A new constructor replaces the default constructor in the DbContext subclass</span></span> 
* <span data-ttu-id="32931-183">El nuevo constructor adopta los argumentos necesarios para el enrutamiento dependiente de datos a través de la biblioteca de cliente de bases de datos elásticas:</span><span class="sxs-lookup"><span data-stu-id="32931-183">The new constructor takes the arguments that are required for data dependent routing through elastic database client library:</span></span>
  
  * <span data-ttu-id="32931-184">El mapa de particiones para acceder a las interfaces de enrutamiento dependiente de datos.</span><span class="sxs-lookup"><span data-stu-id="32931-184">the shard map to access the data-dependent routing interfaces,</span></span>
  * <span data-ttu-id="32931-185">La clave de particionamiento para identificar el shardlet.</span><span class="sxs-lookup"><span data-stu-id="32931-185">the sharding key to identify the shardlet,</span></span>
  * <span data-ttu-id="32931-186">Una cadena de conexión con las credenciales para la conexión de enrutamiento dependiente de datos a la partición.</span><span class="sxs-lookup"><span data-stu-id="32931-186">a connection string with the credentials for the data-dependent routing connection to the shard.</span></span> 
* <span data-ttu-id="32931-187">La llamada al constructor de clase base se desvía a un método estático que realiza todos los pasos necesarios para enrutamiento dependiente de datos.</span><span class="sxs-lookup"><span data-stu-id="32931-187">The call to the base class constructor takes a detour into a static method that performs all the steps necessary for data-dependent routing.</span></span> 
  
  * <span data-ttu-id="32931-188">Usa la llamada OpenConnectionForKey de las interfaces de cliente de bases de datos elásticas en el mapa de particiones para establecer una conexión abierta.</span><span class="sxs-lookup"><span data-stu-id="32931-188">It uses the OpenConnectionForKey call of the elastic database client interfaces on the shard map to establish an open connection.</span></span>
  * <span data-ttu-id="32931-189">El mapa de particiones crea la conexión abierta con la partición que contiene el shardlet para la clave de particionamiento especificada.</span><span class="sxs-lookup"><span data-stu-id="32931-189">The shard map creates the open connection to the shard that holds the shardlet for the given sharding key.</span></span>
  * <span data-ttu-id="32931-190">Esta conexión abierta se transfiere de nuevo al constructor de la clase base DbContext para indicar que se va a usar esta conexión en EF en lugar de dejar que EF cree automáticamente una conexión.</span><span class="sxs-lookup"><span data-stu-id="32931-190">This open connection is passed back to the base class constructor of DbContext to indicate that this connection is to be used by EF instead of letting EF create a new connection automatically.</span></span> <span data-ttu-id="32931-191">De este modo, la API de cliente de bases de datos elásticas etiqueta la conexión para que pueda garantizar la coherencia en las operaciones de administración de mapas de particiones.</span><span class="sxs-lookup"><span data-stu-id="32931-191">This way the connection has been tagged by the elastic database client API so that it can guarantee consistency under shard map management operations.</span></span>

<span data-ttu-id="32931-192">Use en el código el nuevo constructor para la subclase DbContext en lugar del constructor predeterminado.</span><span class="sxs-lookup"><span data-stu-id="32931-192">Use the new constructor for your DbContext subclass instead of the default constructor in your code.</span></span> <span data-ttu-id="32931-193">Aquí tiene un ejemplo:</span><span class="sxs-lookup"><span data-stu-id="32931-193">Here is an example:</span></span> 

    // Create and save a new blog.

    Console.Write("Enter a name for a new blog: "); 
    var name = Console.ReadLine(); 

    using (var db = new ElasticScaleContext<int>( 
                            sharding.ShardMap,  
                            tenantId1,  
                            connStrBldr.ConnectionString)) 
    { 
        var blog = new Blog { Name = name }; 
        db.Blogs.Add(blog); 
        db.SaveChanges(); 

        // Display all Blogs for tenant 1 
        var query = from b in db.Blogs 
                    orderby b.Name 
                    select b; 
     … 
    }

<span data-ttu-id="32931-194">El nuevo constructor abre la conexión con la partición que contiene los datos para el shardlet identificado por el valor de **tenantid1**.</span><span class="sxs-lookup"><span data-stu-id="32931-194">The new constructor opens the connection to the shard that holds the data for the shardlet identified by the value of **tenantid1**.</span></span> <span data-ttu-id="32931-195">El código en el bloque **using** permanece sin cambios para acceder al **DbSet** de los blogs que usan EF en la partición de **tenantid1**.</span><span class="sxs-lookup"><span data-stu-id="32931-195">The code in the **using** block stays unchanged to access the **DbSet** for blogs using EF on the shard for **tenantid1**.</span></span> <span data-ttu-id="32931-196">Esto cambia la semántica para el código del bloque using de modo que todas las operaciones de base de datos ahora se limitan a la partición donde se guarda **tenantid1** .</span><span class="sxs-lookup"><span data-stu-id="32931-196">This changes semantics for the code in the using block such that all database operations are now scoped to the one shard where **tenantid1** is kept.</span></span> <span data-ttu-id="32931-197">Por ejemplo, una consulta LINQ en los blogs de **DbSet** solo devolvería los blogs almacenados en la partición actual, pero no los almacenados en otras particiones.</span><span class="sxs-lookup"><span data-stu-id="32931-197">For instance, a LINQ query over the blogs **DbSet** would only return blogs stored on the current shard, but not the ones stored on other shards.</span></span>  

#### <a name="transient-faults-handling"></a><span data-ttu-id="32931-198">Control de errores transitorios</span><span class="sxs-lookup"><span data-stu-id="32931-198">Transient faults handling</span></span>
<span data-ttu-id="32931-199">El equipo de Microsoft Patterns & Practices publicó el artículo sobre el [bloque de aplicación de gestión de errores transitorios](https://msdn.microsoft.com/library/dn440719.aspx).</span><span class="sxs-lookup"><span data-stu-id="32931-199">The Microsoft Patterns & Practices team published the [The Transient Fault Handling Application Block](https://msdn.microsoft.com/library/dn440719.aspx).</span></span> <span data-ttu-id="32931-200">La biblioteca se usa con la biblioteca de cliente de escalado elástico conjuntamente con EF.</span><span class="sxs-lookup"><span data-stu-id="32931-200">The library is used with elastic scale client library in combination with EF.</span></span> <span data-ttu-id="32931-201">Sin embargo, asegúrese de que cualquier excepción transitoria se devuelve a un lugar donde podamos garantizar que después de un error transitorio se usa el nuevo constructor para que cualquier nuevo intento de conexión se realice con los constructores que hemos ajustado.</span><span class="sxs-lookup"><span data-stu-id="32931-201">However, ensure that any transient exception returns to a place where we can ensure that the new constructor is being used after a transient fault so that any new connection attempt is made using the constructors we have tweaked.</span></span> <span data-ttu-id="32931-202">De lo contrario, no se garantiza una conexión a la partición correcta y no hay ninguna certeza de que la conexión se mantiene cuando se producen cambios en el mapa de particiones.</span><span class="sxs-lookup"><span data-stu-id="32931-202">Otherwise, a connection to the correct shard is not guaranteed, and there are no assurances the connection is maintained as changes to the shard map occur.</span></span> 

<span data-ttu-id="32931-203">El ejemplo de código siguiente muestra cómo se puede usar una directiva de reintentos SQL en torno a los nuevos constructores de subclase **DbContext** :</span><span class="sxs-lookup"><span data-stu-id="32931-203">The following code sample illustrates how a SQL retry policy can be used around the new **DbContext** subclass constructors:</span></span> 

    SqlDatabaseUtils.SqlRetryPolicy.ExecuteAction(() => 
    { 
        using (var db = new ElasticScaleContext<int>( 
                                sharding.ShardMap,  
                                tenantId1,  
                                connStrBldr.ConnectionString)) 
            { 
                    var blog = new Blog { Name = name }; 
                    db.Blogs.Add(blog); 
                    db.SaveChanges(); 
            … 
            } 
        }); 

<span data-ttu-id="32931-204">**SqlDatabaseUtils.SqlRetryPolicy** en el código anterior se define como **SqlDatabaseTransientErrorDetectionStrategy** con un número de reintentos de 10 y un tiempo de espera de 5 segundos entre reintentos.</span><span class="sxs-lookup"><span data-stu-id="32931-204">**SqlDatabaseUtils.SqlRetryPolicy** in the code above is defined as a **SqlDatabaseTransientErrorDetectionStrategy** with a retry count of 10, and 5 seconds wait time between retries.</span></span> <span data-ttu-id="32931-205">Este enfoque es parecido a las instrucciones para EF y las transacciones iniciadas por el usuario (consulte las [limitaciones con las estrategias de ejecución de reintentos [EF6 en adelante])](http://msdn.microsoft.com/data/dn307226).</span><span class="sxs-lookup"><span data-stu-id="32931-205">This approach is similar to the guidance for EF and user-initiated transactions (see [Limitations with Retrying Execution Strategies (EF6 onwards)](http://msdn.microsoft.com/data/dn307226).</span></span> <span data-ttu-id="32931-206">En ambas situaciones es necesario que el programa de la aplicación controle el ámbito en el que se devuelve la excepción transitoria: para volver a abrir la transacción o (como se muestra) volver a crear el contexto a partir del constructor adecuado que usa la biblioteca de cliente de bases de datos elásticas.</span><span class="sxs-lookup"><span data-stu-id="32931-206">Both situations require that the application program controls the scope to which the transient exception returns: to either reopen the transaction, or (as shown) recreate the context from the proper constructor that uses the elastic database client library.</span></span>

<span data-ttu-id="32931-207">La necesidad de controlar dónde las excepciones transitorias nos llevan de vuelta en el ámbito también impide el uso de la **SqlAzureExecutionStrategy** integrada que se incluye con EF.</span><span class="sxs-lookup"><span data-stu-id="32931-207">The need to control where transient exceptions take us back in scope also precludes the use of the built-in **SqlAzureExecutionStrategy** that comes with EF.</span></span> <span data-ttu-id="32931-208">**SqlAzureExecutionStrategy** volvería a abrir la conexión pero no usa **OpenConnectionForKey** y, por tanto, pasa por alto toda la validación que se realiza como parte de la llamada **OpenConnectionForKey**.</span><span class="sxs-lookup"><span data-stu-id="32931-208">**SqlAzureExecutionStrategy** would reopen a connection but not use **OpenConnectionForKey** and therefore bypass all the validation that is performed as part of the **OpenConnectionForKey** call.</span></span> <span data-ttu-id="32931-209">En su lugar, el código de ejemplo usa **DefaultExecutionStrategy** integrada que también se incluye con EF.</span><span class="sxs-lookup"><span data-stu-id="32931-209">Instead, the code sample uses the built-in **DefaultExecutionStrategy** that also comes with EF.</span></span> <span data-ttu-id="32931-210">Al contrario que **SqlAzureExecutionStrategy**, funciona correctamente en combinación con la directiva de reintentos de gestión de errores transitorios.</span><span class="sxs-lookup"><span data-stu-id="32931-210">As opposed to **SqlAzureExecutionStrategy**, it works correctly in combination with the retry policy from Transient Fault Handling.</span></span> <span data-ttu-id="32931-211">La directiva de ejecución se establece en la clase **ElasticScaleDbConfiguration** .</span><span class="sxs-lookup"><span data-stu-id="32931-211">The execution policy is set in the **ElasticScaleDbConfiguration** class.</span></span> <span data-ttu-id="32931-212">Tenga en cuenta que hemos decidido no usar **DefaultSqlExecutionStrategy** dado que sugiere el uso de **SqlAzureExecutionStrategy** si se producen excepciones transitorias, lo que podría llevar a un comportamiento erróneo, como hemos comentado.</span><span class="sxs-lookup"><span data-stu-id="32931-212">Note that we decided not to use **DefaultSqlExecutionStrategy** since it suggests to use **SqlAzureExecutionStrategy** if transient exceptions occur - which would lead to wrong behavior as discussed.</span></span> <span data-ttu-id="32931-213">Para obtener más información sobre las diferentes directivas de reintento y EF, consulte [Resistencia de conexión en EF](http://msdn.microsoft.com/data/dn456835.aspx).</span><span class="sxs-lookup"><span data-stu-id="32931-213">For more information on the different retry policies and EF, see [Connection Resiliency in EF](http://msdn.microsoft.com/data/dn456835.aspx).</span></span>     

#### <a name="constructor-rewrites"></a><span data-ttu-id="32931-214">Reescrituras del constructor</span><span class="sxs-lookup"><span data-stu-id="32931-214">Constructor rewrites</span></span>
<span data-ttu-id="32931-215">Los ejemplos de código anteriores muestran las reescrituras del constructor predeterminado que requiere la aplicación para usar enrutamiento dependiente de datos con Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="32931-215">The code examples above illustrate the default constructor re-writes required for your application in order to use  data dependent routing with the Entity Framework.</span></span> <span data-ttu-id="32931-216">La siguiente tabla generaliza este método para otros constructores.</span><span class="sxs-lookup"><span data-stu-id="32931-216">The following table generalizes this approach to other constructors.</span></span> 

| <span data-ttu-id="32931-217">Constructor actual</span><span class="sxs-lookup"><span data-stu-id="32931-217">Current Constructor</span></span> | <span data-ttu-id="32931-218">Constructor reescrito para datos</span><span class="sxs-lookup"><span data-stu-id="32931-218">Rewritten Constructor for data</span></span> | <span data-ttu-id="32931-219">Constructor base</span><span class="sxs-lookup"><span data-stu-id="32931-219">Base Constructor</span></span> | <span data-ttu-id="32931-220">Notas</span><span class="sxs-lookup"><span data-stu-id="32931-220">Notes</span></span> |
| --- | --- | --- | --- |
| <span data-ttu-id="32931-221">MyContext()</span><span class="sxs-lookup"><span data-stu-id="32931-221">MyContext()</span></span> |<span data-ttu-id="32931-222">ElasticScaleContext(ShardMap, TKey)</span><span class="sxs-lookup"><span data-stu-id="32931-222">ElasticScaleContext(ShardMap, TKey)</span></span> |<span data-ttu-id="32931-223">DbContext(DbConnection, bool)</span><span class="sxs-lookup"><span data-stu-id="32931-223">DbContext(DbConnection, bool)</span></span> |<span data-ttu-id="32931-224">La conexión debe ser una función de la asignación de particiones y la clave de enrutamiento dependiente de datos.</span><span class="sxs-lookup"><span data-stu-id="32931-224">The connection needs to be a function of the shard map and the data-dependent routing key.</span></span> <span data-ttu-id="32931-225">Se debe omitir la creación de conexión automática por parte de EF y usar en su lugar el mapa de particiones para negociar la conexión.</span><span class="sxs-lookup"><span data-stu-id="32931-225">You need to by-pass automatic connection creation by EF and instead use the shard map to broker the connection.</span></span> |
| <span data-ttu-id="32931-226">MyContext(string)</span><span class="sxs-lookup"><span data-stu-id="32931-226">MyContext(string)</span></span> |<span data-ttu-id="32931-227">ElasticScaleContext(ShardMap, TKey)</span><span class="sxs-lookup"><span data-stu-id="32931-227">ElasticScaleContext(ShardMap, TKey)</span></span> |<span data-ttu-id="32931-228">DbContext(DbConnection, bool)</span><span class="sxs-lookup"><span data-stu-id="32931-228">DbContext(DbConnection, bool)</span></span> |<span data-ttu-id="32931-229">La conexión es una función del mapa de particiones y la clave de enrutamiento dependiente de datos.</span><span class="sxs-lookup"><span data-stu-id="32931-229">The connection is a function of the shard map and the data-dependent routing key.</span></span> <span data-ttu-id="32931-230">Una cadena de nombre de base de datos o de conexión fija no funcionará ya que omite la validación por parte del mapa de particiones.</span><span class="sxs-lookup"><span data-stu-id="32931-230">A fixed database name or connection string will not work as they by-pass validation by the shard map.</span></span> |
| <span data-ttu-id="32931-231">MyContext(DbCompiledModel)</span><span class="sxs-lookup"><span data-stu-id="32931-231">MyContext(DbCompiledModel)</span></span> |<span data-ttu-id="32931-232">ElasticScaleContext(ShardMap, TKey, DbCompiledModel)</span><span class="sxs-lookup"><span data-stu-id="32931-232">ElasticScaleContext(ShardMap, TKey, DbCompiledModel)</span></span> |<span data-ttu-id="32931-233">DbContext(DbConnection, DbCompiledModel, bool)</span><span class="sxs-lookup"><span data-stu-id="32931-233">DbContext(DbConnection, DbCompiledModel, bool)</span></span> |<span data-ttu-id="32931-234">La conexión se creará para el mapa de particiones determinado y la clave de particionamiento con el modelo proporcionado.</span><span class="sxs-lookup"><span data-stu-id="32931-234">The connection will get created for the given shard map and sharding key with the model provided.</span></span> <span data-ttu-id="32931-235">El modelo compilado se transferirá al constructor base.</span><span class="sxs-lookup"><span data-stu-id="32931-235">The compiled model will be passed on to the base c’tor.</span></span> |
| <span data-ttu-id="32931-236">MyContext(DbConnection, bool)</span><span class="sxs-lookup"><span data-stu-id="32931-236">MyContext(DbConnection, bool)</span></span> |<span data-ttu-id="32931-237">ElasticScaleContext(ShardMap, TKey, bool)</span><span class="sxs-lookup"><span data-stu-id="32931-237">ElasticScaleContext(ShardMap, TKey, bool)</span></span> |<span data-ttu-id="32931-238">DbContext(DbConnection, bool)</span><span class="sxs-lookup"><span data-stu-id="32931-238">DbContext(DbConnection, bool)</span></span> |<span data-ttu-id="32931-239">La conexión se tiene que deducir del mapa de particiones y la clave.</span><span class="sxs-lookup"><span data-stu-id="32931-239">The connection needs to be inferred from the shard map and the key.</span></span> <span data-ttu-id="32931-240">No se puede especificar como entrada (a menos que la entrada ya use el mapa de particiones y la clave).</span><span class="sxs-lookup"><span data-stu-id="32931-240">It cannot be provided as an input (unless that input was already using the shard map and the key).</span></span> <span data-ttu-id="32931-241">Se transferirá el valor booleano.</span><span class="sxs-lookup"><span data-stu-id="32931-241">The Boolean will be passed on.</span></span> |
| <span data-ttu-id="32931-242">MyContext(string, DbCompiledModel)</span><span class="sxs-lookup"><span data-stu-id="32931-242">MyContext(string, DbCompiledModel)</span></span> |<span data-ttu-id="32931-243">ElasticScaleContext(ShardMap, TKey, DbCompiledModel)</span><span class="sxs-lookup"><span data-stu-id="32931-243">ElasticScaleContext(ShardMap, TKey, DbCompiledModel)</span></span> |<span data-ttu-id="32931-244">DbContext(DbConnection, DbCompiledModel, bool)</span><span class="sxs-lookup"><span data-stu-id="32931-244">DbContext(DbConnection, DbCompiledModel, bool)</span></span> |<span data-ttu-id="32931-245">La conexión se tiene que deducir del mapa de particiones y la clave.</span><span class="sxs-lookup"><span data-stu-id="32931-245">The connection needs to be inferred from the shard map and the key.</span></span> <span data-ttu-id="32931-246">No se puede especificar como entrada (a menos que la entrada use el mapa de particiones y la clave).</span><span class="sxs-lookup"><span data-stu-id="32931-246">It cannot be provided as an input (unless that input was using the shard map and the key).</span></span> <span data-ttu-id="32931-247">Se transferirá el modelo compilado.</span><span class="sxs-lookup"><span data-stu-id="32931-247">The compiled model will be passed on.</span></span> |
| <span data-ttu-id="32931-248">MyContext(ObjectContext, bool)</span><span class="sxs-lookup"><span data-stu-id="32931-248">MyContext(ObjectContext, bool)</span></span> |<span data-ttu-id="32931-249">ElasticScaleContext(ShardMap, TKey, ObjectContext, bool)</span><span class="sxs-lookup"><span data-stu-id="32931-249">ElasticScaleContext(ShardMap, TKey, ObjectContext, bool)</span></span> |<span data-ttu-id="32931-250">DbContext(ObjectContext, bool)</span><span class="sxs-lookup"><span data-stu-id="32931-250">DbContext(ObjectContext, bool)</span></span> |<span data-ttu-id="32931-251">El nuevo constructor debe asegurarse de que las conexiones de ObjectContext pasado como entrada se vuelve a enrutar a una conexión administrada por el escalado elástico.</span><span class="sxs-lookup"><span data-stu-id="32931-251">The new constructor needs to ensure that any connection in the ObjectContext passed as an input is re-routed to a connection managed by Elastic Scale.</span></span> <span data-ttu-id="32931-252">No es el objetivo de este documento dar una explicación detallada de ObjectContext.</span><span class="sxs-lookup"><span data-stu-id="32931-252">A detailed discussion of ObjectContexts is beyond the scope of this document.</span></span> |
| <span data-ttu-id="32931-253">MyContext(DbConnection, DbCompiledModel,bool)</span><span class="sxs-lookup"><span data-stu-id="32931-253">MyContext(DbConnection, DbCompiledModel,bool)</span></span> |<span data-ttu-id="32931-254">ElasticScaleContext(ShardMap, TKey, DbCompiledModel, bool)</span><span class="sxs-lookup"><span data-stu-id="32931-254">ElasticScaleContext(ShardMap, TKey, DbCompiledModel, bool)</span></span> |<span data-ttu-id="32931-255">DbContext(DbConnection, DbCompiledModel, bool);</span><span class="sxs-lookup"><span data-stu-id="32931-255">DbContext(DbConnection, DbCompiledModel, bool);</span></span> |<span data-ttu-id="32931-256">La conexión se tiene que deducir del mapa de particiones y la clave.</span><span class="sxs-lookup"><span data-stu-id="32931-256">The connection needs to be inferred from the shard map and the key.</span></span> <span data-ttu-id="32931-257">La conexión no se puede especificar como entrada (a menos que la entrada ya use el mapa de particiones y la clave).</span><span class="sxs-lookup"><span data-stu-id="32931-257">The connection cannot be provided as an input (unless that input was already using the shard map and the key).</span></span> <span data-ttu-id="32931-258">El modelo y los valores booleanos se transfieren al constructor de clase base.</span><span class="sxs-lookup"><span data-stu-id="32931-258">Model and Boolean are passed on to the base class constructor.</span></span> |

## <a name="shard-schema-deployment-through-ef-migrations"></a><span data-ttu-id="32931-259">Implementación del esquema de partición mediante migraciones de EF</span><span class="sxs-lookup"><span data-stu-id="32931-259">Shard schema deployment through EF migrations</span></span>
<span data-ttu-id="32931-260">La administración automática de esquemas es una ventaja que ofrece Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="32931-260">Automatic schema management is a convenience provided by the Entity Framework.</span></span> <span data-ttu-id="32931-261">En el contexto de aplicaciones con herramientas de bases de datos elásticas, queremos conservar esta capacidad para aprovisionar automáticamente el esquema a las particiones recién creadas cuando se agregan bases de datos a la aplicación particionada.</span><span class="sxs-lookup"><span data-stu-id="32931-261">In the context of applications using elastic database tools, we want to retain this capability to automatically provision the schema to newly created shards when databases are added to the sharded application.</span></span> <span data-ttu-id="32931-262">El principal caso de uso es aumentar la capacidad en la capa de datos para aplicaciones particionadas con EF.</span><span class="sxs-lookup"><span data-stu-id="32931-262">The primary use case is to increase capacity at the data tier for sharded applications using EF.</span></span> <span data-ttu-id="32931-263">Al basarse en la funcionalidad de EF para la administración de esquemas se reducen las tareas de administración de base de datos con una aplicación particionada que esté integrada en EF.</span><span class="sxs-lookup"><span data-stu-id="32931-263">Relying on EF’s capabilities for schema management reduces the database administration effort with a sharded application built on EF.</span></span> 

<span data-ttu-id="32931-264">La implementación del esquema a través de migraciones de EF funciona mejor en **conexiones sin abrir**.</span><span class="sxs-lookup"><span data-stu-id="32931-264">Schema deployment through EF migrations works best on **unopened connections**.</span></span> <span data-ttu-id="32931-265">Esto difiere del escenario de enrutamiento dependiente de datos que se basa en la conexión abierta que proporciona la API de cliente de bases de datos elásticas.</span><span class="sxs-lookup"><span data-stu-id="32931-265">This is in contrast to the scenario for data dependent routing that relies on the opened connection provided by the elastic database client API.</span></span> <span data-ttu-id="32931-266">Otra diferencia es el requisito de coherencia: aunque es conveniente garantizar la coherencia de todas las conexiones de enrutamiento dependiente de datos como protección ante la manipulación del mapa de particiones simultánea, no hay ningún problema con la implementación del esquema inicial en una nueva base de datos que aún no se haya registrado en el mapa de particiones y no se haya asignado para que contenga shardlets.</span><span class="sxs-lookup"><span data-stu-id="32931-266">Another difference is the consistency requirement: While desirable to ensure consistency for all data-dependent routing connections to protect against concurrent shard map manipulation, it is not a concern with initial schema deployment to a new database that has not yet been registered in the shard map, and not yet been allocated to hold shardlets.</span></span> <span data-ttu-id="32931-267">Por lo tanto, podemos confiar en las conexiones de base de datos normales para estos escenarios, en lugar de enrutamiento dependiente de datos.</span><span class="sxs-lookup"><span data-stu-id="32931-267">We can therefore rely on regular database connections for this scenarios, as opposed to data-dependent routing.</span></span>  

<span data-ttu-id="32931-268">Esto conduce a un método en el que la implementación de esquemas mediante migraciones de EF está estrechamente vinculado al registro de la nueva base de datos como partición del mapa de particiones de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="32931-268">This leads to an approach where schema deployment through EF migrations is tightly coupled with the registration of the new database as a shard in the application’s shard map.</span></span> <span data-ttu-id="32931-269">Se basa en los requisitos previos siguientes:</span><span class="sxs-lookup"><span data-stu-id="32931-269">This relies on the following prerequisites:</span></span> 

* <span data-ttu-id="32931-270">Ya se ha creado la base de datos.</span><span class="sxs-lookup"><span data-stu-id="32931-270">The database has already been created.</span></span> 
* <span data-ttu-id="32931-271">La base de datos está vacía, no contiene ningún esquema de usuario ni hay datos de usuario.</span><span class="sxs-lookup"><span data-stu-id="32931-271">The database is empty - it holds no user schema and no user data.</span></span>
* <span data-ttu-id="32931-272">Aún no se puede tener acceso a la base de datos mediante las API de cliente de bases de datos elásticas para enrutamiento dependiente de datos.</span><span class="sxs-lookup"><span data-stu-id="32931-272">The database cannot yet be accessed through the elastic database client APIs for data-dependent routing.</span></span> 

<span data-ttu-id="32931-273">Una vez satisfechos estos requisitos previos, podemos crear una **SqlConnection** normal sin abrir para iniciar migraciones de EF para la implementación del esquema.</span><span class="sxs-lookup"><span data-stu-id="32931-273">With these prerequisites in place, we can create a regular un-opened **SqlConnection** to kick off EF migrations for schema deployment.</span></span> <span data-ttu-id="32931-274">En el ejemplo de código siguiente se muestra este método.</span><span class="sxs-lookup"><span data-stu-id="32931-274">The following code sample illustrates this approach.</span></span> 

        // Enter a new shard - i.e. an empty database - to the shard map, allocate a first tenant to it  
        // and kick off EF intialization of the database to deploy schema 

        public void RegisterNewShard(string server, string database, string connStr, int key) 
        { 

            Shard shard = this.ShardMap.CreateShard(new ShardLocation(server, database)); 

            SqlConnectionStringBuilder connStrBldr = new SqlConnectionStringBuilder(connStr); 
            connStrBldr.DataSource = server; 
            connStrBldr.InitialCatalog = database; 

            // Go into a DbContext to trigger migrations and schema deployment for the new shard. 
            // This requires an un-opened connection. 
            using (var db = new ElasticScaleContext<int>(connStrBldr.ConnectionString)) 
            { 
                // Run a query to engage EF migrations 
                (from b in db.Blogs 
                    select b).Count(); 
            } 

            // Register the mapping of the tenant to the shard in the shard map. 
            // After this step, data-dependent routing on the shard map can be used 

            this.ShardMap.CreatePointMapping(key, shard); 
        } 


<span data-ttu-id="32931-275">Este ejemplo muestra el método **RegisterNewShard** que registra la partición en el mapa de particiones, implementa el esquema mediante migraciones de EF y almacena la asignación de una clave de particionamiento en la partición.</span><span class="sxs-lookup"><span data-stu-id="32931-275">This sample shows the method **RegisterNewShard** that registers the shard in the shard map, deploys the schema through EF migrations, and stores a mapping of a sharding key to the shard.</span></span> <span data-ttu-id="32931-276">Se basa en un constructor de la subclase **DbContext** (**ElasticScaleContext** en el ejemplo) que toma una cadena de conexión SQL como entrada.</span><span class="sxs-lookup"><span data-stu-id="32931-276">It relies on a constructor of the **DbContext** subclass (**ElasticScaleContext** in the sample) that takes a SQL connection string as input.</span></span> <span data-ttu-id="32931-277">El código de este constructor es sencillo, como se muestra en el ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="32931-277">The code of this constructor is straight-forward, as the following example shows:</span></span> 

        // C'tor to deploy schema and migrations to a new shard 
        protected internal ElasticScaleContext(string connectionString) 
            : base(SetInitializerForConnection(connectionString)) 
        { 
        } 

        // Only static methods are allowed in calls into base class c'tors 
        private static string SetInitializerForConnection(string connnectionString) 
        { 
            // We want existence checks so that the schema can get deployed 
            Database.SetInitializer<ElasticScaleContext<T>>( 
        new CreateDatabaseIfNotExists<ElasticScaleContext<T>>()); 

            return connnectionString; 
        } 

<span data-ttu-id="32931-278">Se podría haber usado la versión del constructor heredado de la clase base.</span><span class="sxs-lookup"><span data-stu-id="32931-278">One might have used the version of the constructor inherited from the base class.</span></span> <span data-ttu-id="32931-279">Pero el código debe garantizar que el inicializador predeterminado para EF se usa al conectarse.</span><span class="sxs-lookup"><span data-stu-id="32931-279">But the code needs to ensure that the default initializer for EF is used when connecting.</span></span> <span data-ttu-id="32931-280">De ahí el breve desvío del método estático antes de llamar al constructor de clase base con la cadena de conexión.</span><span class="sxs-lookup"><span data-stu-id="32931-280">Hence the short detour into the static method before calling into the base class constructor with the connection string.</span></span> <span data-ttu-id="32931-281">Tenga en cuenta que el registro de particiones debe ejecutarse en un dominio de aplicación diferente o procesarse para garantizar que los valores de configuración del inicializador para EF no entren en conflicto.</span><span class="sxs-lookup"><span data-stu-id="32931-281">Note that the registration of shards should run in a different app domain or process to ensure that the initializer settings for EF do not conflict.</span></span> 

## <a name="limitations"></a><span data-ttu-id="32931-282">Limitaciones</span><span class="sxs-lookup"><span data-stu-id="32931-282">Limitations</span></span>
<span data-ttu-id="32931-283">Los métodos descritos en este documento implican un par de limitaciones:</span><span class="sxs-lookup"><span data-stu-id="32931-283">The approaches outlined in this document entail a couple of limitations:</span></span> 

* <span data-ttu-id="32931-284">Las aplicaciones de EF que usen **LocalDb** deben migrar en primer lugar a una base de datos de SQL Server normal antes de usar la biblioteca de cliente de Base de datos elástica.</span><span class="sxs-lookup"><span data-stu-id="32931-284">EF applications that use **LocalDb** first need to migrate to a regular SQL Server database before using elastic database client library.</span></span> <span data-ttu-id="32931-285">El escalado horizontal de una aplicación mediante particionamiento con Escalado elástico no es posible con **LocalDb**.</span><span class="sxs-lookup"><span data-stu-id="32931-285">Scaling out an application through sharding with Elastic Scale is not possible with **LocalDb**.</span></span> <span data-ttu-id="32931-286">Tenga en cuenta que los desarrolladores pueden seguir usando **LocalDb**.</span><span class="sxs-lookup"><span data-stu-id="32931-286">Note that development can still use **LocalDb**.</span></span> 
* <span data-ttu-id="32931-287">Los cambios efectuados en la aplicación que implican cambios en el esquema de base de datos deben pasar por migraciones de EF en todas las particiones.</span><span class="sxs-lookup"><span data-stu-id="32931-287">Any changes to the application that imply database schema changes need to go through EF migrations on all shards.</span></span> <span data-ttu-id="32931-288">El código de ejemplo de este documento no muestra cómo hacerlo.</span><span class="sxs-lookup"><span data-stu-id="32931-288">The sample code for this document does not demonstrate how to do this.</span></span> <span data-ttu-id="32931-289">Considere el uso de Update-Database con un parámetro ConnectionString para iterar en todas las particiones; o extraiga el script T-SQL para la migración pendiente usando Update-Database con la opción –Script y aplique el script T-SQL en sus particiones.</span><span class="sxs-lookup"><span data-stu-id="32931-289">Consider using Update-Database with a ConnectionString parameter to iterate over all shards; or extract the T-SQL script for the pending migration using Update-Database with the -Script option and apply the T-SQL script to your shards.</span></span>  
* <span data-ttu-id="32931-290">Dada una solicitud, se supone que todo el procesamiento de la base de datos está contenido en una sola partición que se identifica con la clave de particionamiento especificada por la solicitud.</span><span class="sxs-lookup"><span data-stu-id="32931-290">Given a request, it is assumed that all of its database processing is contained within a single shard as identified by the sharding key provided by the request.</span></span> <span data-ttu-id="32931-291">Sin embargo, esta suposición no siempre es cierta.</span><span class="sxs-lookup"><span data-stu-id="32931-291">However, this assumption does not always hold true.</span></span> <span data-ttu-id="32931-292">Por ejemplo, cuando no se puede disponer de una clave de particionamiento.</span><span class="sxs-lookup"><span data-stu-id="32931-292">For example, when it is not possible to make a sharding key available.</span></span> <span data-ttu-id="32931-293">Para solucionar este problema, la biblioteca cliente proporciona la clase **MultiShardQuery** que implementa una abstracción de conexión para realizar consultas en varias particiones.</span><span class="sxs-lookup"><span data-stu-id="32931-293">To address this, the client library provides the **MultiShardQuery** class that implements a connection abstraction for querying over several shards.</span></span> <span data-ttu-id="32931-294">No es el objetivo de este documento tratar sobre el uso de **MultiShardQuery** junto con EF.</span><span class="sxs-lookup"><span data-stu-id="32931-294">Learning to use the **MultiShardQuery** in combination with EF is beyond the scope of this document</span></span>

## <a name="conclusion"></a><span data-ttu-id="32931-295">Conclusión</span><span class="sxs-lookup"><span data-stu-id="32931-295">Conclusion</span></span>
<span data-ttu-id="32931-296">Con los pasos descritos en este documento, las aplicaciones de EF pueden utilizar la funcionalidad de enrutamiento dependiente de datos de la biblioteca cliente de bases de datos elásticas mediante la refactorización de constructores de las subclases **DbContext** que se usan en la aplicación de EF.</span><span class="sxs-lookup"><span data-stu-id="32931-296">Through the steps outlined in this document, EF applications can use the elastic database client library's capability for data dependent routing by refactoring constructors of the **DbContext** subclasses used in the EF application.</span></span> <span data-ttu-id="32931-297">Esto limita los cambios necesarios en los lugares donde ya existen clases **DbContext** .</span><span class="sxs-lookup"><span data-stu-id="32931-297">This limits the  changes required to those places where **DbContext** classes already exist.</span></span> <span data-ttu-id="32931-298">Además, las aplicaciones de EF pueden seguir aprovechando la implementación automática de esquemas mediante la combinación de los pasos que invocan las migraciones de EF necesarias con el registro de nuevas particiones y asignaciones en el mapa de particiones.</span><span class="sxs-lookup"><span data-stu-id="32931-298">In addition, EF applications can continue to benefit from automatic schema deployment by combining the steps that invoke the necessary EF migrations with the registration of new shards and mappings in the shard map.</span></span> 

[!INCLUDE [elastic-scale-include](../../includes/elastic-scale-include.md)]

<!--Image references-->
[1]: ./media/sql-database-elastic-scale-use-entity-framework-applications-visual-studio/sample.png
