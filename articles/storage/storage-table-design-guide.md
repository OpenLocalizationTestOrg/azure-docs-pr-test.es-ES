---
title: "Guía de diseño de tablas de Azure Storage | Microsoft Docs"
description: "Diseño de tablas escalables y eficientes en Azure Table Storage"
services: storage
documentationcenter: na
author: jasonnewyork
manager: tadb
editor: tysonn
ms.assetid: 8e228b0c-2998-4462-8101-9f16517393ca
ms.service: storage
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: storage
ms.date: 02/28/2017
ms.author: jahogg
ms.openlocfilehash: 5ddb234cc97b3113ec865f97195c871b9f2f40d3
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 07/11/2017
---
# <a name="azure-storage-table-design-guide-designing-scalable-and-performant-tables"></a><span data-ttu-id="1425b-103">Guía de diseño de tablas de Azure Storage: diseño de tablas escalables y eficientes</span><span class="sxs-lookup"><span data-stu-id="1425b-103">Azure Storage Table Design Guide: Designing Scalable and Performant Tables</span></span>
[!INCLUDE [storage-table-cosmos-db-tip-include](../../includes/storage-table-cosmos-db-tip-include.md)]

<span data-ttu-id="1425b-104">Para diseñar tablas escalables y de rendimiento debe tener en cuenta una serie de factores, como el rendimiento, la escalabilidad y el coste.</span><span class="sxs-lookup"><span data-stu-id="1425b-104">To design scalable and performant tables you must consider a number of factors such as performance, scalability, and cost.</span></span> <span data-ttu-id="1425b-105">Si anteriormente ha diseñado esquemas de bases de datos relacionales, estas consideraciones le serán familiares, pero aunque hay algunas similitudes entre los modelos relacionales y el modelo de almacenamiento de Azure Table service, también existen muchas diferencias importantes.</span><span class="sxs-lookup"><span data-stu-id="1425b-105">If you have previously designed schemas for relational databases, these considerations will be familiar to you, but while there are some similarities between the Azure Table service storage model and relational models, there are also many important differences.</span></span> <span data-ttu-id="1425b-106">Normalmente, estas diferencias provocan diseños muy diferentes que pueden parecer no intuitivos o incorrectos a alguien que esté familiarizado con las bases de datos relacionales, pero que sí tienen sentido si va a diseñar un almacén de claves/valores de NoSQL como Azure Table service.</span><span class="sxs-lookup"><span data-stu-id="1425b-106">These differences typically lead to very different designs that may look counter-intuitive or wrong to someone familiar with relational databases, but which do make good sense if you are designing for a NoSQL key/value store such as the Azure Table service.</span></span> <span data-ttu-id="1425b-107">Muchas de sus diferencias de diseño reflejarán el hecho de que Table service está diseñado para admitir aplicaciones de escala de nube que pueden contener miles de millones de entidades (filas en terminología de base de datos de relación) de datos o de conjuntos de datos que deben ser compatibles con volúmenes de transacciones muy elevadas: por lo tanto, tendrá que pensar cómo almacenar los datos de forma diferente y comprender cómo funciona Table service.</span><span class="sxs-lookup"><span data-stu-id="1425b-107">Many of your design differences will reflect the fact that the Table service is designed to support cloud-scale applications that can contain billions of entities (rows in relational database terminology) of data or for datasets that must support very high transaction volumes: therefore, you need to think differently about how you store your data and understand how the Table service works.</span></span> <span data-ttu-id="1425b-108">Un almacén de datos NoSQL bien diseñado puede permitir a su solución escalar mucho más (y a un costo más bajo) que una solución que utiliza una base de datos relacional.</span><span class="sxs-lookup"><span data-stu-id="1425b-108">A well designed NoSQL data store can enable your solution to scale much further (and at a lower cost) than a solution that uses a relational database.</span></span> <span data-ttu-id="1425b-109">Esta guía le ayuda con estos temas.</span><span class="sxs-lookup"><span data-stu-id="1425b-109">This guide helps you with these topics.</span></span>  

## <a name="about-the-azure-table-service"></a><span data-ttu-id="1425b-110">Acerca de Azure Table service</span><span class="sxs-lookup"><span data-stu-id="1425b-110">About the Azure Table service</span></span>
<span data-ttu-id="1425b-111">En esta sección se resaltan algunas de las características clave de Table service que son especialmente importantes para obtener un diseño que confiera rendimiento y escalabilidad.</span><span class="sxs-lookup"><span data-stu-id="1425b-111">This section highlights some of the key features of the Table service that are especially relevant to designing for performance and scalability.</span></span> <span data-ttu-id="1425b-112">Si no está familiarizado con Azure Storage y Table service, consulte primero [Introducción a Microsoft Azure Storage](storage-introduction.md) e [Introducción a Azure Table Storage mediante .NET](storage-dotnet-how-to-use-tables.md) antes de leer el resto de este artículo.</span><span class="sxs-lookup"><span data-stu-id="1425b-112">If you are new to Azure Storage and the Table service, first read [Introduction to Microsoft Azure Storage](storage-introduction.md) and [Get started with Azure Table Storage using .NET](storage-dotnet-how-to-use-tables.md) before reading the remainder of this article.</span></span> <span data-ttu-id="1425b-113">Aunque esta guía se centra en Table service, incluirá información sobre los servicios Azure Queue y Blob, y cómo usarlos junto con Table service en una solución.</span><span class="sxs-lookup"><span data-stu-id="1425b-113">Although the focus of this guide is on the Table service, it will include some discussion of the Azure Queue and Blob services, and how you might use them along with the Table service in a solution.</span></span>  

<span data-ttu-id="1425b-114">¿Qué es Table service?</span><span class="sxs-lookup"><span data-stu-id="1425b-114">What is the Table service?</span></span> <span data-ttu-id="1425b-115">Como cabría esperar por su nombre, Table service usa un formato tabular para almacenar los datos.</span><span class="sxs-lookup"><span data-stu-id="1425b-115">As you might expect from the name, the Table service uses a tabular format to store data.</span></span> <span data-ttu-id="1425b-116">En la terminología estándar, cada fila de la tabla representa una entidad y las columnas almacenan las distintas propiedades de la entidad.</span><span class="sxs-lookup"><span data-stu-id="1425b-116">In the standard terminology, each row of the table represents an entity, and the columns store the various properties of that entity.</span></span> <span data-ttu-id="1425b-117">Cada entidad tiene un par de claves para identificar de forma exclusiva y una columna de marca de tiempo que Table service utiliza para realizar un seguimiento de cuando la entidad se ha actualizado por última vez (esto ocurre automáticamente y no se puede sobrescribir manualmente la marca de tiempo con un valor arbitrario).</span><span class="sxs-lookup"><span data-stu-id="1425b-117">Every entity has a pair of keys to uniquely identify it, and a timestamp column that the Table service uses to track when the entity was last updated (this happens automatically and you cannot manually overwrite the timestamp with an arbitrary value).</span></span> <span data-ttu-id="1425b-118">Table service usa esta última marca de tiempo modificada (LMT) para administrar la simultaneidad optimista.</span><span class="sxs-lookup"><span data-stu-id="1425b-118">The Table service uses this last-modified timestamp (LMT) to manage optimistic concurrency.</span></span>  

> [!NOTE]
> <span data-ttu-id="1425b-119">Las operaciones de API de REST de Table service también devuelven un valor **ETag** que se deriva del LMT.</span><span class="sxs-lookup"><span data-stu-id="1425b-119">The Table service REST API operations also return an **ETag** value that it derives from the last-modified timestamp (LMT).</span></span> <span data-ttu-id="1425b-120">En este documento se utilizarán los términos ETag y LMT indistintamente porque hacen referencia a los mismos datos subyacentes.</span><span class="sxs-lookup"><span data-stu-id="1425b-120">In this document we will use the terms ETag and LMT interchangeably because they refer to the same underlying data.</span></span>  
> 
> 

<span data-ttu-id="1425b-121">En el ejemplo siguiente se muestra el diseño de una tabla sencilla para almacenar las entidades employee y department.</span><span class="sxs-lookup"><span data-stu-id="1425b-121">The following example shows a simple table design to store employee and department entities.</span></span> <span data-ttu-id="1425b-122">Muchos de los ejemplos que se muestran más adelante en esta guía se basan en este diseño simple.</span><span class="sxs-lookup"><span data-stu-id="1425b-122">Many of the examples shown later in this guide are based on this simple design.</span></span>  

<table>
<tr>
<th><span data-ttu-id="1425b-123">PartitionKey</span><span class="sxs-lookup"><span data-stu-id="1425b-123">PartitionKey</span></span></th>
<th><span data-ttu-id="1425b-124">RowKey</span><span class="sxs-lookup"><span data-stu-id="1425b-124">RowKey</span></span></th>
<th><span data-ttu-id="1425b-125">Timestamp</span><span class="sxs-lookup"><span data-stu-id="1425b-125">Timestamp</span></span></th>
<th></th>
</tr>
<tr>
<td><span data-ttu-id="1425b-126">Marketing</span><span class="sxs-lookup"><span data-stu-id="1425b-126">Marketing</span></span></td>
<td><span data-ttu-id="1425b-127">00001</span><span class="sxs-lookup"><span data-stu-id="1425b-127">00001</span></span></td>
<td><span data-ttu-id="1425b-128">2014-08-22T00:50:32Z</span><span class="sxs-lookup"><span data-stu-id="1425b-128">2014-08-22T00:50:32Z</span></span></td>
<td>
<table>
<tr>
<th><span data-ttu-id="1425b-129">Nombre</span><span class="sxs-lookup"><span data-stu-id="1425b-129">FirstName</span></span></th>
<th><span data-ttu-id="1425b-130">Apellidos</span><span class="sxs-lookup"><span data-stu-id="1425b-130">LastName</span></span></th>
<th><span data-ttu-id="1425b-131">Edad</span><span class="sxs-lookup"><span data-stu-id="1425b-131">Age</span></span></th>
<th><span data-ttu-id="1425b-132">Email</span><span class="sxs-lookup"><span data-stu-id="1425b-132">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="1425b-133">Don</span><span class="sxs-lookup"><span data-stu-id="1425b-133">Don</span></span></td>
<td><span data-ttu-id="1425b-134">Hall</span><span class="sxs-lookup"><span data-stu-id="1425b-134">Hall</span></span></td>
<td><span data-ttu-id="1425b-135">34</span><span class="sxs-lookup"><span data-stu-id="1425b-135">34</span></span></td>
<td>donh@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td><span data-ttu-id="1425b-136">Marketing</span><span class="sxs-lookup"><span data-stu-id="1425b-136">Marketing</span></span></td>
<td><span data-ttu-id="1425b-137">00002</span><span class="sxs-lookup"><span data-stu-id="1425b-137">00002</span></span></td>
<td><span data-ttu-id="1425b-138">2014-08-22T00:50:34Z</span><span class="sxs-lookup"><span data-stu-id="1425b-138">2014-08-22T00:50:34Z</span></span></td>
<td>
<table>
<tr>
<th><span data-ttu-id="1425b-139">Nombre</span><span class="sxs-lookup"><span data-stu-id="1425b-139">FirstName</span></span></th>
<th><span data-ttu-id="1425b-140">Apellidos</span><span class="sxs-lookup"><span data-stu-id="1425b-140">LastName</span></span></th>
<th><span data-ttu-id="1425b-141">Edad</span><span class="sxs-lookup"><span data-stu-id="1425b-141">Age</span></span></th>
<th><span data-ttu-id="1425b-142">Email</span><span class="sxs-lookup"><span data-stu-id="1425b-142">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="1425b-143">Jun</span><span class="sxs-lookup"><span data-stu-id="1425b-143">Jun</span></span></td>
<td><span data-ttu-id="1425b-144">Cao</span><span class="sxs-lookup"><span data-stu-id="1425b-144">Cao</span></span></td>
<td><span data-ttu-id="1425b-145">47</span><span class="sxs-lookup"><span data-stu-id="1425b-145">47</span></span></td>
<td>junc@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td><span data-ttu-id="1425b-146">Marketing</span><span class="sxs-lookup"><span data-stu-id="1425b-146">Marketing</span></span></td>
<td><span data-ttu-id="1425b-147">Departamento</span><span class="sxs-lookup"><span data-stu-id="1425b-147">Department</span></span></td>
<td><span data-ttu-id="1425b-148">2014-08-22T00:50:30Z</span><span class="sxs-lookup"><span data-stu-id="1425b-148">2014-08-22T00:50:30Z</span></span></td>
<td>
<table>
<tr>
<th><span data-ttu-id="1425b-149">DepartmentName</span><span class="sxs-lookup"><span data-stu-id="1425b-149">DepartmentName</span></span></th>
<th><span data-ttu-id="1425b-150">EmployeeCount</span><span class="sxs-lookup"><span data-stu-id="1425b-150">EmployeeCount</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="1425b-151">Marketing</span><span class="sxs-lookup"><span data-stu-id="1425b-151">Marketing</span></span></td>
<td><span data-ttu-id="1425b-152">153</span><span class="sxs-lookup"><span data-stu-id="1425b-152">153</span></span></td>
</tr>
</table>
</td>
</tr>
<tr>
<td><span data-ttu-id="1425b-153">Ventas</span><span class="sxs-lookup"><span data-stu-id="1425b-153">Sales</span></span></td>
<td><span data-ttu-id="1425b-154">00010</span><span class="sxs-lookup"><span data-stu-id="1425b-154">00010</span></span></td>
<td><span data-ttu-id="1425b-155">2014-08-22T00:50:44Z</span><span class="sxs-lookup"><span data-stu-id="1425b-155">2014-08-22T00:50:44Z</span></span></td>
<td>
<table>
<tr>
<th><span data-ttu-id="1425b-156">Nombre</span><span class="sxs-lookup"><span data-stu-id="1425b-156">FirstName</span></span></th>
<th><span data-ttu-id="1425b-157">Apellidos</span><span class="sxs-lookup"><span data-stu-id="1425b-157">LastName</span></span></th>
<th><span data-ttu-id="1425b-158">Edad</span><span class="sxs-lookup"><span data-stu-id="1425b-158">Age</span></span></th>
<th><span data-ttu-id="1425b-159">Email</span><span class="sxs-lookup"><span data-stu-id="1425b-159">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="1425b-160">Ken</span><span class="sxs-lookup"><span data-stu-id="1425b-160">Ken</span></span></td>
<td><span data-ttu-id="1425b-161">Kwok</span><span class="sxs-lookup"><span data-stu-id="1425b-161">Kwok</span></span></td>
<td><span data-ttu-id="1425b-162">23</span><span class="sxs-lookup"><span data-stu-id="1425b-162">23</span></span></td>
<td>kenk@contoso.com</td>
</tr>
</table>
</td>
</tr>
</table>


<span data-ttu-id="1425b-163">Hasta ahora, parece muy similar a una tabla en una base de datos relacional, con las diferencias clave de las columnas obligatorias y la capacidad de almacenar varios tipos de entidad en la misma tabla.</span><span class="sxs-lookup"><span data-stu-id="1425b-163">So far, this looks very similar to a table in a relational database with the key differences being the mandatory columns, and the ability to store multiple entity types in the same table.</span></span> <span data-ttu-id="1425b-164">Además, cada una de las propiedades definidas por el usuario como **FirstName** o **Age** tienen un tipo de datos, como un número entero o una cadena, como una columna en una base de datos relacional.</span><span class="sxs-lookup"><span data-stu-id="1425b-164">In addition, each of the user-defined properties such as **FirstName** or **Age** has a data type, such as integer or string, just like a column in a relational database.</span></span> <span data-ttu-id="1425b-165">Aunque a diferencia de una base de datos relacional, la naturaleza sin esquema de Table service significa que una propiedad no necesita tener los mismos tipos de datos en cada entidad.</span><span class="sxs-lookup"><span data-stu-id="1425b-165">Although unlike in a relational database, the schema-less nature of the Table service means that a property need not have the same data type on each entity.</span></span> <span data-ttu-id="1425b-166">Para almacenar tipos de datos complejos en una sola propiedad, debe utilizar un formato serializado como JSON o XML.</span><span class="sxs-lookup"><span data-stu-id="1425b-166">To store complex data types in a single property, you must use a serialized format such as JSON or XML.</span></span> <span data-ttu-id="1425b-167">Para obtener más información sobre Table service, como los tipos de datos admitidos, los intervalos de fechas admitidos, las reglas de nomenclatura y las restricciones de tamaño, consulte [Introducción al modelo de datos de Table service](http://msdn.microsoft.com/library/azure/dd179338.aspx).</span><span class="sxs-lookup"><span data-stu-id="1425b-167">For more information about the table service such as supported data types, supported date ranges, naming rules, and size constraints, see [Understanding the Table Service Data Model](http://msdn.microsoft.com/library/azure/dd179338.aspx).</span></span>

<span data-ttu-id="1425b-168">Como puede ver, la elección del **PartitionKey** y **RowKey** es fundamental para el diseño de tabla válida.</span><span class="sxs-lookup"><span data-stu-id="1425b-168">As you will see, your choice of **PartitionKey** and **RowKey** is fundamental to good table design.</span></span> <span data-ttu-id="1425b-169">Todas las entidades almacenadas en una tabla deben tener una combinación única de **PartitionKey** y **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="1425b-169">Every entity stored in a table must have a unique combination of **PartitionKey** and **RowKey**.</span></span> <span data-ttu-id="1425b-170">Al igual que con las claves en una tabla de base de datos relacional, los valores **PartitionKey** y **RowKey** están indexados para crear un índice agrupado que permite búsquedas rápidas; sin embargo, Table Service no crea índices secundarios, por lo que estas son las dos únicas propiedades indexadas (algunos de los patrones descritos más adelante muestran cómo evitar esta limitación aparente).</span><span class="sxs-lookup"><span data-stu-id="1425b-170">As with keys in a relational database table, the **PartitionKey** and **RowKey** values are indexed to create a clustered index that enables fast look-ups; however, the Table service does not create any secondary indexes so these are the only two indexed properties (some of the patterns described later show how you can work around this apparent limitation).</span></span>  

<span data-ttu-id="1425b-171">Una tabla está formada por una o varias particiones y, como podrá ver, muchas de las decisiones de diseño que tome estarán relacionadas con la elección de un **PartitionKey** y **RowKey** adecuado para optimizar la solución.</span><span class="sxs-lookup"><span data-stu-id="1425b-171">A table is made up of one or more partitions, and as you will see, many of the design decisions you make will be around choosing a suitable **PartitionKey** and **RowKey** to optimize your solution.</span></span> <span data-ttu-id="1425b-172">Una solución puede constar de solo una única tabla que contenga todas las entidades que se organizan en particiones, pero normalmente las soluciones tendrán varias tablas.</span><span class="sxs-lookup"><span data-stu-id="1425b-172">A solution could consist of just a single table that contains all your entities organized into partitions, but typically a solution will have multiple tables.</span></span> <span data-ttu-id="1425b-173">Tablas le ayuda a organizar las entidades de manera lógica, le ayudará a administrar el acceso a los datos mediante listas de control de acceso y puede quitar una tabla completa mediante una sola operación de almacenamiento.</span><span class="sxs-lookup"><span data-stu-id="1425b-173">Tables help you to logically organize your entities, help you manage access to the data using access control lists, and you can drop an entire table using a single storage operation.</span></span>  

### <a name="table-partitions"></a><span data-ttu-id="1425b-174">Particiones de tabla</span><span class="sxs-lookup"><span data-stu-id="1425b-174">Table partitions</span></span>
<span data-ttu-id="1425b-175">El nombre de la cuenta, el nombre de la tabla y **PartitionKey** juntos identifican la partición dentro del servicio de almacenamiento donde Table service almacena la entidad.</span><span class="sxs-lookup"><span data-stu-id="1425b-175">The account name, table name and **PartitionKey** together identify the partition within the storage service where the table service stores the entity.</span></span> <span data-ttu-id="1425b-176">Además de ser parte del esquema de direccionamiento de las entidades, las particiones definen un ámbito para las transacciones (vea [Transacciones de grupo de entidad](#entity-group-transactions) a continuación) y forman la base de cómo escala Table service.</span><span class="sxs-lookup"><span data-stu-id="1425b-176">As well as being part of the addressing scheme for entities, partitions define a scope for transactions (see [Entity Group Transactions](#entity-group-transactions) below), and form the basis of how the table service scales.</span></span> <span data-ttu-id="1425b-177">Para obtener más información sobre las particiones, vea [Objetivos de rendimiento y escalabilidad de Azure Storage](storage-scalability-targets.md).</span><span class="sxs-lookup"><span data-stu-id="1425b-177">For more information on partitions see [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span>  

<span data-ttu-id="1425b-178">En Table service, un nodo individual da servicio a una o más particiones completas y el servicio se escala equilibrando dinámicamente la carga de las particiones entre nodos.</span><span class="sxs-lookup"><span data-stu-id="1425b-178">In the Table service, an individual node services one or more complete partitions and the service scales by dynamically load-balancing partitions across nodes.</span></span> <span data-ttu-id="1425b-179">Si un nodo está bajo carga, Table Service puede *dividir* el intervalo de particiones atendidas por ese nodo en nodos diferentes; cuando el tráfico disminuye, el servicio puede *combinar* los intervalos de la partición de nodos silenciosos a un único nodo.</span><span class="sxs-lookup"><span data-stu-id="1425b-179">If a node is under load, the table service can *split* the range of partitions serviced by that node onto different nodes; when traffic subsides, the service can *merge* the partition ranges from quiet nodes back onto a single node.</span></span>  

<span data-ttu-id="1425b-180">Para obtener más información acerca de los detalles internos de Table service y saber en particular cómo administra las particiones, consulte el artículo [Microsoft Azure Storage: Un servicio de almacenamiento en la nube altamente disponible con gran coherencia](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx).</span><span class="sxs-lookup"><span data-stu-id="1425b-180">For more information about the internal details of the Table service, and in particular how the service manages partitions, see the paper [Microsoft Azure Storage: A Highly Available Cloud Storage Service with Strong Consistency](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx).</span></span>  

### <a name="entity-group-transactions"></a><span data-ttu-id="1425b-181">Transacciones de grupo de entidad</span><span class="sxs-lookup"><span data-stu-id="1425b-181">Entity Group Transactions</span></span>
<span data-ttu-id="1425b-182">En Table service, las transacciones de grupo de entidad (EGT) son el único mecanismo integrado para realizar actualizaciones atómicas en varias entidades.</span><span class="sxs-lookup"><span data-stu-id="1425b-182">In the Table service, Entity Group Transactions (EGTs) are the only built-in mechanism for performing atomic updates across multiple entities.</span></span> <span data-ttu-id="1425b-183">Las EGT también se conocen como *transacciones por lotes* en algunos documentos.</span><span class="sxs-lookup"><span data-stu-id="1425b-183">EGTs are also referred to as *batch transactions* in some documentation.</span></span> <span data-ttu-id="1425b-184">Las EGT funcionan únicamente en entidades almacenadas en la misma partición (comparten la misma clave de partición en una tabla determinada), por lo que siempre que necesite un comportamiento transaccional atómico a través de varias entidades, debe asegurarse de que las entidades se encuentren en la misma partición.</span><span class="sxs-lookup"><span data-stu-id="1425b-184">EGTs can only operate on entities stored in the same partition (share the same partition key in a given table), so anytime you need atomic transactional behavior across multiple entities you need to ensure that those entities are in the same partition.</span></span> <span data-ttu-id="1425b-185">Este suele ser un motivo para mantener varios tipos de entidad en la misma tabla (y partición) y no utilizar varias tablas para diferentes tipos de entidad.</span><span class="sxs-lookup"><span data-stu-id="1425b-185">This is often a reason for keeping multiple entity types in the same table (and partition) and not using multiple tables for different entity types.</span></span> <span data-ttu-id="1425b-186">Una sola EGT puede operar en 100 entidades como máximo.</span><span class="sxs-lookup"><span data-stu-id="1425b-186">A single EGT can operate on at most 100 entities.</span></span>  <span data-ttu-id="1425b-187">Si envía varias EGT simultáneas para procesamiento, es importante asegurarse de que esas EGT no funcionan en las entidades que son comunes en EGT, ya que de lo contrario se puede retrasar el procesamiento.</span><span class="sxs-lookup"><span data-stu-id="1425b-187">If you submit multiple concurrent EGTs for processing it is important to ensure  those EGTs do not operate on entities that are common across EGTs as otherwise processing can be delayed.</span></span>

<span data-ttu-id="1425b-188">Las EGT también presentan una desventaja potencial que debe evaluar en su diseño: el uso de más particiones aumentará la escalabilidad de la aplicación porque Azure tiene más oportunidades para equilibrar la carga de solicitudes entre nodos, pero esto podría limitar la capacidad de la aplicación de realizar transacciones atómicas y mantener la coherencia segura para sus datos.</span><span class="sxs-lookup"><span data-stu-id="1425b-188">EGTs also introduce a potential trade-off for you to evaluate in your design: using more partitions will increase the scalability of your application because Azure has more opportunities for load balancing requests across nodes, but this might limit the ability of your application to perform atomic transactions and maintain strong consistency for your data.</span></span> <span data-ttu-id="1425b-189">Además, existen destinos de escalabilidad específicos en el nivel de una partición que puede limitar el rendimiento de las transacciones que se pueden esperar de un solo nodo. Para más información sobre los objetivos de escalabilidad para las cuentas de Azure Storage y Table Service, consulte [Objetivos de rendimiento y escalabilidad de Azure Storage](storage-scalability-targets.md).</span><span class="sxs-lookup"><span data-stu-id="1425b-189">Furthermore, there are specific scalability targets at the level of a partition that might limit the throughput of transactions you can expect for a single node: for more information about the scalability targets for Azure storage accounts and the table service, see [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span> <span data-ttu-id="1425b-190">En secciones posteriores de esta guía se trata sobre diversas estrategias de diseño que le ayudarán a administrar los inconvenientes de este, y se explica cómo elegir mejor su clave de partición según los requisitos específicos de su aplicación cliente.</span><span class="sxs-lookup"><span data-stu-id="1425b-190">Later sections of this guide discuss various design strategies that help you manage trade-offs such as this one, and discuss how best to choose your partition key based on the specific requirements of your client application.</span></span>  

### <a name="capacity-considerations"></a><span data-ttu-id="1425b-191">Consideraciones de capacidad</span><span class="sxs-lookup"><span data-stu-id="1425b-191">Capacity considerations</span></span>
<span data-ttu-id="1425b-192">En la tabla siguiente se incluyen algunos de los valores de clave a tener en cuenta al diseñar una solución de Table service:</span><span class="sxs-lookup"><span data-stu-id="1425b-192">The following table includes some of the key values to be aware of when you are designing a Table service solution:</span></span>  

| <span data-ttu-id="1425b-193">Capacidad total de una cuenta de Azure Storage</span><span class="sxs-lookup"><span data-stu-id="1425b-193">Total capacity of an Azure storage account</span></span> | <span data-ttu-id="1425b-194">500 TB</span><span class="sxs-lookup"><span data-stu-id="1425b-194">500 TB</span></span> |
| --- | --- |
| <span data-ttu-id="1425b-195">Número de tablas en una cuenta de Azure Storage</span><span class="sxs-lookup"><span data-stu-id="1425b-195">Number of tables in an Azure storage account</span></span> |<span data-ttu-id="1425b-196">Solo limitadas por la capacidad de la cuenta de almacenamiento</span><span class="sxs-lookup"><span data-stu-id="1425b-196">Limited only by the capacity of the storage account</span></span> |
| <span data-ttu-id="1425b-197">Número de particiones en una tabla</span><span class="sxs-lookup"><span data-stu-id="1425b-197">Number of partitions in a table</span></span> |<span data-ttu-id="1425b-198">Solo limitadas por la capacidad de la cuenta de almacenamiento</span><span class="sxs-lookup"><span data-stu-id="1425b-198">Limited only by the capacity of the storage account</span></span> |
| <span data-ttu-id="1425b-199">Número de entidades de una partición</span><span class="sxs-lookup"><span data-stu-id="1425b-199">Number of entities in a partition</span></span> |<span data-ttu-id="1425b-200">Solo limitadas por la capacidad de la cuenta de almacenamiento</span><span class="sxs-lookup"><span data-stu-id="1425b-200">Limited only by the capacity of the storage account</span></span> |
| <span data-ttu-id="1425b-201">Tamaño de una entidad individual</span><span class="sxs-lookup"><span data-stu-id="1425b-201">Size of an individual entity</span></span> |<span data-ttu-id="1425b-202">Hasta 1 MB con un máximo de 255 propiedades (incluyendo **PartitionKey**, **RowKey** y **Timestamp**)</span><span class="sxs-lookup"><span data-stu-id="1425b-202">Up to 1 MB with a maximum of 255 properties (including the **PartitionKey**, **RowKey**, and **Timestamp**)</span></span> |
| <span data-ttu-id="1425b-203">Tamaño de la **PartitionKey**</span><span class="sxs-lookup"><span data-stu-id="1425b-203">Size of the **PartitionKey**</span></span> |<span data-ttu-id="1425b-204">Una cadena de hasta 1 KB</span><span class="sxs-lookup"><span data-stu-id="1425b-204">A string up to 1 KB in size</span></span> |
| <span data-ttu-id="1425b-205">Tamaño de la **RowKey**</span><span class="sxs-lookup"><span data-stu-id="1425b-205">Size of the **RowKey**</span></span> |<span data-ttu-id="1425b-206">Una cadena de hasta 1 KB</span><span class="sxs-lookup"><span data-stu-id="1425b-206">A string up to 1 KB in size</span></span> |
| <span data-ttu-id="1425b-207">Tamaño de una transacción de un grupo de entidades</span><span class="sxs-lookup"><span data-stu-id="1425b-207">Size of an Entity Group Transaction</span></span> |<span data-ttu-id="1425b-208">Una transacción puede incluir como máximo 100 entidades y la carga debe ser inferior a 4 MB.</span><span class="sxs-lookup"><span data-stu-id="1425b-208">A transaction can include at most 100 entities and the payload must be less than 4 MB in size.</span></span> <span data-ttu-id="1425b-209">Un EGT solo puede actualizar una entidad una vez.</span><span class="sxs-lookup"><span data-stu-id="1425b-209">An EGT can only update an entity once.</span></span> |

<span data-ttu-id="1425b-210">Para más información, consulte [Descripción del modelo de datos de Table service](http://msdn.microsoft.com/library/azure/dd179338.aspx).</span><span class="sxs-lookup"><span data-stu-id="1425b-210">For more information, see [Understanding the Table Service Data Model](http://msdn.microsoft.com/library/azure/dd179338.aspx).</span></span>  

### <a name="cost-considerations"></a><span data-ttu-id="1425b-211">Consideraciones sobre el coste</span><span class="sxs-lookup"><span data-stu-id="1425b-211">Cost considerations</span></span>
<span data-ttu-id="1425b-212">El almacenamiento en tablas es relativamente económico, pero debe incluir las estimaciones de costes para el uso de la capacidad y la cantidad de transacciones como parte de la evaluación de cualquier solución que utilice Table service.</span><span class="sxs-lookup"><span data-stu-id="1425b-212">Table storage is relatively inexpensive, but you should include cost estimates for both capacity usage and the quantity of transactions as part of your evaluation of any solution that uses the Table service.</span></span> <span data-ttu-id="1425b-213">Sin embargo, en muchos escenarios, el almacenamiento de datos duplicados o sin normalizar para mejorar el rendimiento o la escalabilidad de su solución es un enfoque válido que se puede tomar.</span><span class="sxs-lookup"><span data-stu-id="1425b-213">However, in many scenarios storing denormalized or duplicate data in order to improve the performance or scalability of your solution is a valid approach to take.</span></span> <span data-ttu-id="1425b-214">Para obtener más información sobre los precios, consulte [Precios de Azure Storage](https://azure.microsoft.com/pricing/details/storage/).</span><span class="sxs-lookup"><span data-stu-id="1425b-214">For more information about pricing, see [Azure Storage Pricing](https://azure.microsoft.com/pricing/details/storage/).</span></span>  

## <a name="guidelines-for-table-design"></a><span data-ttu-id="1425b-215">Directrices para el diseño de tablas</span><span class="sxs-lookup"><span data-stu-id="1425b-215">Guidelines for table design</span></span>
<span data-ttu-id="1425b-216">En estas listas se resumen algunas de las instrucciones claves que debe tener en cuenta al diseñar las tablas y esta guía abordará todo con más detalle posteriormente.</span><span class="sxs-lookup"><span data-stu-id="1425b-216">These lists summarize some of the key guidelines you should keep in mind when you are designing your tables, and this guide will address them all in more detail later in.</span></span> <span data-ttu-id="1425b-217">Estas instrucciones son muy diferentes de las directrices que seguiría normalmente para el diseño de la base de datos relacional.</span><span class="sxs-lookup"><span data-stu-id="1425b-217">These guidelines are very different from the guidelines you would typically follow for relational database design.</span></span>  

<span data-ttu-id="1425b-218">Diseñe una solución de Table service cuya *lectura* sea eficaz:</span><span class="sxs-lookup"><span data-stu-id="1425b-218">Designing your Table service solution to be *read* efficient:</span></span>

* <span data-ttu-id="1425b-219">***Diseño para realizar consultas en aplicaciones con muchas lecturas.***</span><span class="sxs-lookup"><span data-stu-id="1425b-219">***Design for querying in read-heavy applications.***</span></span> <span data-ttu-id="1425b-220">Al diseñar las tablas, piense en las consultas (especialmente las sensibles a la latencia) que ejecutará antes de pensar cómo actualizará las entidades.</span><span class="sxs-lookup"><span data-stu-id="1425b-220">When you are designing your tables, think about the queries (especially the latency sensitive ones) that you will execute before you think about how you will update your entities.</span></span> <span data-ttu-id="1425b-221">Normalmente esto produce una solución eficiente y de rendimiento.</span><span class="sxs-lookup"><span data-stu-id="1425b-221">This typically results in an efficient and performant solution.</span></span>  
* <span data-ttu-id="1425b-222">***Especificar tanto PartitionKey como RowKey en sus consultas.***</span><span class="sxs-lookup"><span data-stu-id="1425b-222">***Specify both PartitionKey and RowKey in your queries.***</span></span> <span data-ttu-id="1425b-223">*consultas puntuales* como estas son las consultas más eficaces de Table service.</span><span class="sxs-lookup"><span data-stu-id="1425b-223">*Point queries* such as these are the most efficient table service queries.</span></span>  
* <span data-ttu-id="1425b-224">***Tenga en cuenta la posibilidad de almacenar copias duplicadas de las entidades.***</span><span class="sxs-lookup"><span data-stu-id="1425b-224">***Consider storing duplicate copies of entities.***</span></span> <span data-ttu-id="1425b-225">El almacenamiento en tablas es barato por lo que puede almacenar la misma entidad varias veces (con claves diferentes) para permitir que se realicen consultas más eficaces.</span><span class="sxs-lookup"><span data-stu-id="1425b-225">Table storage is cheap so consider storing the same entity multiple times (with different keys) to enable more efficient queries.</span></span>  
* <span data-ttu-id="1425b-226">***Considere la posibilidad de desnormalizar sus datos.***</span><span class="sxs-lookup"><span data-stu-id="1425b-226">***Consider denormalizing your data.***</span></span> <span data-ttu-id="1425b-227">El almacenamiento en tablas es barato, por tanto, piense en desnormalizar sus datos.</span><span class="sxs-lookup"><span data-stu-id="1425b-227">Table storage is cheap so consider denormalizing your data.</span></span> <span data-ttu-id="1425b-228">Por ejemplo, almacene entidades de resumen para que las consultas para datos agregados solo necesiten acceder a una única entidad.</span><span class="sxs-lookup"><span data-stu-id="1425b-228">For example, store summary entities so that queries for aggregate data only need to access a single entity.</span></span>  
* <span data-ttu-id="1425b-229">***Use valores de clave compuestos.***</span><span class="sxs-lookup"><span data-stu-id="1425b-229">***Use compound key values.***</span></span> <span data-ttu-id="1425b-230">Las únicas claves de las que dispone son **PartitionKey** y **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="1425b-230">The only keys you have are **PartitionKey** and **RowKey**.</span></span> <span data-ttu-id="1425b-231">Por ejemplo, s los valores de clave compuestos para habilitar rutas de acceso con clave alternativas a las entidades.</span><span class="sxs-lookup"><span data-stu-id="1425b-231">For example, use compound key values to enable alternate keyed access paths to entities.</span></span>  
* <span data-ttu-id="1425b-232">***Use la proyección de consultas.***</span><span class="sxs-lookup"><span data-stu-id="1425b-232">***Use query projection.***</span></span> <span data-ttu-id="1425b-233">Puede reducir la cantidad de datos que se transfieren a través de la red mediante el uso de consultas que seleccionen solo los campos que necesite.</span><span class="sxs-lookup"><span data-stu-id="1425b-233">You can reduce the amount of data that you transfer over the network by using queries that select just the fields you need.</span></span>  

<span data-ttu-id="1425b-234">Diseñe su solución de Table service cuya *escritura* sea eficaz:</span><span class="sxs-lookup"><span data-stu-id="1425b-234">Designing your Table service solution to be *write* efficient:</span></span>  

* <span data-ttu-id="1425b-235">***No cree particiones activas.***</span><span class="sxs-lookup"><span data-stu-id="1425b-235">***Do not create hot partitions.***</span></span> <span data-ttu-id="1425b-236">Elija claves que le permitan distribuir las solicitudes en varias particiones en cualquier momento.</span><span class="sxs-lookup"><span data-stu-id="1425b-236">Choose keys that enable you to spread your requests across multiple partitions at any point of time.</span></span>  
* <span data-ttu-id="1425b-237">***Evite picos de tráfico.***</span><span class="sxs-lookup"><span data-stu-id="1425b-237">***Avoid spikes in traffic.***</span></span> <span data-ttu-id="1425b-238">Equilibre el tráfico en un período de tiempo razonable y evite picos de tráfico.</span><span class="sxs-lookup"><span data-stu-id="1425b-238">Smooth the traffic over a reasonable period of time and avoid spikes in traffic.</span></span>
* <span data-ttu-id="1425b-239">***No es preciso crear necesariamente una tabla independiente para cada tipo de entidad.***</span><span class="sxs-lookup"><span data-stu-id="1425b-239">***Don't necessarily create a separate table for each type of entity.***</span></span> <span data-ttu-id="1425b-240">Cuando necesite transacciones atómicas en los tipos de entidad, puede almacenar estos distintos tipos de entidad en la misma partición de la misma tabla.</span><span class="sxs-lookup"><span data-stu-id="1425b-240">When you require atomic transactions across entity types, you can store these multiple entity types in the same partition in the same table.</span></span>
* <span data-ttu-id="1425b-241">***Tenga en cuenta el rendimiento máximo que debe alcanzar.***</span><span class="sxs-lookup"><span data-stu-id="1425b-241">***Consider the maximum throughput you must achieve.***</span></span> <span data-ttu-id="1425b-242">Debe tener en cuenta los objetivos de escalabilidad de Table service y asegurarse de que su diseño no los superará.</span><span class="sxs-lookup"><span data-stu-id="1425b-242">You must be aware of the scalability targets for the Table service and ensure that your design will not cause you to exceed them.</span></span>  

<span data-ttu-id="1425b-243">A medida que lea esta guía, verá ejemplos en los que se ponen en práctica todos estos principios.</span><span class="sxs-lookup"><span data-stu-id="1425b-243">As you read this guide, you will see examples that put all of these principles into practice.</span></span>  

## <a name="design-for-querying"></a><span data-ttu-id="1425b-244">Diseño de consulta</span><span class="sxs-lookup"><span data-stu-id="1425b-244">Design for querying</span></span>
<span data-ttu-id="1425b-245">Las soluciones de Table service pueden requerir mucha lectura, escritura o una combinación de ambas.</span><span class="sxs-lookup"><span data-stu-id="1425b-245">Table service solutions may be read intensive, write intensive, or a mix of the two.</span></span> <span data-ttu-id="1425b-246">Esta sección se centra en los aspectos a tener en cuenta al diseñar Table service para admitir operaciones de lectura de forma eficaz.</span><span class="sxs-lookup"><span data-stu-id="1425b-246">This section focuses on the things to bear in mind when you are designing your Table service to support read operations efficiently.</span></span> <span data-ttu-id="1425b-247">Normalmente, un diseño que admite operaciones de lectura eficazmente también es eficaz para las operaciones de escritura.</span><span class="sxs-lookup"><span data-stu-id="1425b-247">Typically, a design that supports read operations efficiently is also efficient for write operations.</span></span> <span data-ttu-id="1425b-248">Sin embargo, hay algunas consideraciones adicionales que hay que tener en cuenta durante el diseño para admitir operaciones de escritura y que se explican en la siguiente sección, [Diseño para la modificación de datos](#design-for-data-modification).</span><span class="sxs-lookup"><span data-stu-id="1425b-248">However, there are additional considerations to bear in mind when designing to support write operations, discussed in the next section, [Design for data modification](#design-for-data-modification).</span></span>

<span data-ttu-id="1425b-249">Un buen punto de partida para diseñar la solución de Table service para que pueda leer los datos de manera eficiente es preguntar "¿Qué consultas necesitará ejecutar mi aplicación para recuperar los datos que necesita de Table service?"</span><span class="sxs-lookup"><span data-stu-id="1425b-249">A good starting point for designing your Table service solution to enable you to read data efficiently is to ask "What queries will my application need to execute to retrieve the data it needs from the Table service?"</span></span>  

> [!NOTE]
> <span data-ttu-id="1425b-250">Con Table service, es importante obtener el diseño correcto por adelantado, ya que resulta difícil y caro cambiarlo posteriormente.</span><span class="sxs-lookup"><span data-stu-id="1425b-250">With the Table service, it's important to get the design correct up front because it's difficult and expensive to change it later.</span></span> <span data-ttu-id="1425b-251">Por ejemplo, en una base de datos relacional a menudo resulta posible resolver problemas de rendimiento agregando índices a una base de datos existente: esto no es una opción con Table service.</span><span class="sxs-lookup"><span data-stu-id="1425b-251">For example, in a relational database it's often possible to address performance issues simply by adding indexes to an existing database: this is not an option with the Table service.</span></span>  
> 
> 

<span data-ttu-id="1425b-252">Esta sección se centra en los problemas clave que se deben solucionar al diseñar las tablas para las consultas.</span><span class="sxs-lookup"><span data-stu-id="1425b-252">This section focuses on the key issues you must address when you design your tables for querying.</span></span> <span data-ttu-id="1425b-253">Entre los temas tratados en esta sección se incluyen:</span><span class="sxs-lookup"><span data-stu-id="1425b-253">The topics covered in this section include:</span></span>

* [<span data-ttu-id="1425b-254">Cómo afecta al rendimiento de las consultas su elección de PartitionKey y RowKey</span><span class="sxs-lookup"><span data-stu-id="1425b-254">How your choice of PartitionKey and RowKey impacts query performance</span></span>](#how-your-choice-of-partitionkey-and-rowkey-impacts-query-performance)
* [<span data-ttu-id="1425b-255">Elegir un PartitionKey apropiado</span><span class="sxs-lookup"><span data-stu-id="1425b-255">Choosing an appropriate PartitionKey</span></span>](#choosing-an-appropriate-partitionkey)
* [<span data-ttu-id="1425b-256">Optimización de consultas para Table service</span><span class="sxs-lookup"><span data-stu-id="1425b-256">Optimizing queries for the Table service</span></span>](#optimizing-queries-for-the-table-service)
* [<span data-ttu-id="1425b-257">Ordenación de los datos de Table service</span><span class="sxs-lookup"><span data-stu-id="1425b-257">Sorting data in the Table service</span></span>](#sorting-data-in-the-table-service)

### <a name="how-your-choice-of-partitionkey-and-rowkey-impacts-query-performance"></a><span data-ttu-id="1425b-258">Cómo afecta al rendimiento de las consultas su elección de PartitionKey y RowKey</span><span class="sxs-lookup"><span data-stu-id="1425b-258">How your choice of PartitionKey and RowKey impacts query performance</span></span>
<span data-ttu-id="1425b-259">Los ejemplos siguientes asumen que Table service almacena las entidades employee con la estructura siguiente (la mayoría de los ejemplos omiten la propiedad **Timestamp** para mayor claridad):</span><span class="sxs-lookup"><span data-stu-id="1425b-259">The following examples assume the table service is storing employee entities with the following structure (most of the examples omit the **Timestamp** property for clarity):</span></span>  

| <span data-ttu-id="1425b-260">*Nombre de la columna*</span><span class="sxs-lookup"><span data-stu-id="1425b-260">*Column name*</span></span> | <span data-ttu-id="1425b-261">*Tipo de datos*</span><span class="sxs-lookup"><span data-stu-id="1425b-261">*Data type*</span></span> |
| --- | --- |
| <span data-ttu-id="1425b-262">**PartitionKey** (nombre de departamento)</span><span class="sxs-lookup"><span data-stu-id="1425b-262">**PartitionKey** (Department Name)</span></span> |<span data-ttu-id="1425b-263">String</span><span class="sxs-lookup"><span data-stu-id="1425b-263">String</span></span> |
| <span data-ttu-id="1425b-264">**RowKey** (Identificación de empleado)</span><span class="sxs-lookup"><span data-stu-id="1425b-264">**RowKey** (Employee Id)</span></span> |<span data-ttu-id="1425b-265">String</span><span class="sxs-lookup"><span data-stu-id="1425b-265">String</span></span> |
| <span data-ttu-id="1425b-266">**Nombre**</span><span class="sxs-lookup"><span data-stu-id="1425b-266">**FirstName**</span></span> |<span data-ttu-id="1425b-267">String</span><span class="sxs-lookup"><span data-stu-id="1425b-267">String</span></span> |
| <span data-ttu-id="1425b-268">**Apellidos**</span><span class="sxs-lookup"><span data-stu-id="1425b-268">**LastName**</span></span> |<span data-ttu-id="1425b-269">String</span><span class="sxs-lookup"><span data-stu-id="1425b-269">String</span></span> |
| <span data-ttu-id="1425b-270">**Edad**</span><span class="sxs-lookup"><span data-stu-id="1425b-270">**Age**</span></span> |<span data-ttu-id="1425b-271">Entero</span><span class="sxs-lookup"><span data-stu-id="1425b-271">Integer</span></span> |
| <span data-ttu-id="1425b-272">**EmailAddress**</span><span class="sxs-lookup"><span data-stu-id="1425b-272">**EmailAddress**</span></span> |<span data-ttu-id="1425b-273">Cadena</span><span class="sxs-lookup"><span data-stu-id="1425b-273">String</span></span> |

<span data-ttu-id="1425b-274">En la sección [Descripción general de Table Service](#overview) se describen algunas de las características clave de Azure Table Service que tienen influencia directa en el diseño de la consulta.</span><span class="sxs-lookup"><span data-stu-id="1425b-274">The earlier section [Azure Table service overview](#overview) describes some of the key features of the Azure Table service that have a direct influence on designing for query.</span></span> <span data-ttu-id="1425b-275">Estos dan como resultado las siguientes directrices generales para diseñar consultas de Table service.</span><span class="sxs-lookup"><span data-stu-id="1425b-275">These result in the following general guidelines for designing Table service queries.</span></span> <span data-ttu-id="1425b-276">Tenga en cuenta que la sintaxis de filtro utilizada en los ejemplos siguientes es de la API de REST del Table Service. Para más información, consulte [Entidades de consulta](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span><span class="sxs-lookup"><span data-stu-id="1425b-276">Note that the filter syntax used in the examples below is from the Table service REST API, for more information see [Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span></span>  

* <span data-ttu-id="1425b-277">Una ***consulta de punto*** es la búsqueda más eficaz que puede usar y se recomienda para búsquedas de gran volumen o búsquedas que requieren menor latencia.</span><span class="sxs-lookup"><span data-stu-id="1425b-277">A ***Point Query*** is the most efficient lookup to use and is recommended to be used for high-volume lookups or lookups requiring lowest latency.</span></span> <span data-ttu-id="1425b-278">Este tipo de consulta puede utilizar los índices para localizar una entidad individual con gran eficacia si se especifican los valores **PartitionKey** y **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="1425b-278">Such a query can use the indexes to locate an individual entity very efficiently by specifying both the **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="1425b-279">Por ejemplo: $filter=(PartitionKey eq 'Sales') y (RowKey eq '2')</span><span class="sxs-lookup"><span data-stu-id="1425b-279">For example: $filter=(PartitionKey eq 'Sales') and (RowKey eq '2')</span></span>  
* <span data-ttu-id="1425b-280">La segunda opción más eficaz es una ***Consulta por rango*** que use **PartitionKey** y filtre un rango de valores **RowKey** para devolver más de una entidad.</span><span class="sxs-lookup"><span data-stu-id="1425b-280">Second best is a ***Range Query*** that uses the **PartitionKey** and filters on a range of **RowKey** values to return more than one entity.</span></span> <span data-ttu-id="1425b-281">El valor **PartitionKey** identifica una partición específica y los valores **RowKey** identifican un subconjunto de las entidades de esa partición.</span><span class="sxs-lookup"><span data-stu-id="1425b-281">The **PartitionKey** value identifies a specific partition, and the **RowKey** values identify a subset of the entities in that partition.</span></span> <span data-ttu-id="1425b-282">Por ejemplo: $filter=PartitionKey eq 'Sales”, RowKey ge 'S' y RowKey lt 'T'</span><span class="sxs-lookup"><span data-stu-id="1425b-282">For example: $filter=PartitionKey eq 'Sales' and RowKey ge 'S' and RowKey lt 'T'</span></span>  
* <span data-ttu-id="1425b-283">En tercer lugar, tiene un ***Examen de partición*** que usa **PartitionKey** y filtra otra propiedad no clave y que puede devolver más de una entidad.</span><span class="sxs-lookup"><span data-stu-id="1425b-283">Third best is a ***Partition Scan*** that uses the **PartitionKey** and filters on another non-key property and that may return more than one entity.</span></span> <span data-ttu-id="1425b-284">El valor **PartitionKey** identifica una partición específica y los valores de propiedad seleccionan un subconjunto de las entidades de esa partición.</span><span class="sxs-lookup"><span data-stu-id="1425b-284">The **PartitionKey** value identifies a specific partition, and the property values select for a subset of the entities in that partition.</span></span> <span data-ttu-id="1425b-285">Por ejemplo: $filter=PartitionKey eq 'Sales' y LastName eq 'Smith'</span><span class="sxs-lookup"><span data-stu-id="1425b-285">For example: $filter=PartitionKey eq 'Sales' and LastName eq 'Smith'</span></span>  
* <span data-ttu-id="1425b-286">Un ***Examen de tabla*** no incluye la **PartitionKey** y es bastante ineficaz, ya que busca en todas las particiones que componen la tabla todas las entidades coincidentes.</span><span class="sxs-lookup"><span data-stu-id="1425b-286">A ***Table Scan*** does not include the **PartitionKey** and is very inefficient because it searches all of the partitions that make up your table in turn for any matching entities.</span></span> <span data-ttu-id="1425b-287">Realizará un recorrido de tabla independientemente de si su filtro usa **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="1425b-287">It will perform a table scan regardless of whether or not your filter uses the **RowKey**.</span></span> <span data-ttu-id="1425b-288">Por ejemplo: $filter=LastName eq 'Jones'</span><span class="sxs-lookup"><span data-stu-id="1425b-288">For example: $filter=LastName eq 'Jones'</span></span>  
* <span data-ttu-id="1425b-289">Las consultas que devuelven varias entidades las devuelven ordenadas en orden **PartitionKey** y **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="1425b-289">Queries that return multiple entities return them sorted in **PartitionKey** and **RowKey** order.</span></span> <span data-ttu-id="1425b-290">Para evitar reordenar las entidades del cliente, seleccione un **RowKey** que defina el criterio de ordenación más común.</span><span class="sxs-lookup"><span data-stu-id="1425b-290">To avoid resorting the entities in the client, choose a **RowKey** that defines the most common sort order.</span></span>  

<span data-ttu-id="1425b-291">Tenga en cuenta que si usa un "**or**" para especificar un filtro basado en valores **RowKey**, se generará un examen de partición y no se tratará como una consulta de intervalo.</span><span class="sxs-lookup"><span data-stu-id="1425b-291">Note that using an "**or**" to specify a filter based on **RowKey** values results in a partition scan and is not treated as a range query.</span></span> <span data-ttu-id="1425b-292">Por lo tanto, debe evitar las consultas que usan filtros como: $filter=PartitionKey eq 'Sales' y (RowKey eq '121' o RowKey eq '322')</span><span class="sxs-lookup"><span data-stu-id="1425b-292">Therefore, you should avoid queries that use filters such as: $filter=PartitionKey eq 'Sales' and (RowKey eq '121' or RowKey eq '322')</span></span>  

<span data-ttu-id="1425b-293">Para obtener ejemplos de código de cliente que utilizan la biblioteca de clientes de Storage para ejecutar consultas eficaces, consulte:</span><span class="sxs-lookup"><span data-stu-id="1425b-293">For examples of client-side code that use the Storage Client Library to execute efficient queries, see:</span></span>  

* [<span data-ttu-id="1425b-294">Ejecutar una consulta de punto mediante la biblioteca de clientes de Storage</span><span class="sxs-lookup"><span data-stu-id="1425b-294">Executing a point query using the Storage Client Library</span></span>](#executing-a-point-query-using-the-storage-client-library)
* [<span data-ttu-id="1425b-295">Recuperar varias entidades con LINQ</span><span class="sxs-lookup"><span data-stu-id="1425b-295">Retrieving multiple entities using LINQ</span></span>](#retrieving-multiple-entities-using-linq)
* [<span data-ttu-id="1425b-296">Proyección de servidor</span><span class="sxs-lookup"><span data-stu-id="1425b-296">Server-side projection</span></span>](#server-side-projection)  

<span data-ttu-id="1425b-297">Para obtener ejemplos de código de cliente que pueda administrar varios tipos de entidad almacenados en la misma tabla, consulte:</span><span class="sxs-lookup"><span data-stu-id="1425b-297">For examples of client-side code that can handle multiple entity types stored in the same table, see:</span></span>  

* [<span data-ttu-id="1425b-298">Trabajar con tipos de entidad heterogéneos</span><span class="sxs-lookup"><span data-stu-id="1425b-298">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)  

### <a name="choosing-an-appropriate-partitionkey"></a><span data-ttu-id="1425b-299">Elegir un PartitionKey apropiado</span><span class="sxs-lookup"><span data-stu-id="1425b-299">Choosing an appropriate PartitionKey</span></span>
<span data-ttu-id="1425b-300">La elección del **PartitionKey** debe equilibrar la necesidad de habilitar el uso de EGT (para garantizar la coherencia) frente a la necesidad de distribuir las entidades en varias particiones (para asegurar que una solución escalable).</span><span class="sxs-lookup"><span data-stu-id="1425b-300">Your choice of **PartitionKey** should balance the need to enables the use of EGTs (to ensure consistency) against the requirement to distribute your entities across multiple partitions (to ensure a scalable solution).</span></span>  

<span data-ttu-id="1425b-301">En un extremo, puede almacenar todas las entidades en una sola partición, pero esto puede limitar la escalabilidad de su solución y podría impedir a Table service equilibrar la carga de las solicitudes.</span><span class="sxs-lookup"><span data-stu-id="1425b-301">At one extreme, you could store all your entities in a single partition, but this may limit the scalability of your solution and would prevent the table service from being able to load-balance requests.</span></span> <span data-ttu-id="1425b-302">En el otro extremo, puede almacenar una entidad por cada partición que sería muy escalable y que permite a Table service equilibrar la carga de las solicitudes, pero que podrían impedir que se utilicen transacciones de grupo de la entidad.</span><span class="sxs-lookup"><span data-stu-id="1425b-302">At the other extreme, you could store one entity per partition, which would be highly scalable and which enables the table service to load-balance requests, but which would prevent you from using entity group transactions.</span></span>  

<span data-ttu-id="1425b-303">Un **PartitionKey** idóneo es el que permite utilizar consultas eficaces y que tiene suficientes particiones para asegurarse de que su solución es escalable.</span><span class="sxs-lookup"><span data-stu-id="1425b-303">An ideal **PartitionKey** is one that enables you to use efficient queries and that has sufficient partitions to ensure your solution is scalable.</span></span> <span data-ttu-id="1425b-304">Normalmente, encontrará que las entidades tendrán una propiedad adecuada que distribuye las entidades entre particiones suficientes.</span><span class="sxs-lookup"><span data-stu-id="1425b-304">Typically, you will find that your entities will have a suitable property that distributes your entities across sufficient partitions.</span></span>

> [!NOTE]
> <span data-ttu-id="1425b-305">Por ejemplo, en un sistema que almacena información acerca de los usuarios o empleados, el identificador del usuario puede ser un buen PartitionKey.</span><span class="sxs-lookup"><span data-stu-id="1425b-305">For example, in a system that stores information about users or employees, UserID may be a good PartitionKey.</span></span> <span data-ttu-id="1425b-306">Puede que tenga varias entidades que utilizan un determinado identificador de usuario como clave de partición.</span><span class="sxs-lookup"><span data-stu-id="1425b-306">You may have several entities that use a given UserID as the partition key.</span></span> <span data-ttu-id="1425b-307">Cada entidad que almacena los datos de un usuario se agrupa en una sola partición y, de esta manera estas entidades están accesibles a través de las transacciones de grupo de entidad, y continúan siendo altamente escalables.</span><span class="sxs-lookup"><span data-stu-id="1425b-307">Each entity that stores data about a user is grouped into a single partition, and so these entities are accessible via entity group transactions, while still being highly scalable.</span></span>
> 
> 

<span data-ttu-id="1425b-308">Existen otros puntos adicionales que se tienen en cuenta al elegir **PartitionKey** y que están relacionados con la forma de insertar, actualizar y eliminar entidades: consulte la sección [Diseño de modificación de datos](#design-for-data-modification) .</span><span class="sxs-lookup"><span data-stu-id="1425b-308">There are additional considerations in your choice of **PartitionKey** that relate to how you will insert, update, and delete entities: see the section [Design for data modification](#design-for-data-modification) below.</span></span>  

### <a name="optimizing-queries-for-the-table-service"></a><span data-ttu-id="1425b-309">Optimización de consultas para Table service</span><span class="sxs-lookup"><span data-stu-id="1425b-309">Optimizing queries for the Table service</span></span>
<span data-ttu-id="1425b-310">Table Service indexará automáticamente las entidades mediante los valores **PartitionKey** y **RowKey** en un índice agrupado único, por lo tanto, este es el motivo por el que las consultas de punto son las más eficaces.</span><span class="sxs-lookup"><span data-stu-id="1425b-310">The Table service automatically indexes your entities using the **PartitionKey** and **RowKey** values in a single clustered index, hence the reason that point queries are the most efficient to use.</span></span> <span data-ttu-id="1425b-311">Sin embargo, no hay ningún índice distinto del índice agrupado en **PartitionKey** y **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="1425b-311">However, there are no indexes other than that on the clustered index on the **PartitionKey** and **RowKey**.</span></span>

<span data-ttu-id="1425b-312">Muchos diseños deben cumplir los requisitos para habilitar la búsqueda de entidades según varios criterios.</span><span class="sxs-lookup"><span data-stu-id="1425b-312">Many designs must meet requirements to enable lookup of entities based on multiple criteria.</span></span> <span data-ttu-id="1425b-313">Por ejemplo, localizar las entidades employee en función de correo electrónico, Id. de empleado o apellido.</span><span class="sxs-lookup"><span data-stu-id="1425b-313">For example, locating employee entities based on email, employee id, or last name.</span></span> <span data-ttu-id="1425b-314">Los siguientes patrones de la sección [Patrones de diseño de tabla](#table-design-patterns) tratan estos tipos de requisitos y describen las formas de solucionar el hecho de que Table Service no proporciona índices secundarios:</span><span class="sxs-lookup"><span data-stu-id="1425b-314">The following patterns in the section [Table Design Patterns](#table-design-patterns) address these types of requirement and describe ways of working around the fact that the Table service does not provide secondary indexes:</span></span>  

* <span data-ttu-id="1425b-315">[Patrón de índice secundario dentro de la partición](#intra-partition-secondary-index-pattern): almacenar varias copias de cada entidad con diferentes valores **RowKey** (en la misma partición) para habilitar búsquedas rápidas y eficaces y ordenaciones alternativas mediante el uso de diferentes valores **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="1425b-315">[Intra-partition secondary index pattern](#intra-partition-secondary-index-pattern) - Store multiple copies of each entity using different **RowKey** values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span>  
* <span data-ttu-id="1425b-316">[Patrón de índice secundario entre particiones](#inter-partition-secondary-index-pattern): almacenar varias copias de cada entidad con diferentes valores RowKey en particiones o en tablas independientes para habilitar búsquedas rápidas y eficaces y ordenaciones alternativas mediante el uso de diferentes valores **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="1425b-316">[Inter-partition secondary index pattern](#inter-partition-secondary-index-pattern) - Store multiple copies of each entity using different RowKey values in separate partitions or in separate tables to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span>  
* <span data-ttu-id="1425b-317">[Patrón de entidades de índice](#index-entities-pattern): mantener las entidades de índice para habilitar búsquedas eficaces que devuelvan listas de entidades.</span><span class="sxs-lookup"><span data-stu-id="1425b-317">[Index Entities Pattern](#index-entities-pattern) - Maintain index entities to enable efficient searches that return lists of entities.</span></span>  

### <a name="sorting-data-in-the-table-service"></a><span data-ttu-id="1425b-318">Ordenación de los datos de Table service</span><span class="sxs-lookup"><span data-stu-id="1425b-318">Sorting data in the Table service</span></span>
<span data-ttu-id="1425b-319">Table Service devuelve entidades ordenadas en orden ascendente según **PartitionKey** y, a continuación, por **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="1425b-319">The Table service returns entities sorted in ascending order based on **PartitionKey** and then by **RowKey**.</span></span> <span data-ttu-id="1425b-320">Estas claves son valores de cadena y para asegurarse de que los valores numéricos se ordenen correctamente, debe convertirlos a una longitud fija y rellenarlos con ceros.</span><span class="sxs-lookup"><span data-stu-id="1425b-320">These keys are string values and to ensure that numeric values sort correctly, you should convert them to a fixed length and pad them with zeroes.</span></span> <span data-ttu-id="1425b-321">Por ejemplo, si el valor de identificador de empleado que utiliza como **RowKey** es un valor entero, debe convertir el identificador de empleado **123** en **00000123**.</span><span class="sxs-lookup"><span data-stu-id="1425b-321">For example, if the employee id value you use as the **RowKey** is an integer value, you should convert employee id **123** to **00000123**.</span></span>  

<span data-ttu-id="1425b-322">Muchas aplicaciones tienen requisitos para utilizar datos ordenados en distintos órdenes: por ejemplo, ordenar los empleados por su nombre o por su fecha de contratación.</span><span class="sxs-lookup"><span data-stu-id="1425b-322">Many applications have requirements to use data sorted in different orders: for example, sorting employees by name, or by joining date.</span></span> <span data-ttu-id="1425b-323">Los patrones siguientes de la sección [Patrones de diseño de tabla](#table-design-patterns) tratan cómo alternar órdenes de clasificación para sus entidades:</span><span class="sxs-lookup"><span data-stu-id="1425b-323">The following patterns in the section [Table Design Patterns](#table-design-patterns) address how to alternate sort orders for your entities:</span></span>  

* <span data-ttu-id="1425b-324">[Patrón de índice secundario dentro de la partición](#intra-partition-secondary-index-pattern): almacenar varias copias de cada entidad con diferentes valores RowKey (en la misma partición) para habilitar búsquedas rápidas y eficaces y ordenaciones alternativas mediante el uso de diferentes valores RowKey.</span><span class="sxs-lookup"><span data-stu-id="1425b-324">[Intra-partition secondary index pattern](#intra-partition-secondary-index-pattern) - Store multiple copies of each entity using different RowKey values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different RowKey values.</span></span>  
* <span data-ttu-id="1425b-325">[Patrón de índice secundario entre particiones](#inter-partition-secondary-index-pattern): almacenar varias copias de cada entidad con diferentes valores RowKey en particiones en tablas independientes para habilitar búsquedas rápidas y eficaces y ordenaciones alternativas mediante el uso de diferentes valores RowKey.</span><span class="sxs-lookup"><span data-stu-id="1425b-325">[Inter-partition secondary index pattern](#inter-partition-secondary-index-pattern) - Store multiple copies of each entity using different RowKey values in separate partitions in separate tables to enable fast and efficient lookups and alternate sort orders by using different RowKey values.</span></span>
* <span data-ttu-id="1425b-326">[Patrón final del registro](#log-tail-pattern): recupere las entidades *n* agregadas recientemente a una partición utilizando un valor **RowKey** que se clasifique en orden de fecha y hora inverso.</span><span class="sxs-lookup"><span data-stu-id="1425b-326">[Log tail pattern](#log-tail-pattern) - Retrieve the *n* entities most recently added to a partition by using a **RowKey** value that sorts in reverse date and time order.</span></span>  

## <a name="design-for-data-modification"></a><span data-ttu-id="1425b-327">Diseño para la modificación de datos</span><span class="sxs-lookup"><span data-stu-id="1425b-327">Design for data modification</span></span>
<span data-ttu-id="1425b-328">Esta sección se centra en las consideraciones de diseño para optimizar las inserciones, actualizaciones y eliminaciones.</span><span class="sxs-lookup"><span data-stu-id="1425b-328">This section focuses on the design considerations for optimizing inserts, updates, and deletes.</span></span> <span data-ttu-id="1425b-329">En algunos casos, deberá evaluar el equilibrio entre los diseños que se optimizan para realizar una consulta en diseños que optimizan la modificación de datos como lo hace usted en los diseños de bases de datos relacionales (aunque las técnicas para administrar las ventajas y desventajas de diseño son diferentes en una base de datos relacional).</span><span class="sxs-lookup"><span data-stu-id="1425b-329">In some cases, you will need to evaluate the trade-off between designs that optimize for querying against designs that optimize for data modification just as you do in designs for relational databases (although the techniques for managing the design trade-offs are different in a relational database).</span></span> <span data-ttu-id="1425b-330">En la sección [Patrones de diseño de tabla](#table-design-patterns) se describen algunos modelos de diseño detallados para Table service y se destacan algunas de estas ventajas e inconvenientes.</span><span class="sxs-lookup"><span data-stu-id="1425b-330">The section [Table Design Patterns](#table-design-patterns) describes some detailed design patterns for the Table service and highlights some these trade-offs.</span></span> <span data-ttu-id="1425b-331">En la práctica, encontrará que muchos diseños optimizados para consultar entidades también funcionan bien para la modificación de entidades.</span><span class="sxs-lookup"><span data-stu-id="1425b-331">In practice, you will find that many designs optimized for querying entities also work well for modifying entities.</span></span>  

### <a name="optimizing-the-performance-of-insert-update-and-delete-operations"></a><span data-ttu-id="1425b-332">Optimizar el rendimiento de las operaciones de inserción, actualización y eliminación</span><span class="sxs-lookup"><span data-stu-id="1425b-332">Optimizing the performance of insert, update, and delete operations</span></span>
<span data-ttu-id="1425b-333">Para actualizar o eliminar una entidad, debe poder identificarla mediante el uso de los valores **PartitionKey** y **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="1425b-333">To update or delete an entity, you must be able to identify it by using the **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="1425b-334">En este sentido, la elección de **PartitionKey** y **RowKey** para modificar entidades debería seguir criterios similares a su elección para admitir consultas de punto porque desea identificar las entidades de la forma más eficaz posible.</span><span class="sxs-lookup"><span data-stu-id="1425b-334">In this respect, your choice of **PartitionKey** and **RowKey** for modifying entities should follow similar criteria to your choice to support point queries because you want to identify entities as efficiently as possible.</span></span> <span data-ttu-id="1425b-335">No desea utilizar un examen ineficaz de partición o de tabla para buscar una entidad con el fin de detectar los valores **PartitionKey** y **RowKey** que necesita actualizar o eliminar.</span><span class="sxs-lookup"><span data-stu-id="1425b-335">You do not want to use an inefficient partition or table scan to locate an entity in order to discover the **PartitionKey** and **RowKey** values you need to update or delete it.</span></span>  

<span data-ttu-id="1425b-336">Los modelos siguientes de la sección [Patrones de diseño de tabla](#table-design-patterns) tratan la optimización del rendimiento o la inserción, actualización y las operaciones de eliminación:</span><span class="sxs-lookup"><span data-stu-id="1425b-336">The following patterns in the section [Table Design Patterns](#table-design-patterns) address optimizing the performance or your insert, update, and delete operations:</span></span>  

* <span data-ttu-id="1425b-337">[Patrón de eliminación de gran volumen](#high-volume-delete-pattern): habilitar la eliminación de un gran volumen de entidades mediante el almacenamiento de todas las entidades para su eliminación simultánea en su propia tabla independiente; elimine las entidades mediante la eliminación de la tabla.</span><span class="sxs-lookup"><span data-stu-id="1425b-337">[High volume delete pattern](#high-volume-delete-pattern) - Enable the deletion of a high volume of entities by storing all the entities for simultaneous deletion in their own separate table; you delete the entities by deleting the table.</span></span>  
* <span data-ttu-id="1425b-338">[Patrón de serie de datos](#data-series-pattern): almacenar una serie de datos completa en una sola entidad para minimizar el número de solicitudes que realice.</span><span class="sxs-lookup"><span data-stu-id="1425b-338">[Data series pattern](#data-series-pattern) - Store complete data series in a single entity to minimize the number of requests you make.</span></span>  
* <span data-ttu-id="1425b-339">[Patrón de entidades amplio](#wide-entities-pattern): usar varias entidades físicas para almacenar entidades lógicas con más de 252 propiedades.</span><span class="sxs-lookup"><span data-stu-id="1425b-339">[Wide entities pattern](#wide-entities-pattern) - Use multiple physical entities to store logical entities with more than 252 properties.</span></span>  
* <span data-ttu-id="1425b-340">[Patrón de entidades de gran tamaño](#large-entities-pattern): use Blob Storage para almacenar valores de propiedad de gran tamaño.</span><span class="sxs-lookup"><span data-stu-id="1425b-340">[Large entities pattern](#large-entities-pattern) - Use blob storage to store large property values.</span></span>  

### <a name="ensuring-consistency-in-your-stored-entities"></a><span data-ttu-id="1425b-341">Garantizar la coherencia en las entidades almacenadas</span><span class="sxs-lookup"><span data-stu-id="1425b-341">Ensuring consistency in your stored entities</span></span>
<span data-ttu-id="1425b-342">El otro factor clave que afecta a su elección de claves para optimizar las modificaciones de datos es cómo garantizar la coherencia mediante el uso de transacciones atómicas.</span><span class="sxs-lookup"><span data-stu-id="1425b-342">The other key factor that influences your choice of keys for optimizing data modifications is how to ensure consistency by using atomic transactions.</span></span> <span data-ttu-id="1425b-343">Solo puede utilizar un EGT para operar en las entidades almacenadas en la misma partición.</span><span class="sxs-lookup"><span data-stu-id="1425b-343">You can only use an EGT to operate on entities stored in the same partition.</span></span>  

<span data-ttu-id="1425b-344">Los siguientes patrones de la sección [Patrones de diseño de tabla](#table-design-patterns) tratan la administración de coherencia:</span><span class="sxs-lookup"><span data-stu-id="1425b-344">The following patterns in the section [Table Design Patterns](#table-design-patterns) address managing consistency:</span></span>  

* <span data-ttu-id="1425b-345">[Patrón de índice secundario dentro de la partición](#intra-partition-secondary-index-pattern): almacenar varias copias de cada entidad con diferentes valores **RowKey** (en la misma partición) para habilitar búsquedas rápidas y eficaces y ordenaciones alternativas mediante el uso de diferentes valores **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="1425b-345">[Intra-partition secondary index pattern](#intra-partition-secondary-index-pattern) - Store multiple copies of each entity using different **RowKey** values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span>  
* <span data-ttu-id="1425b-346">[Patrón de índice secundario entre particiones](#inter-partition-secondary-index-pattern): almacenar varias copias de cada entidad con diferentes valores RowKey en particiones o en tablas independientes para habilitar búsquedas rápidas y eficaces y ordenaciones alternativas mediante el uso de diferentes valores **RowKey** .</span><span class="sxs-lookup"><span data-stu-id="1425b-346">[Inter-partition secondary index pattern](#inter-partition-secondary-index-pattern) - Store multiple copies of each entity using different RowKey values in separate partitions or in separate tables to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span>  
* <span data-ttu-id="1425b-347">[Patrón final coherente de transacciones](#eventually-consistent-transactions-pattern): habilitar el comportamiento final coherente a través de límites de partición o los límites del sistema de almacenamiento mediante el uso de las colas de Azure.</span><span class="sxs-lookup"><span data-stu-id="1425b-347">[Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) - Enable eventually consistent behavior across partition boundaries or storage system boundaries by using Azure queues.</span></span>
* <span data-ttu-id="1425b-348">[Patrón de entidades de índice](#index-entities-pattern): mantener las entidades de índice para habilitar búsquedas eficaces que devuelvan listas de entidades.</span><span class="sxs-lookup"><span data-stu-id="1425b-348">[Index Entities Pattern](#index-entities-pattern) - Maintain index entities to enable efficient searches that return lists of entities.</span></span>  
* <span data-ttu-id="1425b-349">[Patrón de desnormalización](#denormalization-pattern): combinar datos relacionados entre sí en una sola entidad para recuperar todos los datos que necesita con una consulta de punto único.</span><span class="sxs-lookup"><span data-stu-id="1425b-349">[Denormalization pattern](#denormalization-pattern) - Combine related data together in a single entity to enable you to retrieve all the data you need with a single point query.</span></span>  
* <span data-ttu-id="1425b-350">[Patrón de serie de datos](#data-series-pattern): almacenar una serie de datos completa en una sola entidad para minimizar el número de solicitudes que realice.</span><span class="sxs-lookup"><span data-stu-id="1425b-350">[Data series pattern](#data-series-pattern) - Store complete data series in a single entity to minimize the number of requests you make.</span></span>  

<span data-ttu-id="1425b-351">Para obtener información sobre EGT, consulte la sección [Transacciones de grupo de entidad (EGT)](#entity-group-transactions).</span><span class="sxs-lookup"><span data-stu-id="1425b-351">For information about entity group transactions, see the section [Entity Group Transactions](#entity-group-transactions).</span></span>  

### <a name="ensuring-your-design-for-efficient-modifications-facilitates-efficient-queries"></a><span data-ttu-id="1425b-352">Garantizar su diseño para efectuar modificaciones eficientes facilita la realización de consultas eficaces</span><span class="sxs-lookup"><span data-stu-id="1425b-352">Ensuring your design for efficient modifications facilitates efficient queries</span></span>
<span data-ttu-id="1425b-353">En muchos casos, un diseño para los resultados de consultas eficaces en modificaciones eficaces, pero siempre debe evaluar si este es el caso para su escenario concreto.</span><span class="sxs-lookup"><span data-stu-id="1425b-353">In many cases, a design for efficient querying results in efficient modifications, but you should always evaluate whether this is the case for your specific scenario.</span></span> <span data-ttu-id="1425b-354">Algunos de los patrones de la sección [Patrones de diseño de tabla](#table-design-patterns) evalúan explícitamente equilibrios entre entidades de consulta y modificación, y debe tener siempre en cuenta el número de cada tipo de operación.</span><span class="sxs-lookup"><span data-stu-id="1425b-354">Some of the patterns in the section [Table Design Patterns](#table-design-patterns) explicitly evaluate trade-offs between querying and modifying entities, and you should always take into account the number of each type of operation.</span></span>  

<span data-ttu-id="1425b-355">Los siguientes patrones de la sección [Patrones de diseño de tabla](#table-design-patterns) tratan el equilibrio entre diseños para efectuar consultas eficaces y diseños para la modificación eficaz de datos:</span><span class="sxs-lookup"><span data-stu-id="1425b-355">The following patterns in the section [Table Design Patterns](#table-design-patterns) address trade-offs between designing for efficient queries and designing for efficient data modification:</span></span>  

* <span data-ttu-id="1425b-356">[Patrón de clave compuesta](#compound-key-pattern) : utilice valores **RowKey** compuestos para permitir a un cliente buscar datos relacionados con una consulta de punto único.</span><span class="sxs-lookup"><span data-stu-id="1425b-356">[Compound key pattern](#compound-key-pattern) - Use compound **RowKey** values to enable a client to lookup related data with a single point query.</span></span>  
* <span data-ttu-id="1425b-357">[Patrón final del registro](#log-tail-pattern): recupere las entidades *n* agregadas recientemente a una partición utilizando un valor **RowKey** que se clasifique en orden de fecha y hora inverso.</span><span class="sxs-lookup"><span data-stu-id="1425b-357">[Log tail pattern](#log-tail-pattern) - Retrieve the *n* entities most recently added to a partition by using a **RowKey** value that sorts in reverse date and time order.</span></span>  

## <a name="encrypting-table-data"></a><span data-ttu-id="1425b-358">Cifrado de datos de tablas</span><span class="sxs-lookup"><span data-stu-id="1425b-358">Encrypting Table Data</span></span>
<span data-ttu-id="1425b-359">La biblioteca de clientes de Azure Storage para .NET admite el cifrado de propiedades de entidades de cadena en operaciones de insertar y reemplazar.</span><span class="sxs-lookup"><span data-stu-id="1425b-359">The .NET Azure Storage Client Library supports encryption of string entity properties for insert and replace operations.</span></span> <span data-ttu-id="1425b-360">Las cadenas cifradas se almacenan en el servicio como propiedades binarias y se convierten de nuevo en cadenas después del descifrado.</span><span class="sxs-lookup"><span data-stu-id="1425b-360">The encrypted strings are stored on the service as binary properties, and they are converted back to strings after decryption.</span></span>    

<span data-ttu-id="1425b-361">Para las tablas, además de la directiva de cifrado, los usuarios deben especificar las propiedades que se van a cifrar.</span><span class="sxs-lookup"><span data-stu-id="1425b-361">For tables, in addition to the encryption policy, users must specify the properties to be encrypted.</span></span> <span data-ttu-id="1425b-362">Para ello, pueden especificar un atributo EncryptProperty (para las entidades POCO que se derivan de TableEntity) o una resolución de cifrado en las opciones de solicitud.</span><span class="sxs-lookup"><span data-stu-id="1425b-362">This can be done by either specifying an [EncryptProperty] attribute (for POCO entities that derive from TableEntity) or an encryption resolver in request options.</span></span> <span data-ttu-id="1425b-363">Una resolución de cifrado es un delegado que toma una clave de partición, una clave de fila y un nombre de propiedad y devuelve un valor booleano que indica si se debe cifrar dicha propiedad.</span><span class="sxs-lookup"><span data-stu-id="1425b-363">An encryption resolver is a delegate that takes a partition key, row key, and property name and returns a Boolean that indicates whether that property should be encrypted.</span></span> <span data-ttu-id="1425b-364">Durante el cifrado, la biblioteca de cliente usará esta información para decidir si se debe cifrar una propiedad mientras se escribe en la conexión.</span><span class="sxs-lookup"><span data-stu-id="1425b-364">During encryption, the client library will use this information to decide whether a property should be encrypted while writing to the wire.</span></span> <span data-ttu-id="1425b-365">El delegado también proporciona la posibilidad de lógica con respecto a la forma de cifrar las propiedades.</span><span class="sxs-lookup"><span data-stu-id="1425b-365">The delegate also provides for the possibility of logic around how properties are encrypted.</span></span> <span data-ttu-id="1425b-366">(Por ejemplo, si el valor es X, hay que cifrar la propiedad A; en caso contrario, hay que cifrar las propiedades A y B). Tenga en cuenta que no es necesario proporcionar esta información para leer o consultar entidades.</span><span class="sxs-lookup"><span data-stu-id="1425b-366">(For example, if X, then encrypt property A; otherwise encrypt properties A and B.) Note that it is not necessary to provide this information while reading or querying entities.</span></span>

<span data-ttu-id="1425b-367">Tenga en cuenta que actualmente no se admite la combinación.</span><span class="sxs-lookup"><span data-stu-id="1425b-367">Note that merge is not currently supported.</span></span> <span data-ttu-id="1425b-368">Puesto que un subconjunto de propiedades puede haberse cifrado previamente con una clave distinta, si simplemente se combinan las nuevas propiedades y se actualizan los metadatos, se producirá una pérdida de datos.</span><span class="sxs-lookup"><span data-stu-id="1425b-368">Since a subset of properties may have been encrypted previously using a different key, simply merging the new properties and updating the metadata will result in data loss.</span></span> <span data-ttu-id="1425b-369">Para realizar una combinación es necesario realizar llamadas de servicio adicionales para leer la entidad existente desde el servicio. También puede usar una nueva clave por propiedad. Ninguno de estos procedimientos es adecuado por motivos de rendimiento.</span><span class="sxs-lookup"><span data-stu-id="1425b-369">Merging either requires making extra service calls to read the pre-existing entity from the service, or using a new key per property, both of which are not suitable for performance reasons.</span></span>     

<span data-ttu-id="1425b-370">Para información acerca del cifrado de datos de tablas, consulte [Cifrado del lado cliente y Azure Key Vault para Microsoft Azure Storage](storage-client-side-encryption.md).</span><span class="sxs-lookup"><span data-stu-id="1425b-370">For information about encrypting table data, see [Client-Side Encryption and Azure Key Vault for Microsoft Azure Storage](storage-client-side-encryption.md).</span></span>  

## <a name="modelling-relationships"></a><span data-ttu-id="1425b-371">Relaciones de modelos</span><span class="sxs-lookup"><span data-stu-id="1425b-371">Modelling relationships</span></span>
<span data-ttu-id="1425b-372">La creación de modelos de dominio es un paso clave en el diseño de sistemas complejos.</span><span class="sxs-lookup"><span data-stu-id="1425b-372">Building domain models is a key step in the design of complex systems.</span></span> <span data-ttu-id="1425b-373">Normalmente, se utiliza el proceso de modelo para identificar las entidades y las relaciones entre ellos como manera de entender el dominio de negocio e informar del diseño del sistema.</span><span class="sxs-lookup"><span data-stu-id="1425b-373">Typically, you use the modelling process to identify entities and the relationships between them as a way to understand the business domain and inform the design of your system.</span></span> <span data-ttu-id="1425b-374">Esta sección se centra en cómo puede convertir algunos de los tipos de relación comunes encontrados en los modelos de dominio en diseños para Table service.</span><span class="sxs-lookup"><span data-stu-id="1425b-374">This section focuses on how you can translate some of the common relationship types found in domain models to designs for the Table service.</span></span> <span data-ttu-id="1425b-375">El proceso de asignación de un modelo de datos lógico a uno físico basado en NoSQL es muy diferente del que se utiliza cuando se diseña una base de datos relacional.</span><span class="sxs-lookup"><span data-stu-id="1425b-375">The process of mapping from a logical data-model to a physical NoSQL based data-model is very different from that used when designing a relational database.</span></span> <span data-ttu-id="1425b-376">El diseño de bases de datos relacionales normalmente supone un proceso de normalización de datos optimizado para minimizar la redundancia y una capacidad de consulta declarativa que abstrae el modo de funcionamiento de la implementación de la base de datos.</span><span class="sxs-lookup"><span data-stu-id="1425b-376">Relational databases design typically assumes a data normalization process optimized for minimizing redundancy – and a declarative querying capability that abstracts how the implementation of how the database works.</span></span>  

### <a name="one-to-many-relationships"></a><span data-ttu-id="1425b-377">Relaciones uno a varios</span><span class="sxs-lookup"><span data-stu-id="1425b-377">One-to-many relationships</span></span>
<span data-ttu-id="1425b-378">Las relaciones uno a varios entre los objetos de dominio de negocio se producen con mucha frecuencia: por ejemplo, cuando un departamento tiene muchos empleados.</span><span class="sxs-lookup"><span data-stu-id="1425b-378">One-to-many relationships between business domain objects occur very frequently: for example, one department has many employees.</span></span> <span data-ttu-id="1425b-379">Hay varias formas de implementar relaciones uno a varios en Table service, cada una con los correspondientes pros y contras para el escenario en concreto.</span><span class="sxs-lookup"><span data-stu-id="1425b-379">There are several ways to implement one-to-many relationships in the Table service each with pros and cons that may be relevant to the particular scenario.</span></span>  

<span data-ttu-id="1425b-380">Considere el ejemplo de una gran empresa multinacional con decenas de miles de departamentos y entidades de empleado en las que cada departamento tiene muchos empleados y cada empleado está asociado a un departamento determinado.</span><span class="sxs-lookup"><span data-stu-id="1425b-380">Consider the example of a large multi-national corporation with tens of thousands of departments and employee entities where every department has many employees and each employee as associated with one specific department.</span></span> <span data-ttu-id="1425b-381">Un enfoque consiste en almacenar el departamento independiente y entidades de empleado como las siguientes:</span><span class="sxs-lookup"><span data-stu-id="1425b-381">One approach is to store separate department and employee entities such as these:</span></span>  

![][1]

<span data-ttu-id="1425b-382">En este ejemplo se muestra una relación de uno a varios implícita entre los tipos basados en el valor **PartitionKey** .</span><span class="sxs-lookup"><span data-stu-id="1425b-382">This example shows an implicit one-to-many relationship between the types based on the **PartitionKey** value.</span></span> <span data-ttu-id="1425b-383">Cada departamento puede tener muchos empleados.</span><span class="sxs-lookup"><span data-stu-id="1425b-383">Each department can have many employees.</span></span>  

<span data-ttu-id="1425b-384">En este ejemplo también se muestra una entidad de departamento y sus entidades relacionadas de empleado relacionadas en la misma partición.</span><span class="sxs-lookup"><span data-stu-id="1425b-384">This example also shows a department entity and its related employee entities in the same partition.</span></span> <span data-ttu-id="1425b-385">Puede elegir usar distintas particiones, tablas o incluso cuentas de almacenamiento para los diferentes tipos de entidad.</span><span class="sxs-lookup"><span data-stu-id="1425b-385">You could choose to use different partitions, tables, or even storage accounts for the different entity types.</span></span>  

<span data-ttu-id="1425b-386">Un enfoque alternativo es desnormalizar los datos y almacenar solo las entidades de empleado con datos sin normalizar de departamentos tal como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="1425b-386">An alternative approach is to denormalize your data and store only employee entities with denormalized department data as shown in the following example.</span></span> <span data-ttu-id="1425b-387">En este escenario concreto, este enfoque sin normalizar puede que no sea el mejor si tiene un requisito para poder cambiar los detalles de un administrador de departamento porque para ello deberá actualizar a todos los empleados del departamento.</span><span class="sxs-lookup"><span data-stu-id="1425b-387">In this particular scenario, this denormalized approach may not be the best if you have a requirement to be able to change the details of a department manager because to do this you need to update every employee in the department.</span></span>  

![][2]

<span data-ttu-id="1425b-388">Para obtener más información, consulte más adelante en esta guía el [Patrón de desnormalización](#denormalization-pattern) .</span><span class="sxs-lookup"><span data-stu-id="1425b-388">For more information, see the [Denormalization pattern](#denormalization-pattern) later in this guide.</span></span>  

<span data-ttu-id="1425b-389">En la tabla siguiente se resumen las ventajas y desventajas de cada uno de los métodos descritos anteriormente para almacenar entidades de departamento y empleado que tienen una relación uno a varios.</span><span class="sxs-lookup"><span data-stu-id="1425b-389">The following table summarizes the pros and cons of each of the approaches outlined above for storing employee and department entities that have a one-to-many relationship.</span></span> <span data-ttu-id="1425b-390">También debe tener en cuenta la frecuencia con que espera realizar varias operaciones: puede ser aceptable tener un diseño que incluye una operación costosa si esa operación solo ocurre con poca frecuencia.</span><span class="sxs-lookup"><span data-stu-id="1425b-390">You should also consider how often you expect to perform various operations: it may be acceptable to have a design that includes an expensive operation if that operation only happens infrequently.</span></span>  

<table>
<tr>
<th><span data-ttu-id="1425b-391">Enfoque</span><span class="sxs-lookup"><span data-stu-id="1425b-391">Approach</span></span></th>
<th><span data-ttu-id="1425b-392">Ventajas</span><span class="sxs-lookup"><span data-stu-id="1425b-392">Pros</span></span></th>
<th><span data-ttu-id="1425b-393">Desventajas</span><span class="sxs-lookup"><span data-stu-id="1425b-393">Cons</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="1425b-394">Tipos de entidad independientes, la misma partición, la misma tabla</span><span class="sxs-lookup"><span data-stu-id="1425b-394">Separate entity types, same partition, same table</span></span></td>
<td>
<ul>
<li><span data-ttu-id="1425b-395">Puede actualizar una entidad de departamento con una sola operación.</span><span class="sxs-lookup"><span data-stu-id="1425b-395">You can update a department entity with a single operation.</span></span></li>
<li><span data-ttu-id="1425b-396">Puede usar un EGT para mantener la coherencia si tiene un requisito para modificar una entidad department siempre que se actualice, inserte o elimine una entidad de empleado.</span><span class="sxs-lookup"><span data-stu-id="1425b-396">You can use an EGT to maintain consistency if you have a requirement to modify a department entity whenever you update/insert/delete an employee entity.</span></span> <span data-ttu-id="1425b-397">Por ejemplo, si mantiene un recuento de empleado del departamento para cada departamento.</span><span class="sxs-lookup"><span data-stu-id="1425b-397">For example if you maintain a departmental employee count for each department.</span></span></li>
</ul>
</td>
<td>
<ul>
<li><span data-ttu-id="1425b-398">Puede que necesite recuperar una entidad de empleado y de departamento para algunas actividades de cliente.</span><span class="sxs-lookup"><span data-stu-id="1425b-398">You may need to retrieve both an employee and a department entity for some client activities.</span></span></li>
<li><span data-ttu-id="1425b-399">Las operaciones de almacenamiento se producen en la misma partición.</span><span class="sxs-lookup"><span data-stu-id="1425b-399">Storage operations happen in the same partition.</span></span> <span data-ttu-id="1425b-400">Con volúmenes de transacciones elevados, esto puede producir un punto de conflicto.</span><span class="sxs-lookup"><span data-stu-id="1425b-400">At high transaction volumes, this may result in a hotspot.</span></span></li>
<li><span data-ttu-id="1425b-401">No se puede mover a un empleado a un nuevo departamento mediante un EGT.</span><span class="sxs-lookup"><span data-stu-id="1425b-401">You cannot move an employee to a new department using an EGT.</span></span></li>
</ul>
</td>
</tr>
<tr>
<td><span data-ttu-id="1425b-402">Tipos de entidad independientes, particiones o tablas distintas o cuentas de almacenamiento</span><span class="sxs-lookup"><span data-stu-id="1425b-402">Separate entity types, different partitions or tables or storage accounts</span></span></td>
<td>
<ul>
<li><span data-ttu-id="1425b-403">Puede actualizar una entidad de departamento o de empleado con una sola operación.</span><span class="sxs-lookup"><span data-stu-id="1425b-403">You can update a department entity or employee entity with a single operation.</span></span></li>
<li><span data-ttu-id="1425b-404">Con volúmenes de transacciones altos, esto puede ayudar a distribuir la carga entre más particiones.</span><span class="sxs-lookup"><span data-stu-id="1425b-404">At high transaction volumes, this may help spread the load across more partitions.</span></span></li>
</ul>
</td>
<td>
<ul>
<li><span data-ttu-id="1425b-405">Puede que necesite recuperar una entidad de empleado y de departamento para algunas actividades de cliente.</span><span class="sxs-lookup"><span data-stu-id="1425b-405">You may need to retrieve both an employee and a department entity for some client activities.</span></span></li>
<li><span data-ttu-id="1425b-406">No se pueden usar EGT para mantener la coherencia cuando se actualiza, inserta y elimina un empleado y se actualiza un departamento.</span><span class="sxs-lookup"><span data-stu-id="1425b-406">You cannot use EGTs to maintain consistency when you update/insert/delete an employee and update a department.</span></span> <span data-ttu-id="1425b-407">Por ejemplo, actualizando un recuento de empleados en una entidad de departamento.</span><span class="sxs-lookup"><span data-stu-id="1425b-407">For example, updating an employee count in a department entity.</span></span></li>
<li><span data-ttu-id="1425b-408">No se puede mover a un empleado a un nuevo departamento mediante un EGT.</span><span class="sxs-lookup"><span data-stu-id="1425b-408">You cannot move an employee to a new department using an EGT.</span></span></li>
</ul>
</td>
</tr>
<tr>
<td><span data-ttu-id="1425b-409">Desnormalizar en un único tipo de entidad</span><span class="sxs-lookup"><span data-stu-id="1425b-409">Denormalize into single entity type</span></span></td>
<td>
<ul>
<li><span data-ttu-id="1425b-410">Puede recuperar toda la información que necesita con una única solicitud.</span><span class="sxs-lookup"><span data-stu-id="1425b-410">You can retrieve all the information you need with a single request.</span></span></li>
</ul>
</td>
<td>
<ul>
<li><span data-ttu-id="1425b-411">Puede ser costoso de mantener la coherencia si necesita actualizar la información de departamento (esto requerirá actualizar a todos los empleados de un departamento).</span><span class="sxs-lookup"><span data-stu-id="1425b-411">It may be expensive to maintain consistency if you need to update department information (this would require you to update all the employees in a department).</span></span></li>
</ul>
</td>
</tr>
</table>

<span data-ttu-id="1425b-412">Cómo elegir entre estas opciones y cuáles de las ventajas y desventajas son más importantes, depende de los escenarios de aplicación concretos.</span><span class="sxs-lookup"><span data-stu-id="1425b-412">How you choose between these options, and which of the pros and cons are most significant, depends on your specific application scenarios.</span></span> <span data-ttu-id="1425b-413">Por ejemplo, la frecuencia con que modifica las entidades de departamento; necesitan todas las consultas de empleados la información adicional del departamento; ¿cómo de cerca se encuentra de los límites de escalabilidad de sus particiones o de su cuenta de almacenamiento?</span><span class="sxs-lookup"><span data-stu-id="1425b-413">For example, how often do you modify department entities; do all your employee queries need the additional departmental information; how close are you to the scalability limits on your partitions or your storage account?</span></span>  

### <a name="one-to-one-relationships"></a><span data-ttu-id="1425b-414">Relaciones uno a uno</span><span class="sxs-lookup"><span data-stu-id="1425b-414">One-to-one relationships</span></span>
<span data-ttu-id="1425b-415">Es posible que los modelos de dominio incluyan relaciones uno a uno entre las entidades.</span><span class="sxs-lookup"><span data-stu-id="1425b-415">Domain models may include one-to-one relationships between entities.</span></span> <span data-ttu-id="1425b-416">Si necesita implementar una relación uno a uno en Table service, también debe elegir cómo vincular las dos entidades relacionadas cuando se necesita para recuperar ambas.</span><span class="sxs-lookup"><span data-stu-id="1425b-416">If you need to implement a one-to-one relationship in the Table service, you must also choose how to link the two related entities when you need to retrieve them both.</span></span> <span data-ttu-id="1425b-417">Este vínculo puede ser implícito, en función de una convención en los valores de clave o explícito almacenando un vínculo en el formulario de los valores **PartitionKey** y **RowKey** de cada entidad con su entidad relacionada.</span><span class="sxs-lookup"><span data-stu-id="1425b-417">This link can be either implicit, based on a convention in the key values, or explicit by storing a link in the form of **PartitionKey** and **RowKey** values in each entity to its related entity.</span></span> <span data-ttu-id="1425b-418">Para obtener una explicación sobre si debe almacenar las entidades relacionadas en la misma partición, consulte la sección [Relaciones uno a varios](#one-to-many-relationships).</span><span class="sxs-lookup"><span data-stu-id="1425b-418">For a discussion of whether you should store the related entities in the same partition, see the section [One-to-many relationships](#one-to-many-relationships).</span></span>  

<span data-ttu-id="1425b-419">Tenga en cuenta que también hay consideraciones de implementación que podrían provocar la implementación de relaciones uno a uno en Table service:</span><span class="sxs-lookup"><span data-stu-id="1425b-419">Note that there are also implementation considerations that might lead you to implement one-to-one relationships in the Table service:</span></span>  

* <span data-ttu-id="1425b-420">Administración de entidades de gran tamaño (para obtener más información, consulte [Patrón de entidades de gran tamaño](#large-entities-pattern)).</span><span class="sxs-lookup"><span data-stu-id="1425b-420">Handling large entities (for more information, see [Large Entities Pattern](#large-entities-pattern)).</span></span>  
* <span data-ttu-id="1425b-421">Implementación de controles de acceso (para más información, consulte [Control de acceso con firmas de acceso compartido](#controlling-access-with-shared-access-signatures)).</span><span class="sxs-lookup"><span data-stu-id="1425b-421">Implementing access controls (for more information, see [Controlling access with Shared Access Signatures](#controlling-access-with-shared-access-signatures)).</span></span>  

### <a name="join-in-the-client"></a><span data-ttu-id="1425b-422">Únase al cliente</span><span class="sxs-lookup"><span data-stu-id="1425b-422">Join in the client</span></span>
<span data-ttu-id="1425b-423">Aunque hay formas de modelar las relaciones en Table service, no debe olvidar que las dos razones principales para utilizar Table service son la escalabilidad y el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="1425b-423">Although there are ways to model relationships in the Table service, you should not forget that the two prime reasons for using the Table service are scalability and performance.</span></span> <span data-ttu-id="1425b-424">Si encuentra que está modelando muchas relaciones que ponen en peligro el rendimiento y la escalabilidad de su solución, debe preguntarse si es necesario crear todas las relaciones de datos en el diseño de tabla.</span><span class="sxs-lookup"><span data-stu-id="1425b-424">If you find you are modelling many relationships that compromise the performance and scalability of your solution, you should ask yourself if it is necessary to build all the data relationships into your table design.</span></span> <span data-ttu-id="1425b-425">Es posible que pueda simplificar el diseño y mejorar la escalabilidad y el rendimiento de la solución si permite que la aplicación cliente realice las uniones necesarias.</span><span class="sxs-lookup"><span data-stu-id="1425b-425">You may be able to simplify the design and improve the scalability and performance of your solution if you let your client application perform any necessary joins.</span></span>  

<span data-ttu-id="1425b-426">Por ejemplo, si tiene tablas pequeñas que contienen datos que no cambian muy a menudo, puede recuperar estos datos una vez y almacenarlos en la caché en el cliente.</span><span class="sxs-lookup"><span data-stu-id="1425b-426">For example, if you have small tables that contain data that does not change very often, then you can retrieve this data once and cache it on the client.</span></span> <span data-ttu-id="1425b-427">Esto puede evitar repetidas idas y vueltas para recuperar los mismos datos.</span><span class="sxs-lookup"><span data-stu-id="1425b-427">This can avoid repeated roundtrips to retrieve the same data.</span></span> <span data-ttu-id="1425b-428">En los ejemplos que hemos visto en esta guía, es probable que el conjunto de departamentos de una organización pequeña sea pequeño y cambie con poca frecuencia, lo que lo convierte en un buen candidato para los datos que la aplicación cliente puede descargar una vez y almacenar en la memoria caché como datos de búsqueda.</span><span class="sxs-lookup"><span data-stu-id="1425b-428">In the examples we have looked at in this guide, the set of departments in a small organization is likely to be small and change infrequently making it a good candidate for data that client application can download once and cache as look up data.</span></span>  

### <a name="inheritance-relationships"></a><span data-ttu-id="1425b-429">Relaciones de herencia</span><span class="sxs-lookup"><span data-stu-id="1425b-429">Inheritance relationships</span></span>
<span data-ttu-id="1425b-430">Si la aplicación cliente usa un conjunto de clases que forman parte de una relación de herencia para representar entidades empresariales, puede conservar fácilmente las entidades en Table service.</span><span class="sxs-lookup"><span data-stu-id="1425b-430">If your client application uses a set of classes that form part of an inheritance relationship to represent business entities, you can easily persist those entities in the Table service.</span></span> <span data-ttu-id="1425b-431">Por ejemplo, el siguiente conjunto de clases puede estar definido en la aplicación cliente, donde **Person** es una clase abstracta.</span><span class="sxs-lookup"><span data-stu-id="1425b-431">For example, you might have the following set of classes defined in your client application where **Person** is an abstract class.</span></span>

![][3]

<span data-ttu-id="1425b-432">Puede conservar las instancias de las dos clases concretas en Table service utilizando una sola tabla Person mediante entidades que presentan este aspecto:</span><span class="sxs-lookup"><span data-stu-id="1425b-432">You can persist instances of the two concrete classes in the Table service using a single Person table using entities in that look like this:</span></span>  

![][4]

<span data-ttu-id="1425b-433">Para más información acerca de cómo trabajar con varios tipos de entidad en la misma tabla en el código de cliente, consulte la sección [Trabajo con tipos de entidad heterogéneos](#working-with-heterogeneous-entity-types) posteriormente en esta misma guía.</span><span class="sxs-lookup"><span data-stu-id="1425b-433">For more information about working with multiple entity types in the same table in client code, see the section [Working with heterogeneous entity types](#working-with-heterogeneous-entity-types) later in this guide.</span></span> <span data-ttu-id="1425b-434">Esto proporciona ejemplos de cómo reconocer el tipo de entidad en el código de cliente.</span><span class="sxs-lookup"><span data-stu-id="1425b-434">This provides examples of how to recognize the entity type in client code.</span></span>  

## <a name="table-design-patterns"></a><span data-ttu-id="1425b-435">Patrones de diseño de tabla</span><span class="sxs-lookup"><span data-stu-id="1425b-435">Table Design Patterns</span></span>
<span data-ttu-id="1425b-436">En las secciones anteriores, ha visto algunas discusiones detalladas acerca de cómo optimizar su diseño de tabla para recuperar datos de entidad mediante consultas y para insertar, actualizar y eliminar datos de la entidad.</span><span class="sxs-lookup"><span data-stu-id="1425b-436">In previous sections, you have seen some detailed discussions about how to optimize your table design for both retrieving entity data using queries and for inserting, updating, and deleting entity data.</span></span> <span data-ttu-id="1425b-437">En esta sección se describen algunos modelos adecuados para usarse con soluciones de Table service.</span><span class="sxs-lookup"><span data-stu-id="1425b-437">This section describes some patterns appropriate for use with Table service solutions.</span></span> <span data-ttu-id="1425b-438">Además, verá cómo puede prácticamente abordar algunos de los problemas y las ventajas e inconvenientes generados anteriormente en esta guía.</span><span class="sxs-lookup"><span data-stu-id="1425b-438">In addition, you will see how you can practically address some of the issues and trade-offs raised previously in this guide.</span></span> <span data-ttu-id="1425b-439">En el diagrama siguiente se resumen las relaciones entre los distintos patrones:</span><span class="sxs-lookup"><span data-stu-id="1425b-439">The following diagram summarizes the relationships between the different patterns:</span></span>  

![][5]

<span data-ttu-id="1425b-440">La asignación de patrones anterior resalta algunas relaciones entre patrones (azules) y antipatrones (naranja) que se documentan en esta guía.</span><span class="sxs-lookup"><span data-stu-id="1425b-440">The pattern map above highlights some relationships between patterns (blue) and anti-patterns (orange) that are documented in this guide.</span></span> <span data-ttu-id="1425b-441">Por supuesto, existen muchos otros patrones que merece la pena tener en cuenta.</span><span class="sxs-lookup"><span data-stu-id="1425b-441">There are of course many other patterns that are worth considering.</span></span> <span data-ttu-id="1425b-442">Por ejemplo, uno de los escenarios clave de Table Service es almacenar el [patrón de vistas materializadas](https://msdn.microsoft.com/library/azure/dn589782.aspx) desde [Segregación de responsabilidades de consultas de comandos (CQRS)](https://msdn.microsoft.com/library/azure/jj554200.aspx).</span><span class="sxs-lookup"><span data-stu-id="1425b-442">For example, one of the key scenarios for Table Service is to use the [Materialized View Pattern](https://msdn.microsoft.com/library/azure/dn589782.aspx) from the [Command Query Responsibility Segregation (CQRS)](https://msdn.microsoft.com/library/azure/jj554200.aspx) pattern.</span></span>  

### <a name="intra-partition-secondary-index-pattern"></a><span data-ttu-id="1425b-443">Patrón de índice secundario dentro de la partición</span><span class="sxs-lookup"><span data-stu-id="1425b-443">Intra-partition secondary index pattern</span></span>
<span data-ttu-id="1425b-444">Almacene varias copias de cada entidad con diferentes valores **RowKey** (en la misma partición) para habilitar búsquedas rápidas y eficaces y ordenaciones alternativas mediante el uso de diferentes valores **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="1425b-444">Store multiple copies of each entity using different **RowKey** values (in the same partition) to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span> <span data-ttu-id="1425b-445">La coherencia de las actualizaciones entre copias se puede mantener mediante EGT.</span><span class="sxs-lookup"><span data-stu-id="1425b-445">Updates between copies can be kept consistent using EGT's.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="1425b-446">Contexto y problema</span><span class="sxs-lookup"><span data-stu-id="1425b-446">Context and problem</span></span>
<span data-ttu-id="1425b-447">Table Service indexa automáticamente entidades mediante los valores **PartitionKey** y **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="1425b-447">The Table service automatically indexes entities using the **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="1425b-448">Esto permite que una aplicación cliente recupere una entidad eficazmente con estos valores.</span><span class="sxs-lookup"><span data-stu-id="1425b-448">This enables a client application to retrieve an entity efficiently using these values.</span></span> <span data-ttu-id="1425b-449">Por ejemplo, si se usa la estructura de tabla que se muestra a continuación, una aplicación cliente puede utilizar una consulta puntual para recuperar una entidad de empleado individual mediante el uso del nombre del departamento y el identificador de empleado (los valores **PartitionKey** y **RowKey**).</span><span class="sxs-lookup"><span data-stu-id="1425b-449">For example, using the table structure shown below, a client application can use a point query to retrieve an individual employee entity by using the department name and the employee id (the **PartitionKey** and **RowKey** values).</span></span> <span data-ttu-id="1425b-450">Un cliente también puede recuperar las entidades ordenadas por identificador de empleado dentro de cada departamento.</span><span class="sxs-lookup"><span data-stu-id="1425b-450">A client can also retrieve entities sorted by employee id within each department.</span></span>

![][6]

<span data-ttu-id="1425b-451">Si desea ser capaz de encontrar una entidad de empleado basada en el valor de otra propiedad, como la dirección de correo electrónico, debe usar un examen de la partición menos eficiente para encontrar a coincidencia.</span><span class="sxs-lookup"><span data-stu-id="1425b-451">If you also want to be able to find an employee entity based on the value of another property, such as email address, you must use a less efficient partition scan to find a match.</span></span> <span data-ttu-id="1425b-452">Esto se debe a que Table service no proporciona índices secundarios.</span><span class="sxs-lookup"><span data-stu-id="1425b-452">This is because the table service does not provide secondary indexes.</span></span> <span data-ttu-id="1425b-453">Además, no hay ninguna opción para solicitar una lista de empleados ordenados en un orden diferente a **RowKey** .</span><span class="sxs-lookup"><span data-stu-id="1425b-453">In addition, there is no option to request a list of employees sorted in a different order than **RowKey** order.</span></span>  

#### <a name="solution"></a><span data-ttu-id="1425b-454">Solución</span><span class="sxs-lookup"><span data-stu-id="1425b-454">Solution</span></span>
<span data-ttu-id="1425b-455">Para solucionar la falta de índices secundarios, puede almacenar varias copias de cada entidad con cada copia mediante un valor **RowKey** diferente.</span><span class="sxs-lookup"><span data-stu-id="1425b-455">To work around the lack of secondary indexes, you can store multiple copies of each entity with each copy using a different **RowKey** value.</span></span> <span data-ttu-id="1425b-456">Si almacena una entidad con las estructuras que se muestran a continuación, puede recuperar eficazmente las entidades de empleado en función de un identificador de empleado o de dirección de correo electrónico.</span><span class="sxs-lookup"><span data-stu-id="1425b-456">If you store an entity with the structures shown below, you can efficiently retrieve employee entities based on email address or employee id.</span></span> <span data-ttu-id="1425b-457">Los valores de prefijo de **RowKey**, "empid" y "email" permiten consultar un solo empleado o un intervalo de empleados mediante un intervalo de direcciones de correo electrónico o identificadores de empleado.</span><span class="sxs-lookup"><span data-stu-id="1425b-457">The prefix values for the **RowKey**, "empid_" and "email_" enable you to query for a single employee or a range of employees by using a range of email addresses or employee ids.</span></span>  

![][7]

<span data-ttu-id="1425b-458">Los dos criterios de filtro siguientes (uno de búsqueda por identificador de empleado y uno de búsqueda por dirección de correo electrónico) especifican consultas de punto:</span><span class="sxs-lookup"><span data-stu-id="1425b-458">The following two filter criteria (one looking up by employee id and one looking up by email address) both specify point queries:</span></span>  

* <span data-ttu-id="1425b-459">$filter=(PartitionKey eq 'Sales') y (RowKey eq 'empid_000223')</span><span class="sxs-lookup"><span data-stu-id="1425b-459">$filter=(PartitionKey eq 'Sales') and (RowKey eq 'empid_000223')</span></span>  
* <span data-ttu-id="1425b-460">$filter=(PartitionKey eq 'Sales') y (RowKey eq 'email_jonesj@contoso.com')</span><span class="sxs-lookup"><span data-stu-id="1425b-460">$filter=(PartitionKey eq 'Sales') and (RowKey eq 'email_jonesj@contoso.com')</span></span>  

<span data-ttu-id="1425b-461">Si consulta un intervalo de entidades de empleado, puede especificar un intervalo ordenado por identificador de empleado o un intervalo ordenado por dirección de correo electrónico mediante la consulta de entidades con el prefijo adecuado en **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="1425b-461">If you query for a range of employee entities, you can specify a range sorted in employee id order, or a range sorted in email address order by querying for entities with the appropriate prefix in the **RowKey**.</span></span>  

* <span data-ttu-id="1425b-462">Para buscar todos los empleados del departamento de ventas con un id. de empleado en el rango de 000100 a 000199 use: $filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000100') and (RowKey le 'empid_000199')</span><span class="sxs-lookup"><span data-stu-id="1425b-462">To find all the employees in the Sales department with an employee id in the range 000100 to 000199 use: $filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000100') and (RowKey le 'empid_000199')</span></span>  
* <span data-ttu-id="1425b-463">Para buscar todos los empleados del departamento de ventas con una dirección de correo electrónico que empiece por la letra 'a' use: $filter=(PartitionKey eq 'Sales') y (RowKey ge 'email_a') y (RowKey lt 'email_b')</span><span class="sxs-lookup"><span data-stu-id="1425b-463">To find all the employees in the Sales department with an email address starting with the letter 'a' use: $filter=(PartitionKey eq 'Sales') and (RowKey ge 'email_a') and (RowKey lt 'email_b')</span></span>  
  
  <span data-ttu-id="1425b-464">Tenga en cuenta que la sintaxis de filtro usada en los ejemplos anteriores corresponde a la API de REST de Table Service. Para más información, consulte [Entidades de consulta](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span><span class="sxs-lookup"><span data-stu-id="1425b-464">Note that the filter syntax used in the examples above is from the Table service REST API, for more information see [Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="1425b-465">Problemas y consideraciones</span><span class="sxs-lookup"><span data-stu-id="1425b-465">Issues and considerations</span></span>
<span data-ttu-id="1425b-466">Tenga en cuenta los puntos siguientes al decidir cómo implementar este patrón:</span><span class="sxs-lookup"><span data-stu-id="1425b-466">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="1425b-467">El almacenamiento en tablas es relativamente barato, por lo que la sobrecarga de costes de almacenamiento de datos duplicados no debe ser una preocupación importante.</span><span class="sxs-lookup"><span data-stu-id="1425b-467">Table storage is relatively cheap to use so the cost overhead of storing duplicate data should not be a major concern.</span></span> <span data-ttu-id="1425b-468">Sin embargo, debe evaluar siempre el coste del diseño según los requisitos de almacenamiento previstos y solo agregar entidades duplicadas para admitir las consultas que ejecutará la aplicación cliente.</span><span class="sxs-lookup"><span data-stu-id="1425b-468">However, you should always evaluate the cost of your design based on your anticipated storage requirements and only add duplicate entities to support the queries your client application will execute.</span></span>  
* <span data-ttu-id="1425b-469">Dado que las entidades de índice secundario se almacenan en la misma partición que las entidades originales, debe asegurarse de que no superen los objetivos de escalabilidad para una partición individual.</span><span class="sxs-lookup"><span data-stu-id="1425b-469">Because the secondary index entities are stored in the same partition as the original entities, you should ensure that you do not exceed the scalability targets for an individual partition.</span></span>  
* <span data-ttu-id="1425b-470">Puede mantener la coherencia de las entidades duplicadas utilizando EGT para actualizar las dos copias de la entidad de forma atómica.</span><span class="sxs-lookup"><span data-stu-id="1425b-470">You can keep your duplicate entities consistent with each other by using EGTs to update the two copies of the entity atomically.</span></span> <span data-ttu-id="1425b-471">Esto implica que debe almacenar todas las copias de una entidad en la misma partición.</span><span class="sxs-lookup"><span data-stu-id="1425b-471">This implies that you should store all copies of an entity in the same partition.</span></span> <span data-ttu-id="1425b-472">Para más información, consulte la sección [Uso de transacciones de grupos de entidades](#entity-group-transactions).</span><span class="sxs-lookup"><span data-stu-id="1425b-472">For more information, see the section [Using Entity Group Transactions](#entity-group-transactions).</span></span>  
* <span data-ttu-id="1425b-473">El valor que se usa **RowKey** debe ser único para cada entidad.</span><span class="sxs-lookup"><span data-stu-id="1425b-473">The value used for the **RowKey** must be unique for each entity.</span></span> <span data-ttu-id="1425b-474">Considere la posibilidad de usar valores de clave compuestos.</span><span class="sxs-lookup"><span data-stu-id="1425b-474">Consider using compound key values.</span></span>  
* <span data-ttu-id="1425b-475">Rellenar valores numéricos en **RowKey** (por ejemplo, el identificador de empleado 000223) permite corregir los criterios de ordenación y filtro en función de los límites inferior y superior.</span><span class="sxs-lookup"><span data-stu-id="1425b-475">Padding numeric values in the **RowKey** (for example, the employee id 000223), enables correct sorting and filtering based on upper and lower bounds.</span></span>  
* <span data-ttu-id="1425b-476">No es necesario duplicar todas las propiedades de su entidad.</span><span class="sxs-lookup"><span data-stu-id="1425b-476">You do not necessarily need to duplicate all the properties of your entity.</span></span> <span data-ttu-id="1425b-477">Por ejemplo, si las consultas que realizan búsquedas en las entidades mediante la dirección de correo electrónico de **RowKey** nunca necesitan la edad del empleado, dichas entidades podrían tener la siguiente estructura:</span><span class="sxs-lookup"><span data-stu-id="1425b-477">For example, if the queries that lookup the entities using the email address in the **RowKey** never need the employee's age, these entities could have the following structure:</span></span>

![][8]

* <span data-ttu-id="1425b-478">Normalmente es mejor almacenar los datos duplicados y asegurarse de que puede recuperar todos los datos que necesita con una sola consulta que usar una consulta para buscar una entidad y otra para buscar los datos necesarios.</span><span class="sxs-lookup"><span data-stu-id="1425b-478">It is typically better to store duplicate data and ensure that you can retrieve all the data you need with a single query, than to use one query to locate an entity and another to lookup the required data.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="1425b-479">Cuándo usar este patrón</span><span class="sxs-lookup"><span data-stu-id="1425b-479">When to use this pattern</span></span>
<span data-ttu-id="1425b-480">Utilice este patrón cuando la aplicación cliente necesite recuperar entidades mediante una serie de claves diferentes, cuando el cliente necesite recuperar entidades de diferentes criterios de ordenación y cuando pueda identificar cada entidad mediante una serie de valores únicos.</span><span class="sxs-lookup"><span data-stu-id="1425b-480">Use this pattern when your client application needs to retrieve entities using a variety of different keys, when your client needs to retrieve entities in different sort orders, and where you can identify each entity using a variety of unique values.</span></span> <span data-ttu-id="1425b-481">Sin embargo, debe asegurarse de no superar los límites de escalabilidad de partición al realizar búsquedas de entidad utilizando los diferentes valores **RowKey** .</span><span class="sxs-lookup"><span data-stu-id="1425b-481">However, you should be sure that you do not exceed the partition scalability limits when you are performing entity lookups using the different **RowKey** values.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="1425b-482">Orientación y patrones relacionados</span><span class="sxs-lookup"><span data-stu-id="1425b-482">Related patterns and guidance</span></span>
<span data-ttu-id="1425b-483">Los patrones y las directrices siguientes también pueden ser importantes a la hora de implementar este patrón:</span><span class="sxs-lookup"><span data-stu-id="1425b-483">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="1425b-484">Patrón de índice secundario entre particiones</span><span class="sxs-lookup"><span data-stu-id="1425b-484">Inter-partition secondary index pattern</span></span>](#inter-partition-secondary-index-pattern)
* [<span data-ttu-id="1425b-485">Patrón de clave compuesta</span><span class="sxs-lookup"><span data-stu-id="1425b-485">Compound key pattern</span></span>](#compound-key-pattern)
* [<span data-ttu-id="1425b-486">Transacciones de grupos de entidades</span><span class="sxs-lookup"><span data-stu-id="1425b-486">Entity Group Transactions</span></span>](#entity-group-transactions)
* [<span data-ttu-id="1425b-487">Trabajar con tipos de entidad heterogéneos</span><span class="sxs-lookup"><span data-stu-id="1425b-487">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)

### <a name="inter-partition-secondary-index-pattern"></a><span data-ttu-id="1425b-488">Patrón de índice secundario entre particiones</span><span class="sxs-lookup"><span data-stu-id="1425b-488">Inter-partition secondary index pattern</span></span>
<span data-ttu-id="1425b-489">Almacene varias copias de cada entidad con distintos valores de **RowKey** diferentes en particiones independientes o en tablas independientes para habilitar la realización de búsquedas rápidas y eficaces y órdenes alternativos utilizando valores **RowKey** diferentes.</span><span class="sxs-lookup"><span data-stu-id="1425b-489">Store multiple copies of each entity using different **RowKey** values in separate partitions or in separate tables to enable fast and efficient lookups and alternate sort orders by using different **RowKey** values.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="1425b-490">Contexto y problema</span><span class="sxs-lookup"><span data-stu-id="1425b-490">Context and problem</span></span>
<span data-ttu-id="1425b-491">Table Service indexa automáticamente entidades mediante los valores **PartitionKey** y **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="1425b-491">The Table service automatically indexes entities using the **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="1425b-492">Esto permite que una aplicación cliente recupere una entidad eficazmente con estos valores.</span><span class="sxs-lookup"><span data-stu-id="1425b-492">This enables a client application to retrieve an entity efficiently using these values.</span></span> <span data-ttu-id="1425b-493">Por ejemplo, si se usa la estructura de tabla que se muestra a continuación, una aplicación cliente puede utilizar una consulta puntual para recuperar una entidad de empleado individual mediante el uso del nombre del departamento y el identificador de empleado (los valores **PartitionKey** y **RowKey**).</span><span class="sxs-lookup"><span data-stu-id="1425b-493">For example, using the table structure shown below, a client application can use a point query to retrieve an individual employee entity by using the department name and the employee id (the **PartitionKey** and **RowKey** values).</span></span> <span data-ttu-id="1425b-494">Un cliente también puede recuperar las entidades ordenadas por identificador de empleado dentro de cada departamento.</span><span class="sxs-lookup"><span data-stu-id="1425b-494">A client can also retrieve entities sorted by employee id within each department.</span></span>  

![][9]

<span data-ttu-id="1425b-495">Si desea ser capaz de encontrar una entidad de empleado basada en el valor de otra propiedad, como la dirección de correo electrónico, debe usar un examen de la partición menos eficiente para encontrar a coincidencia.</span><span class="sxs-lookup"><span data-stu-id="1425b-495">If you also want to be able to find an employee entity based on the value of another property, such as email address, you must use a less efficient partition scan to find a match.</span></span> <span data-ttu-id="1425b-496">Esto se debe a que Table service no proporciona índices secundarios.</span><span class="sxs-lookup"><span data-stu-id="1425b-496">This is because the table service does not provide secondary indexes.</span></span> <span data-ttu-id="1425b-497">Además, no hay ninguna opción para solicitar una lista de empleados ordenados en un orden diferente a **RowKey** .</span><span class="sxs-lookup"><span data-stu-id="1425b-497">In addition, there is no option to request a list of employees sorted in a different order than **RowKey** order.</span></span>  

<span data-ttu-id="1425b-498">Prevé un gran volumen de transacciones en estas entidades y desea minimizar el riesgo de que Table service limite a su cliente.</span><span class="sxs-lookup"><span data-stu-id="1425b-498">You are anticipating a very high volume of transactions against these entities and want to minimize the risk of the Table service throttling your client.</span></span>  

#### <a name="solution"></a><span data-ttu-id="1425b-499">Solución</span><span class="sxs-lookup"><span data-stu-id="1425b-499">Solution</span></span>
<span data-ttu-id="1425b-500">Para evitar la falta de índices secundarios, puede almacenar varias copias de cada entidad con cada copia con valores **PartitionKey** y **RowKey** diferentes.</span><span class="sxs-lookup"><span data-stu-id="1425b-500">To work around the lack of secondary indexes, you can store multiple copies of each entity with each copy using different **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="1425b-501">Si almacena una entidad con las estructuras que se muestran a continuación, puede recuperar eficazmente las entidades de empleado en función de un identificador de empleado o de dirección de correo electrónico.</span><span class="sxs-lookup"><span data-stu-id="1425b-501">If you store an entity with the structures shown below, you can efficiently retrieve employee entities based on email address or employee id.</span></span> <span data-ttu-id="1425b-502">Los valores de prefijo de **PartitionKey**, "empid" y "email" le permiten identificar qué índice desea utilizar para una consulta.</span><span class="sxs-lookup"><span data-stu-id="1425b-502">The prefix values for the **PartitionKey**, "empid_" and "email_" enable you to identify which index you want to use for a query.</span></span>  

![][10]

<span data-ttu-id="1425b-503">Los dos criterios de filtro siguientes (uno de búsqueda por identificador de empleado y uno de búsqueda por dirección de correo electrónico) especifican consultas de punto:</span><span class="sxs-lookup"><span data-stu-id="1425b-503">The following two filter criteria (one looking up by employee id and one looking up by email address) both specify point queries:</span></span>  

* <span data-ttu-id="1425b-504">$filter=(PartitionKey eq 'empid_Sales') y (RowKey eq '000223')</span><span class="sxs-lookup"><span data-stu-id="1425b-504">$filter=(PartitionKey eq 'empid_Sales') and (RowKey eq '000223')</span></span>
* <span data-ttu-id="1425b-505">$filter=(PartitionKey eq 'email_Sales') y (RowKey eq 'jonesj@contoso.com')</span><span class="sxs-lookup"><span data-stu-id="1425b-505">$filter=(PartitionKey eq 'email_Sales') and (RowKey eq 'jonesj@contoso.com')</span></span>  

<span data-ttu-id="1425b-506">Si consulta un intervalo de entidades de empleado, puede especificar un intervalo ordenado por identificador de empleado o un intervalo ordenado por dirección de correo electrónico mediante la consulta de entidades con el prefijo adecuado en **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="1425b-506">If you query for a range of employee entities, you can specify a range sorted in employee id order, or a range sorted in email address order by querying for entities with the appropriate prefix in the **RowKey**.</span></span>  

* <span data-ttu-id="1425b-507">Para buscar todos los empleados del departamento de ventas con un identificador de empleado en el rango de **000100** a **000199** ordenados en orden de identificador de empleado, use: $filter=(PartitionKey eq 'empid_Sales') y (RowKey ge '000100') y (RowKey le '000199')</span><span class="sxs-lookup"><span data-stu-id="1425b-507">To find all the employees in the Sales department with an employee id in the range **000100** to **000199** sorted in employee id order use: $filter=(PartitionKey eq 'empid_Sales') and (RowKey ge '000100') and (RowKey le '000199')</span></span>  
* <span data-ttu-id="1425b-508">Para buscar todos los empleados del departamento de ventas con una dirección de correo electrónico que empiece por 'a' ordenados en el orden de dirección de correo electrónico, use: $filter=(PartitionKey eq 'email_Sales') y (RowKey ge 'a') y (RowKey lt 'b')</span><span class="sxs-lookup"><span data-stu-id="1425b-508">To find all the employees in the Sales department with an email address that starts with 'a' sorted in email address order use: $filter=(PartitionKey eq 'email_Sales') and (RowKey ge 'a') and (RowKey lt 'b')</span></span>  

<span data-ttu-id="1425b-509">Tenga en cuenta que la sintaxis de filtro usada en los ejemplos anteriores corresponde a la API de REST de Table Service. Para más información, consulte [Entidades de consulta](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span><span class="sxs-lookup"><span data-stu-id="1425b-509">Note that the filter syntax used in the examples above is from the Table service REST API, for more information see [Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx).</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="1425b-510">Problemas y consideraciones</span><span class="sxs-lookup"><span data-stu-id="1425b-510">Issues and considerations</span></span>
<span data-ttu-id="1425b-511">Tenga en cuenta los puntos siguientes al decidir cómo implementar este patrón:</span><span class="sxs-lookup"><span data-stu-id="1425b-511">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="1425b-512">Puede mantener las entidades duplicadas coherentes entre sí en última instancia con el [patrón de transacciones coherentes en última instancia](#eventually-consistent-transactions-pattern) para conservar las entidades de índice principal y secundaria.</span><span class="sxs-lookup"><span data-stu-id="1425b-512">You can keep your duplicate entities eventually consistent with each other by using the [Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) to maintain the primary and secondary index entities.</span></span>  
* <span data-ttu-id="1425b-513">El almacenamiento en tablas es relativamente barato, por lo que la sobrecarga de costes de almacenamiento de datos duplicados no debe ser una preocupación importante.</span><span class="sxs-lookup"><span data-stu-id="1425b-513">Table storage is relatively cheap to use so the cost overhead of storing duplicate data should not be a major concern.</span></span> <span data-ttu-id="1425b-514">Sin embargo, debe evaluar siempre el coste del diseño según los requisitos de almacenamiento previstos y solo agregar entidades duplicadas para admitir las consultas que ejecutará la aplicación cliente.</span><span class="sxs-lookup"><span data-stu-id="1425b-514">However, you should always evaluate the cost of your design based on your anticipated storage requirements and only add duplicate entities to support the queries your client application will execute.</span></span>  
* <span data-ttu-id="1425b-515">El valor que se usa **RowKey** debe ser único para cada entidad.</span><span class="sxs-lookup"><span data-stu-id="1425b-515">The value used for the **RowKey** must be unique for each entity.</span></span> <span data-ttu-id="1425b-516">Considere la posibilidad de usar valores de clave compuestos.</span><span class="sxs-lookup"><span data-stu-id="1425b-516">Consider using compound key values.</span></span>  
* <span data-ttu-id="1425b-517">Rellenar valores numéricos en **RowKey** (por ejemplo, el identificador de empleado 000223) permite corregir los criterios de ordenación y filtro en función de los límites inferior y superior.</span><span class="sxs-lookup"><span data-stu-id="1425b-517">Padding numeric values in the **RowKey** (for example, the employee id 000223), enables correct sorting and filtering based on upper and lower bounds.</span></span>  
* <span data-ttu-id="1425b-518">No es necesario duplicar todas las propiedades de su entidad.</span><span class="sxs-lookup"><span data-stu-id="1425b-518">You do not necessarily need to duplicate all the properties of your entity.</span></span> <span data-ttu-id="1425b-519">Por ejemplo, si las consultas que realizan búsquedas en las entidades mediante la dirección de correo electrónico de **RowKey** nunca necesitan la edad del empleado, dichas entidades podrían tener la siguiente estructura:</span><span class="sxs-lookup"><span data-stu-id="1425b-519">For example, if the queries that lookup the entities using the email address in the **RowKey** never need the employee's age, these entities could have the following structure:</span></span>
  
  ![][11]
* <span data-ttu-id="1425b-520">Normalmente es mejor almacenar los datos duplicados y asegurarse de que puede recuperar todos los datos que necesita con una sola consulta que usar una consulta para buscar una entidad mediante el índice secundario y otra para buscar los datos necesarios en el índice principal.</span><span class="sxs-lookup"><span data-stu-id="1425b-520">It is typically better to store duplicate data and ensure that you can retrieve all the data you need with a single query than to use one query to locate an entity using the secondary index and another to lookup the required data in the primary index.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="1425b-521">Cuándo usar este patrón</span><span class="sxs-lookup"><span data-stu-id="1425b-521">When to use this pattern</span></span>
<span data-ttu-id="1425b-522">Utilice este patrón cuando la aplicación cliente necesite recuperar entidades mediante una serie de claves diferentes, cuando el cliente necesite recuperar entidades de diferentes criterios de ordenación y cuando pueda identificar cada entidad mediante una serie de valores únicos.</span><span class="sxs-lookup"><span data-stu-id="1425b-522">Use this pattern when your client application needs to retrieve entities using a variety of different keys, when your client needs to retrieve entities in different sort orders, and where you can identify each entity using a variety of unique values.</span></span> <span data-ttu-id="1425b-523">Utilice este patrón cuando desee no exceder los límites de escalabilidad de la partición al realizar búsquedas de entidades que usen los diferentes valores **RowKey** .</span><span class="sxs-lookup"><span data-stu-id="1425b-523">Use this pattern when you want to avoid exceeding the partition scalability limits when you are performing entity lookups using the different **RowKey** values.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="1425b-524">Orientación y patrones relacionados</span><span class="sxs-lookup"><span data-stu-id="1425b-524">Related patterns and guidance</span></span>
<span data-ttu-id="1425b-525">Los patrones y las directrices siguientes también pueden ser importantes a la hora de implementar este patrón:</span><span class="sxs-lookup"><span data-stu-id="1425b-525">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="1425b-526">Patrón final coherente de transacciones</span><span class="sxs-lookup"><span data-stu-id="1425b-526">Eventually consistent transactions pattern</span></span>](#eventually-consistent-transactions-pattern)  
* [<span data-ttu-id="1425b-527">Patrón de índice secundario dentro de la partición</span><span class="sxs-lookup"><span data-stu-id="1425b-527">Intra-partition secondary index pattern</span></span>](#intra-partition-secondary-index-pattern)  
* [<span data-ttu-id="1425b-528">Patrón de clave compuesta</span><span class="sxs-lookup"><span data-stu-id="1425b-528">Compound key pattern</span></span>](#compound-key-pattern)  
* [<span data-ttu-id="1425b-529">Transacciones de grupos de entidades</span><span class="sxs-lookup"><span data-stu-id="1425b-529">Entity Group Transactions</span></span>](#entity-group-transactions)  
* [<span data-ttu-id="1425b-530">Trabajar con tipos de entidad heterogéneos</span><span class="sxs-lookup"><span data-stu-id="1425b-530">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)  

### <a name="eventually-consistent-transactions-pattern"></a><span data-ttu-id="1425b-531">Patrón final coherente de transacciones</span><span class="sxs-lookup"><span data-stu-id="1425b-531">Eventually consistent transactions pattern</span></span>
<span data-ttu-id="1425b-532">Habilitar el comportamiento final coherente a través de límites de partición o los límites del sistema de almacenamiento mediante el uso de las colas de Azure.</span><span class="sxs-lookup"><span data-stu-id="1425b-532">Enable eventually consistent behavior across partition boundaries or storage system boundaries by using Azure queues.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="1425b-533">Contexto y problema</span><span class="sxs-lookup"><span data-stu-id="1425b-533">Context and problem</span></span>
<span data-ttu-id="1425b-534">Los EGT permiten transacciones atómicas a través de varias entidades que comparten la misma clave de partición.</span><span class="sxs-lookup"><span data-stu-id="1425b-534">EGTs enable atomic transactions across multiple entities that share the same partition key.</span></span> <span data-ttu-id="1425b-535">Por motivos de escalabilidad y rendimiento, puede decidir almacenar entidades con requisitos de coherencia en particiones independientes o en un sistema de almacenamiento independiente: en este escenario, no puede utilizar EGT para mantener la coherencia.</span><span class="sxs-lookup"><span data-stu-id="1425b-535">For performance and scalability reasons, you might decide to store entities that have consistency requirements in separate partitions or in a separate storage system: in such a scenario, you cannot use EGTs to maintain consistency.</span></span> <span data-ttu-id="1425b-536">Por ejemplo, podría tener un requisito de mantener la coherencia eventual entre:</span><span class="sxs-lookup"><span data-stu-id="1425b-536">For example, you might have a requirement to maintain eventual consistency between:</span></span>  

* <span data-ttu-id="1425b-537">Entidades almacenadas en dos particiones diferentes de la misma tabla, en tablas diferentes y en diferentes cuentas de almacenamiento.</span><span class="sxs-lookup"><span data-stu-id="1425b-537">Entities stored in two different partitions in the same table, in different tables, in in different storage accounts.</span></span>  
* <span data-ttu-id="1425b-538">Una entidad almacenada en Table service y un blob almacenado en Blob service.</span><span class="sxs-lookup"><span data-stu-id="1425b-538">An entity stored in the Table service and a blob stored in the Blob service.</span></span>  
* <span data-ttu-id="1425b-539">Una entidad almacenada en Table service y un archivo en un sistema de archivos.</span><span class="sxs-lookup"><span data-stu-id="1425b-539">An entity stored in the Table service and a file in a file system.</span></span>  
* <span data-ttu-id="1425b-540">Un almacén de entidad en Table service ya indexado utilizando el servicio Azure Search.</span><span class="sxs-lookup"><span data-stu-id="1425b-540">An entity store in the Table service yet indexed using the Azure Search service.</span></span>  

#### <a name="solution"></a><span data-ttu-id="1425b-541">Solución</span><span class="sxs-lookup"><span data-stu-id="1425b-541">Solution</span></span>
<span data-ttu-id="1425b-542">Mediante el uso de las colas de Azure, puede implementar una solución que ofrece coherencia final entre dos o más particiones o sistemas de almacenamiento.</span><span class="sxs-lookup"><span data-stu-id="1425b-542">By using Azure queues, you can implement a solution that delivers eventual consistency across two or more partitions or storage systems.</span></span>
<span data-ttu-id="1425b-543">Para ilustrar este enfoque, suponga que tiene un requisito para poder almacenar entidades de empleado antiguas.</span><span class="sxs-lookup"><span data-stu-id="1425b-543">To illustrate this approach, assume you have a requirement to be able to archive old employee entities.</span></span> <span data-ttu-id="1425b-544">Las entidades de empleado antiguas rara vez se consultan y deben excluirse de las actividades relacionadas con los empleados actuales.</span><span class="sxs-lookup"><span data-stu-id="1425b-544">Old employee entities are rarely queried and should be excluded from any activities that deal with current employees.</span></span> <span data-ttu-id="1425b-545">Para implementar este requisito, almacene empleados activos en la tabla **Current** y empleados antiguos en la tabla **Archive**.</span><span class="sxs-lookup"><span data-stu-id="1425b-545">To implement this requirement you store active employees in the **Current** table and old employees in the **Archive** table.</span></span> <span data-ttu-id="1425b-546">Para archivar un empleado, es preciso eliminar la entidad de la tabla **Current** y agregarla a la tabla **Archive**, pero no se puede usar una EGT para realizar estas dos operaciones.</span><span class="sxs-lookup"><span data-stu-id="1425b-546">Archiving an employee requires you to delete the entity from the **Current** table and add the entity to the **Archive** table, but you cannot use an EGT to perform these two operations.</span></span> <span data-ttu-id="1425b-547">Para evitar el riesgo de que un error provoque la aparición de una entidad en las dos tablas o en ninguna, la operación de almacenamiento debe ser coherente con el tiempo.</span><span class="sxs-lookup"><span data-stu-id="1425b-547">To avoid the risk that a failure causes an entity to appear in both or neither tables, the archive operation must be eventually consistent.</span></span> <span data-ttu-id="1425b-548">En el diagrama de secuencia siguiente se describen los pasos de esta operación.</span><span class="sxs-lookup"><span data-stu-id="1425b-548">The following sequence diagram outlines the steps in this operation.</span></span> <span data-ttu-id="1425b-549">En el texto siguiente se proporcionan más detalles para las rutas de excepción.</span><span class="sxs-lookup"><span data-stu-id="1425b-549">More detail is provided for exception paths in the text following.</span></span>  

![][12]

<span data-ttu-id="1425b-550">Un cliente inicia la operación de almacenamiento mediante la colocación de un mensaje en una cola de Azure, en este ejemplo para archivar el empleado #456.</span><span class="sxs-lookup"><span data-stu-id="1425b-550">A client initiates the archive operation by placing a message on an Azure queue, in this example to archive employee #456.</span></span> <span data-ttu-id="1425b-551">Un rol de trabajador sondea la cola de mensajes nuevos; si encuentra alguno, lee el mensaje y deja una copia oculta en la cola.</span><span class="sxs-lookup"><span data-stu-id="1425b-551">A worker role polls the queue for new messages; when it finds one, it reads the message and leaves a hidden copy on the queue.</span></span> <span data-ttu-id="1425b-552">A continuación, el rol de trabajo busca una copia de la entidad en la tabla **Current**, inserta una copia en la tabla **Archive** y, seguidamente, elimina la original de la tabla **Current**.</span><span class="sxs-lookup"><span data-stu-id="1425b-552">The worker role next fetches a copy of the entity from the **Current** table, inserts a copy in the **Archive** table, and then deletes the original from the **Current** table.</span></span> <span data-ttu-id="1425b-553">Por último, si no ha habido errores en los pasos anteriores, el rol de trabajador elimina el mensaje oculto de la cola.</span><span class="sxs-lookup"><span data-stu-id="1425b-553">Finally, if there were no errors from the previous steps, the worker role deletes the hidden message from the queue.</span></span>  

<span data-ttu-id="1425b-554">En este ejemplo, el paso 4 inserta el empleado en la tabla **Archivo** .</span><span class="sxs-lookup"><span data-stu-id="1425b-554">In this example, step 4 inserts the employee into the **Archive** table.</span></span> <span data-ttu-id="1425b-555">Puede añadir al empleado a un blob en Blob service o un archivo en un sistema de archivos.</span><span class="sxs-lookup"><span data-stu-id="1425b-555">It could add the employee to a blob in the Blob service or a file in a file system.</span></span>  

#### <a name="recovering-from-failures"></a><span data-ttu-id="1425b-556">Recuperación de errores</span><span class="sxs-lookup"><span data-stu-id="1425b-556">Recovering from failures</span></span>
<span data-ttu-id="1425b-557">Es importante que las operaciones de los pasos **4** y **5** sean *idempotentes*, por si el rol de trabajo necesita reiniciar la operación de archivo.</span><span class="sxs-lookup"><span data-stu-id="1425b-557">It is important that the operations in steps **4** and **5** must be *idempotent* in case the worker role needs to restart the archive operation.</span></span> <span data-ttu-id="1425b-558">Si va a utilizar Table Service para el paso **4**, debe utilizar una operación de "insertar o reemplazar"; en el paso **5** debe usar una operación de "eliminar si existe" en la biblioteca de cliente que vaya a usar.</span><span class="sxs-lookup"><span data-stu-id="1425b-558">If you are using the Table service, for step **4** you should use an "insert or replace" operation; for step **5** you should use a "delete if exists" operation in the client library you are using.</span></span> <span data-ttu-id="1425b-559">Si está utilizando otro sistema de almacenamiento, debe utilizar una operación idempotente adecuada.</span><span class="sxs-lookup"><span data-stu-id="1425b-559">If you are using another storage system, you must use an appropriate idempotent operation.</span></span>  

<span data-ttu-id="1425b-560">Si el rol de trabajo no completa el paso **6**, después de un tiempo de expiración el mensaje volverá a aparecer en la cola listo para que el rol de trabajo intente volver a procesarlo.</span><span class="sxs-lookup"><span data-stu-id="1425b-560">If the worker role never completes step **6**, then after a timeout the message reappears on the queue ready for the worker role to try to reprocess it.</span></span> <span data-ttu-id="1425b-561">El rol de trabajador puede comprobar cuántas veces se ha leído un mensaje de la cola y, si es necesario, marcarlo como mensaje "dudoso" para investigarlo mediante el envío a una cola independiente.</span><span class="sxs-lookup"><span data-stu-id="1425b-561">The worker role can check how many times a message on the queue has been read and, if necessary, flag it is a "poison" message for investigation by sending it to a separate queue.</span></span> <span data-ttu-id="1425b-562">Para obtener más información acerca de cómo leer mensajes de la cola y comprobar el número de eliminaciones de cola, consulte [Obtener mensajes](https://msdn.microsoft.com/library/azure/dd179474.aspx).</span><span class="sxs-lookup"><span data-stu-id="1425b-562">For more information about reading queue messages and checking the dequeue count, see [Get Messages](https://msdn.microsoft.com/library/azure/dd179474.aspx).</span></span>  

<span data-ttu-id="1425b-563">Algunos errores de Table service y Queue service son errores transitorios y la aplicación cliente debe incluir una lógica de reintento adecuada para controlarlos.</span><span class="sxs-lookup"><span data-stu-id="1425b-563">Some errors from the Table and Queue services are transient errors, and your client application should include suitable retry logic to handle them.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="1425b-564">Problemas y consideraciones</span><span class="sxs-lookup"><span data-stu-id="1425b-564">Issues and considerations</span></span>
<span data-ttu-id="1425b-565">Tenga en cuenta los puntos siguientes al decidir cómo implementar este patrón:</span><span class="sxs-lookup"><span data-stu-id="1425b-565">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="1425b-566">Esta solución no permite el aislamiento de las transacciones.</span><span class="sxs-lookup"><span data-stu-id="1425b-566">This solution does not provide for transaction isolation.</span></span> <span data-ttu-id="1425b-567">Por ejemplo, un cliente pudo leer las tablas **Current** y **Archive** cuando el rol de trabajo estaba entre los pasos **4** y **5**, y tener una vista incoherente de los datos.</span><span class="sxs-lookup"><span data-stu-id="1425b-567">For example, a client could read the **Current** and **Archive** tables when the worker role was between steps **4** and **5**, and see an inconsistent view of the data.</span></span> <span data-ttu-id="1425b-568">Tenga en cuenta que los datos serán coherentes con el tiempo.</span><span class="sxs-lookup"><span data-stu-id="1425b-568">Note that the data will be consistent eventually.</span></span>  
* <span data-ttu-id="1425b-569">Debe asegurarse de que los pasos 4 y 5 sean idempotentes para garantizar la coherencia.</span><span class="sxs-lookup"><span data-stu-id="1425b-569">You must be sure that steps 4 and 5 are idempotent in order to ensure eventual consistency.</span></span>  
* <span data-ttu-id="1425b-570">Puede escalar la solución mediante el uso de varias colas e instancias de rol de trabajador.</span><span class="sxs-lookup"><span data-stu-id="1425b-570">You can scale the solution by using multiple queues and worker role instances.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="1425b-571">Cuándo usar este patrón</span><span class="sxs-lookup"><span data-stu-id="1425b-571">When to use this pattern</span></span>
<span data-ttu-id="1425b-572">Utilice este patrón cuando desee garantizar la coherencia eventual entre las entidades que existen en diferentes particiones o tablas.</span><span class="sxs-lookup"><span data-stu-id="1425b-572">Use this pattern when you want to guarantee eventual consistency between entities that exist in different partitions or tables.</span></span> <span data-ttu-id="1425b-573">Puede extender este patrón para garantizar la coherencia eventual de las operaciones en Table service y Blob service, y otros orígenes de datos de almacenamiento que no sean de Azure, tales como bases de datos o el sistema de archivos.</span><span class="sxs-lookup"><span data-stu-id="1425b-573">You can extend this pattern to ensure eventual consistency for operations across the Table service and the Blob service and other non-Azure Storage data sources such as database or the file system.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="1425b-574">Orientación y patrones relacionados</span><span class="sxs-lookup"><span data-stu-id="1425b-574">Related patterns and guidance</span></span>
<span data-ttu-id="1425b-575">Los patrones y las directrices siguientes también pueden ser importantes a la hora de implementar este patrón:</span><span class="sxs-lookup"><span data-stu-id="1425b-575">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="1425b-576">Transacciones de grupos de entidades</span><span class="sxs-lookup"><span data-stu-id="1425b-576">Entity Group Transactions</span></span>](#entity-group-transactions)  
* [<span data-ttu-id="1425b-577">Combinar o reemplazar</span><span class="sxs-lookup"><span data-stu-id="1425b-577">Merge or replace</span></span>](#merge-or-replace)  

> [!NOTE]
> <span data-ttu-id="1425b-578">Si el aislamiento de transacciones es importante para su solución, considere la posibilidad de volver a diseñar las tablas para poder utilizar EGT.</span><span class="sxs-lookup"><span data-stu-id="1425b-578">If transaction isolation is important to your solution, you should consider redesigning your tables to enable you to use EGTs.</span></span>  
> 
> 

### <a name="index-entities-pattern"></a><span data-ttu-id="1425b-579">Patrón de entidades de índice</span><span class="sxs-lookup"><span data-stu-id="1425b-579">Index Entities Pattern</span></span>
<span data-ttu-id="1425b-580">Mantenga entidades de índice para poder efectuar búsquedas eficaces que devuelvan listas de entidades.</span><span class="sxs-lookup"><span data-stu-id="1425b-580">Maintain index entities to enable efficient searches that return lists of entities.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="1425b-581">Contexto y problema</span><span class="sxs-lookup"><span data-stu-id="1425b-581">Context and problem</span></span>
<span data-ttu-id="1425b-582">Table Service indexa automáticamente entidades mediante los valores **PartitionKey** y **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="1425b-582">The Table service automatically indexes entities using the **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="1425b-583">Esto permite que una aplicación cliente recupere una entidad eficazmente mediante una consulta de punto.</span><span class="sxs-lookup"><span data-stu-id="1425b-583">This enables a client application to retrieve an entity efficiently using a point query.</span></span> <span data-ttu-id="1425b-584">Por ejemplo, si se usa la estructura de tabla que se muestra a continuación, una aplicación cliente puede recuperar de manera eficiente una entidad de empleado individual mediante el uso del nombre del departamento y el identificador de empleado (los valores **PartitionKey** y **RowKey**).</span><span class="sxs-lookup"><span data-stu-id="1425b-584">For example, using the table structure shown below, a client application can efficiently retrieve an individual employee entity by using the department name and the employee id (the **PartitionKey** and **RowKey**).</span></span>  

![][13]

<span data-ttu-id="1425b-585">Si también desea poder recuperar una lista de las entidades employee en función del valor de otra propiedad no exclusiva, por ejemplo, su apellido, debe utilizar un examen de partición menos eficaz para buscar coincidencias en lugar de utilizar un índice para buscarlas directamente.</span><span class="sxs-lookup"><span data-stu-id="1425b-585">If you also want to be able to retrieve a list of employee entities based on the value of another non-unique property, such as their last name, you must use a less efficient partition scan to find matches rather than using an index to look them up directly.</span></span> <span data-ttu-id="1425b-586">Esto se debe a que Table service no proporciona índices secundarios.</span><span class="sxs-lookup"><span data-stu-id="1425b-586">This is because the table service does not provide secondary indexes.</span></span>  

#### <a name="solution"></a><span data-ttu-id="1425b-587">Solución</span><span class="sxs-lookup"><span data-stu-id="1425b-587">Solution</span></span>
<span data-ttu-id="1425b-588">Para habilitar la búsqueda por apellido con la estructura de entidad mostrada anteriormente, debe mantener listas de identificadores de empleado.</span><span class="sxs-lookup"><span data-stu-id="1425b-588">To enable lookup by last name with the entity structure shown above, you must maintain lists of employee ids.</span></span> <span data-ttu-id="1425b-589">Si desea recuperar las entidades employee con un apellido determinado, como Jones, debe encontrar primero la lista de identificadores de empleado para los empleados con Jones como su apellido y, a continuación, recuperar las entidades employee.</span><span class="sxs-lookup"><span data-stu-id="1425b-589">If you want to retrieve the employee entities with a particular last name, such as Jones, you must first locate the list of employee ids for employees with Jones as their last name, and then retrieve those employee entities.</span></span> <span data-ttu-id="1425b-590">Hay tres opciones principales para almacenar las listas de identificadores de empleado:</span><span class="sxs-lookup"><span data-stu-id="1425b-590">There are three main options for storing the lists of employee ids:</span></span>  

* <span data-ttu-id="1425b-591">Utilice Blob Storage.</span><span class="sxs-lookup"><span data-stu-id="1425b-591">Use blob storage.</span></span>  
* <span data-ttu-id="1425b-592">Cree entidades de índice en la misma partición que las entidades employee.</span><span class="sxs-lookup"><span data-stu-id="1425b-592">Create index entities in the same partition as the employee entities.</span></span>  
* <span data-ttu-id="1425b-593">Cree entidades de índice en una tabla o una partición independiente.</span><span class="sxs-lookup"><span data-stu-id="1425b-593">Create index entities in a separate partition or table.</span></span>  

<span data-ttu-id="1425b-594"><u>Opción n.º 1: Usar Blob Storage</u></span><span class="sxs-lookup"><span data-stu-id="1425b-594"><u>Option #1: Use blob storage</u></span></span>  

<span data-ttu-id="1425b-595">Para la primera opción, cree un blob para cada apellido único y, en cada almacén de blobs, una lista de valores **PartitionKey** (departamento) y **RowKey** (identificador de empleado) para los empleados que tienen ese apellido.</span><span class="sxs-lookup"><span data-stu-id="1425b-595">For the first option, you create a blob for every unique last name, and in each blob store a list of the **PartitionKey** (department) and **RowKey** (employee id) values for employees that have that last name.</span></span> <span data-ttu-id="1425b-596">Al agregar o eliminar a un empleado debe asegurarse de que el contenido del blob relevante es coherente con las entidades employee.</span><span class="sxs-lookup"><span data-stu-id="1425b-596">When you add or delete an employee you should ensure that the content of the relevant blob is eventually consistent with the employee entities.</span></span>  

<span data-ttu-id="1425b-597"><u>Opción n.º 2:</u> crear entidades de índice en la misma partición</span><span class="sxs-lookup"><span data-stu-id="1425b-597"><u>Option #2:</u> Create index entities in the same partition</span></span>  

<span data-ttu-id="1425b-598">Para la segunda opción, utilice las entidades de índice que almacenan los datos siguientes:</span><span class="sxs-lookup"><span data-stu-id="1425b-598">For the second option, use index entities that store the following data:</span></span>  

![][14]

<span data-ttu-id="1425b-599">La propiedad **EmployeeIDs** contiene una lista de identificadores de empleado para los empleados cuyo apellido está almacenado en **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="1425b-599">The **EmployeeIDs** property contains a list of employee ids for employees with the last name stored in the **RowKey**.</span></span>  

<span data-ttu-id="1425b-600">Los siguientes pasos describen el proceso que debe seguir al agregar un nuevo empleado si utiliza la segunda opción.</span><span class="sxs-lookup"><span data-stu-id="1425b-600">The following steps outline the process you should follow when you are adding a new employee if you are using the second option.</span></span> <span data-ttu-id="1425b-601">En este ejemplo, agregamos a un empleado con Id. 000152 y el apellido Jones en el departamento de ventas:</span><span class="sxs-lookup"><span data-stu-id="1425b-601">In this example, we are adding an employee with Id 000152 and a last name Jones in the Sales department:</span></span>  

1. <span data-ttu-id="1425b-602">Recupere la entidad de índice con el valor **PartitionKey** "Sales" y el valor **RowKey** "Jones".</span><span class="sxs-lookup"><span data-stu-id="1425b-602">Retrieve the index entity with a **PartitionKey** value "Sales" and the **RowKey** value "Jones."</span></span> <span data-ttu-id="1425b-603">Guarde el valor ETag de esta entidad para usar en el paso 2.</span><span class="sxs-lookup"><span data-stu-id="1425b-603">Save the ETag of this entity to use in step 2.</span></span>  
2. <span data-ttu-id="1425b-604">Cree una transacción de grupo de entidad (es decir, una operación por lotes) que inserte la nueva entidad del empleado (valor **PartitionKey** "Sales" y valor **RowKey** "000152") y actualice la entidad de índice (valor **PartitionKey** "Sales" y valor **RowKey** "Jones") agregando el nuevo identificador de empleado a la lista del campo EmployeeIDs.</span><span class="sxs-lookup"><span data-stu-id="1425b-604">Create an entity group transaction (that is, a batch operation) that inserts the new employee entity (**PartitionKey** value "Sales" and **RowKey** value "000152"), and updates the index entity (**PartitionKey** value "Sales" and **RowKey** value "Jones") by adding the new employee id to the list in the EmployeeIDs field.</span></span> <span data-ttu-id="1425b-605">Para obtener información sobre EGT, consulte la sección [Transacciones de grupo de entidad (EGT)](#entity-group-transactions).</span><span class="sxs-lookup"><span data-stu-id="1425b-605">For more information about entity group transactions, see [Entity Group Transactions](#entity-group-transactions).</span></span>  
3. <span data-ttu-id="1425b-606">Si la transacción de grupo de entidad falla debido a un error de simultaneidad optimista (alguien ha modificado la entidad de índice), necesitará comenzar de nuevo en el paso 1.</span><span class="sxs-lookup"><span data-stu-id="1425b-606">If the entity group transaction fails because of an optimistic concurrency error (someone else has just modified the index entity), then you need to start over at step 1 again.</span></span>  

<span data-ttu-id="1425b-607">Puede usar un enfoque similar a la eliminación de un empleado si utiliza la segunda opción.</span><span class="sxs-lookup"><span data-stu-id="1425b-607">You can use a similar approach to deleting an employee if you are using the second option.</span></span> <span data-ttu-id="1425b-608">Cambiar el apellido de un empleado es ligeramente más complejo porque necesitará ejecutar una transacción de grupo de entidad que actualice tres entidades: la entidad employee, la entidad de índice para el apellido antiguo y la entidad de índice para el nombre nuevo.</span><span class="sxs-lookup"><span data-stu-id="1425b-608">Changing an employee's last name is slightly more complex because you will need to execute an entity group transaction that updates three entities: the employee entity, the index entity for the old last name, and the index entity for the new last name.</span></span> <span data-ttu-id="1425b-609">Debe recuperar cada entidad antes de realizar cambios para recuperar los valores de ETag que puede utilizar para realizar las actualizaciones mediante la simultaneidad optimista.</span><span class="sxs-lookup"><span data-stu-id="1425b-609">You must retrieve each entity before making any changes in order to retrieve the ETag values that you can then use to perform the updates using optimistic concurrency.</span></span>  

<span data-ttu-id="1425b-610">Los siguientes pasos describen el proceso que debe llevar a cabo cuando se necesita buscar todos los empleados con un apellido determinado en un departamento si utiliza la segunda opción.</span><span class="sxs-lookup"><span data-stu-id="1425b-610">The following steps outline the process you should follow when you need to look up all the employees with a given last name in a department if you are using the second option.</span></span> <span data-ttu-id="1425b-611">En este ejemplo se buscan todos los empleados con el apellido Jones en el departamento de ventas:</span><span class="sxs-lookup"><span data-stu-id="1425b-611">In this example, we are looking up all the employees with last name Jones in the Sales department:</span></span>  

1. <span data-ttu-id="1425b-612">Recupere la entidad de índice con el valor **PartitionKey** "Sales" y el valor **RowKey** "Jones".</span><span class="sxs-lookup"><span data-stu-id="1425b-612">Retrieve the index entity with a **PartitionKey** value "Sales" and the **RowKey** value "Jones."</span></span>  
2. <span data-ttu-id="1425b-613">Analice la lista de identificadores de empleado en el campo EmployeeIDs.</span><span class="sxs-lookup"><span data-stu-id="1425b-613">Parse the list of employee Ids in the EmployeeIDs field.</span></span>  
3. <span data-ttu-id="1425b-614">Si necesita información adicional sobre cada uno de los empleados (por ejemplo, sus direcciones de correo electrónico), recupere cada una de las entidades de empleado mediante los valores **PartitionKey** "Sales" y **RowKey** de la lista de empleados que obtuvo en el paso 2.</span><span class="sxs-lookup"><span data-stu-id="1425b-614">If you need additional information about each of these employees (such as their email addresses), retrieve each of the employee entities using **PartitionKey** value "Sales" and **RowKey** values from the list of employees you obtained in step 2.</span></span>  

<span data-ttu-id="1425b-615"><u>Opción n.º 3:</u> crear entidades de índice en una tabla o partición independientes</span><span class="sxs-lookup"><span data-stu-id="1425b-615"><u>Option #3:</u> Create index entities in a separate partition or table</span></span>  

<span data-ttu-id="1425b-616">Para la tercera opción, utilice las entidades de índice que almacenan los datos siguientes:</span><span class="sxs-lookup"><span data-stu-id="1425b-616">For the third option, use index entities that store the following data:</span></span>  

![][15]

<span data-ttu-id="1425b-617">La propiedad **EmployeeIDs** contiene una lista de identificadores de empleado para los empleados cuyo apellido está almacenado en **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="1425b-617">The **EmployeeIDs** property contains a list of employee ids for employees with the last name stored in the **RowKey**.</span></span>  

<span data-ttu-id="1425b-618">Con la tercera opción, no puede utilizar EGT para mantener la coherencia porque las entidades del índice están en una partición distinta que las entidades employee.</span><span class="sxs-lookup"><span data-stu-id="1425b-618">With the third option, you cannot use EGTs to maintain consistency because the index entities are in a separate partition from the employee entities.</span></span> <span data-ttu-id="1425b-619">Debe asegurarse de que las entidades de índice son coherentes eventualmente con las entidades employee.</span><span class="sxs-lookup"><span data-stu-id="1425b-619">You should ensure that the index entities are eventually consistent with the employee entities.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="1425b-620">Problemas y consideraciones</span><span class="sxs-lookup"><span data-stu-id="1425b-620">Issues and considerations</span></span>
<span data-ttu-id="1425b-621">Tenga en cuenta los puntos siguientes al decidir cómo implementar este patrón:</span><span class="sxs-lookup"><span data-stu-id="1425b-621">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="1425b-622">Esta solución requiere al menos dos consultas para recuperar las entidades coincidentes: una para consultar las entidades de índice con el fin de obtener la lista de valores **RowKey** y, luego, las consultas para recuperar cada entidad de la lista.</span><span class="sxs-lookup"><span data-stu-id="1425b-622">This solution requires at least two queries to retrieve matching entities: one to query the index entities to obtain the list of **RowKey** values, and then queries to retrieve each entity in the list.</span></span>  
* <span data-ttu-id="1425b-623">Dado que una entidad individual tiene un tamaño máximo de 1 MB, la opción nº2 y la opción nº3 de la solución dan por hecho que la lista de identificadores de empleado de cualquier apellido determinado nunca es mayor que 1 MB.</span><span class="sxs-lookup"><span data-stu-id="1425b-623">Given that an individual entity has a maximum size of 1 MB, option #2 and option #3 in the solution assume that the list of employee ids for any given last name is never greater than 1 MB.</span></span> <span data-ttu-id="1425b-624">Si la lista de identificadores de empleado es probable que sea mayor que 1 MB de tamaño, utilice la opción nº 1 y almacene los datos del índice en Blob Storage.</span><span class="sxs-lookup"><span data-stu-id="1425b-624">If the list of employee ids is likely to be greater than 1 MB in size, use option #1 and store the index data in blob storage.</span></span>  
* <span data-ttu-id="1425b-625">Si utiliza la opción 2 (el uso de EGT para controlar la adición y eliminación de empleados, y el cambio de los apellidos de un empleado), debe evaluar si el volumen de transacciones se aproximará a los límites de escalabilidad de una partición determinada.</span><span class="sxs-lookup"><span data-stu-id="1425b-625">If you use option #2 (using EGTs to handle adding and deleting employees, and changing an employee's last name) you must evaluate if the volume of transactions will approach the scalability limits in a given partition.</span></span> <span data-ttu-id="1425b-626">Si este es el caso, debe considerar una solución coherente (opción nº1 o nº3) que utilice colas para controlar las solicitudes de actualización y le permita almacenar entidades de índice en una partición independiente de las entidades employee.</span><span class="sxs-lookup"><span data-stu-id="1425b-626">If this is the case, you should consider an eventually consistent solution (option #1 or option #3) that uses queues to handle the update requests and enables you to store your index entities in a separate partition from the employee entities.</span></span>  
* <span data-ttu-id="1425b-627">La opción nº2 en esta solución da por hecho que desea buscar por apellido dentro de un departamento: por ejemplo, desea recuperar una lista de empleados que tienen un apellido Jones del departamento de ventas.</span><span class="sxs-lookup"><span data-stu-id="1425b-627">Option #2 in this solution assumes that you want to look up by last name within a department: for example, you want to retrieve a list of employees with a last name Jones in the Sales department.</span></span> <span data-ttu-id="1425b-628">Si desea buscar todos los empleados con apellido Jones en toda la organización, utilice opción nº1 o la opción nº3.</span><span class="sxs-lookup"><span data-stu-id="1425b-628">If you want to be able to look up all the employees with a last name Jones across the whole organization, use either option #1 or option #3.</span></span>
* <span data-ttu-id="1425b-629">Puede implementar una solución basada en cola que ofrezca coherencia eventual (consulte [Patrón final coherente de transacciones](#eventually-consistent-transactions-pattern) para más información).</span><span class="sxs-lookup"><span data-stu-id="1425b-629">You can implement a queue-based solution that delivers eventual consistency (see the [Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) for more details).</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="1425b-630">Cuándo usar este patrón</span><span class="sxs-lookup"><span data-stu-id="1425b-630">When to use this pattern</span></span>
<span data-ttu-id="1425b-631">Utilice este patrón cuando desee buscar un conjunto de entidades que compartan un valor de propiedad común, como todos los empleados con el apellido Jones.</span><span class="sxs-lookup"><span data-stu-id="1425b-631">Use this pattern when you want to lookup a set of entities that all share a common property value, such as all employees with the last name Jones.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="1425b-632">Orientación y patrones relacionados</span><span class="sxs-lookup"><span data-stu-id="1425b-632">Related patterns and guidance</span></span>
<span data-ttu-id="1425b-633">Los patrones y las directrices siguientes también pueden ser importantes a la hora de implementar este patrón:</span><span class="sxs-lookup"><span data-stu-id="1425b-633">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="1425b-634">Patrón de clave compuesta</span><span class="sxs-lookup"><span data-stu-id="1425b-634">Compound key pattern</span></span>](#compound-key-pattern)  
* [<span data-ttu-id="1425b-635">Patrón final coherente de transacciones</span><span class="sxs-lookup"><span data-stu-id="1425b-635">Eventually consistent transactions pattern</span></span>](#eventually-consistent-transactions-pattern)  
* [<span data-ttu-id="1425b-636">Transacciones de grupos de entidades</span><span class="sxs-lookup"><span data-stu-id="1425b-636">Entity Group Transactions</span></span>](#entity-group-transactions)  
* [<span data-ttu-id="1425b-637">Trabajar con tipos de entidad heterogéneos</span><span class="sxs-lookup"><span data-stu-id="1425b-637">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)  

### <a name="denormalization-pattern"></a><span data-ttu-id="1425b-638">Patrón de desnormalización</span><span class="sxs-lookup"><span data-stu-id="1425b-638">Denormalization pattern</span></span>
<span data-ttu-id="1425b-639">Combine datos relacionados entre sí en una sola entidad para recuperar todos los datos que necesita con una consulta de punto único.</span><span class="sxs-lookup"><span data-stu-id="1425b-639">Combine related data together in a single entity to enable you to retrieve all the data you need with a single point query.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="1425b-640">Contexto y problema</span><span class="sxs-lookup"><span data-stu-id="1425b-640">Context and problem</span></span>
<span data-ttu-id="1425b-641">En una base de datos relacional, normalmente normaliza datos para eliminar datos duplicados resultantes en las consultas que recuperan datos de varias tablas.</span><span class="sxs-lookup"><span data-stu-id="1425b-641">In a relational database, you typically normalize data to remove duplication resulting in queries that retrieve data from multiple tables.</span></span> <span data-ttu-id="1425b-642">Si normaliza los datos de tablas de Azure, debe realizar varias acciones de ida y vuelta desde el cliente al servidor para recuperar los datos relacionados.</span><span class="sxs-lookup"><span data-stu-id="1425b-642">If you normalize your data in Azure tables, you must make multiple round trips from the client to the server to retrieve your related data.</span></span> <span data-ttu-id="1425b-643">Por ejemplo, con la estructura de tabla que se muestra a continuación, se necesitan dos ciclos de ida y vuelta para recuperar los detalles de un departamento: uno para capturar la entidad del departamento que incluye el identificador del administrador y, después, otra solicitud para capturar los detalles del administrador de una entidad employee.</span><span class="sxs-lookup"><span data-stu-id="1425b-643">For example, with the table structure shown below you need two round trips to retrieve the details for a department: one to fetch the department entity that includes the manager's id, and then another request to fetch the manager's details in an employee entity.</span></span>  

![][16]

#### <a name="solution"></a><span data-ttu-id="1425b-644">Solución</span><span class="sxs-lookup"><span data-stu-id="1425b-644">Solution</span></span>
<span data-ttu-id="1425b-645">En lugar de almacenar los datos en dos entidades independientes, desnormalice los datos y conserve una copia de los detalles del administrador en la entidad department.</span><span class="sxs-lookup"><span data-stu-id="1425b-645">Instead of storing the data in two separate entities, denormalize the data and keep a copy of the manager's details in the department entity.</span></span> <span data-ttu-id="1425b-646">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="1425b-646">For example:</span></span>  

![][17]

<span data-ttu-id="1425b-647">Ahora con las entidades de departamento almacenadas con estas propiedades, puede recuperar todos los detalles que necesita acerca de un departamento mediante una consulta de punto.</span><span class="sxs-lookup"><span data-stu-id="1425b-647">With department entities stored with these properties, you can now retrieve all the details you need about a department using a point query.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="1425b-648">Problemas y consideraciones</span><span class="sxs-lookup"><span data-stu-id="1425b-648">Issues and considerations</span></span>
<span data-ttu-id="1425b-649">Tenga en cuenta los puntos siguientes al decidir cómo implementar este patrón:</span><span class="sxs-lookup"><span data-stu-id="1425b-649">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="1425b-650">Hay algunos costes de sobrecarga asociados al almacenamiento de datos dos veces.</span><span class="sxs-lookup"><span data-stu-id="1425b-650">There is some cost overhead associated with storing some data twice.</span></span> <span data-ttu-id="1425b-651">La ventaja de rendimiento (procedente de menos solicitudes al servicio de almacenamiento) normalmente es más importante que el aumento marginal en los costes de almacenamiento (y este coste se compensa parcialmente con una reducción en el número de transacciones que se requieren para capturar los detalles de un departamento).</span><span class="sxs-lookup"><span data-stu-id="1425b-651">The performance benefit (resulting from fewer requests to the storage service) typically outweighs the marginal increase in storage costs (and this cost is partially offset by a reduction in the number of transactions you require to fetch the details of a department).</span></span>  
* <span data-ttu-id="1425b-652">Debe mantener la coherencia de las dos entidades que almacenan información acerca de los administradores.</span><span class="sxs-lookup"><span data-stu-id="1425b-652">You must maintain the consistency of the two entities that store information about managers.</span></span> <span data-ttu-id="1425b-653">Puede controlar el problema de coherencia utilizando EGT para actualizar varias entidades en una única transacción atómica: en este caso, la entidad department y la entidad employee del administrador de departamento se almacenan en la misma partición.</span><span class="sxs-lookup"><span data-stu-id="1425b-653">You can handle the consistency issue by using EGTs to update multiple entities in a single atomic transaction: in this case, the department entity, and the employee entity for the department manager are stored in the same partition.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="1425b-654">Cuándo usar este patrón</span><span class="sxs-lookup"><span data-stu-id="1425b-654">When to use this pattern</span></span>
<span data-ttu-id="1425b-655">Utilice este patrón cuando necesite buscar información relacionada con frecuencia.</span><span class="sxs-lookup"><span data-stu-id="1425b-655">Use this pattern when you frequently need to look up related information.</span></span> <span data-ttu-id="1425b-656">Este patrón reduce el número de consultas que el cliente debe realizar para recuperar los datos que necesita.</span><span class="sxs-lookup"><span data-stu-id="1425b-656">This pattern reduces the number of queries your client must make to retrieve the data it requires.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="1425b-657">Orientación y patrones relacionados</span><span class="sxs-lookup"><span data-stu-id="1425b-657">Related patterns and guidance</span></span>
<span data-ttu-id="1425b-658">Los patrones y las directrices siguientes también pueden ser importantes a la hora de implementar este patrón:</span><span class="sxs-lookup"><span data-stu-id="1425b-658">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="1425b-659">Patrón de clave compuesta</span><span class="sxs-lookup"><span data-stu-id="1425b-659">Compound key pattern</span></span>](#compound-key-pattern)  
* [<span data-ttu-id="1425b-660">Transacciones de grupos de entidades</span><span class="sxs-lookup"><span data-stu-id="1425b-660">Entity Group Transactions</span></span>](#entity-group-transactions)  
* [<span data-ttu-id="1425b-661">Trabajar con tipos de entidad heterogéneos</span><span class="sxs-lookup"><span data-stu-id="1425b-661">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)

### <a name="compound-key-pattern"></a><span data-ttu-id="1425b-662">Patrón de clave compuesta</span><span class="sxs-lookup"><span data-stu-id="1425b-662">Compound key pattern</span></span>
<span data-ttu-id="1425b-663">Utilice valores **RowKey** compuestos para permitir a los clientes buscar datos relacionados con una consulta de punto único.</span><span class="sxs-lookup"><span data-stu-id="1425b-663">Use compound **RowKey** values to enable a client to lookup related data with a single point query.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="1425b-664">Contexto y problema</span><span class="sxs-lookup"><span data-stu-id="1425b-664">Context and problem</span></span>
<span data-ttu-id="1425b-665">En una base de datos relacional, resulta bastante natural usar combinaciones en las consultas para devolver datos relacionados al cliente en una sola consulta.</span><span class="sxs-lookup"><span data-stu-id="1425b-665">In a relational database, it is quite natural to use joins in queries to return related pieces of data to the client in a single query.</span></span> <span data-ttu-id="1425b-666">Por ejemplo, podría utilizar el identificador de empleado para buscar una lista de entidades relacionadas que contengan datos de rendimiento y revisión de ese empleado.</span><span class="sxs-lookup"><span data-stu-id="1425b-666">For example, you might use the employee id to look up a list of related entities that contain performance and review data for that employee.</span></span>  

<span data-ttu-id="1425b-667">Supongamos que está almacenando entidades employee en Table service utilizando la siguiente estructura:</span><span class="sxs-lookup"><span data-stu-id="1425b-667">Assume you are storing employee entities in the Table service using the following structure:</span></span>  

![][18]

<span data-ttu-id="1425b-668">También necesita almacenar datos históricos relacionados con las revisiones y el rendimiento de cada año que el empleado ha trabajado para su organización y necesitará tener acceso a esta información por año.</span><span class="sxs-lookup"><span data-stu-id="1425b-668">You also need to store historical data relating to reviews and performance for each year the employee has worked for your organization and you need to be able to access this information by year.</span></span> <span data-ttu-id="1425b-669">Una opción consiste en crear otra tabla que almacene las entidades con la estructura siguiente:</span><span class="sxs-lookup"><span data-stu-id="1425b-669">One option is to create another table that stores entities with the following structure:</span></span>  

![][19]

<span data-ttu-id="1425b-670">Observe que con este enfoque puede decidir duplicar parte de la información (por ejemplo, nombre y apellidos) en la nueva entidad, lo que le permite recuperar los datos con una única solicitud.</span><span class="sxs-lookup"><span data-stu-id="1425b-670">Notice that with this approach you may decide to duplicate some information (such as first name and last name) in the new entity to enable you to retrieve your data with a single request.</span></span> <span data-ttu-id="1425b-671">Sin embargo, no puede mantener la homogeneidad porque no puede utilizar un EGT para actualizar las dos entidades de forma atómica.</span><span class="sxs-lookup"><span data-stu-id="1425b-671">However, you cannot maintain strong consistency because you cannot use an EGT to update the two entities atomically.</span></span>  

#### <a name="solution"></a><span data-ttu-id="1425b-672">Solución</span><span class="sxs-lookup"><span data-stu-id="1425b-672">Solution</span></span>
<span data-ttu-id="1425b-673">Almacene un nuevo tipo de entidad en la tabla original mediante entidades con la estructura siguiente:</span><span class="sxs-lookup"><span data-stu-id="1425b-673">Store a new entity type in your original table using entities with the following structure:</span></span>  

![][20]

<span data-ttu-id="1425b-674">Observe que **RowKey** ahora es una clave compuesta formada por el identificador del empleado y el año de los datos de revisión, lo que le permite recuperar el rendimiento del empleado y revisar los datos con una única solicitud para una entidad única.</span><span class="sxs-lookup"><span data-stu-id="1425b-674">Notice how the **RowKey** is now a compound key made up of the employee id and the year of the review data that enables you to retrieve the employee's performance and review data with a single request for a single entity.</span></span>  

<span data-ttu-id="1425b-675">El ejemplo siguiente describe cómo se pueden recuperar todos los datos de revisión para un empleado concreto (como employee 000123 en el departamento de ventas):</span><span class="sxs-lookup"><span data-stu-id="1425b-675">The following example outlines how you can retrieve all the review data for a particular employee (such as employee 000123 in the Sales department):</span></span>  

<span data-ttu-id="1425b-676">$filter=(PartitionKey eq 'Ventas') y (RowKey ge 'empid_000123') y (RowKey lt 'empid_000124')&$select=RowKey,Manager Rating,Peer Rating,Comments</span><span class="sxs-lookup"><span data-stu-id="1425b-676">$filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000123') and (RowKey lt 'empid_000124')&$select=RowKey,Manager Rating,Peer Rating,Comments</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="1425b-677">Problemas y consideraciones</span><span class="sxs-lookup"><span data-stu-id="1425b-677">Issues and considerations</span></span>
<span data-ttu-id="1425b-678">Tenga en cuenta los puntos siguientes al decidir cómo implementar este patrón:</span><span class="sxs-lookup"><span data-stu-id="1425b-678">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="1425b-679">Debe usar un carácter separador adecuado que facilite el análisis del valor **RowKey**: por ejemplo, **000123_2012**.</span><span class="sxs-lookup"><span data-stu-id="1425b-679">You should use a suitable separator character that makes it easy to parse the **RowKey** value: for example, **000123_2012**.</span></span>  
* <span data-ttu-id="1425b-680">También almacena esta entidad en la misma partición que otras entidades que contienen datos relacionados correspondientes al mismo empleado, lo que significa que puede usar EGT para mantener una coherencia segura.</span><span class="sxs-lookup"><span data-stu-id="1425b-680">You are also storing this entity in the same partition as other entities that contain related data for the same employee, which means you can use EGTs to maintain strong consistency.</span></span>
* <span data-ttu-id="1425b-681">Debe considerar la frecuencia con la que consultará los datos para determinar si este patrón es adecuado.</span><span class="sxs-lookup"><span data-stu-id="1425b-681">You should consider how frequently you will query the data to determine whether this pattern is appropriate.</span></span>  <span data-ttu-id="1425b-682">Por ejemplo, si tendrá acceso a los datos de revisión con poca frecuencia y a menudo a los datos de empleados principales debe guardarlos como entidades independientes.</span><span class="sxs-lookup"><span data-stu-id="1425b-682">For example, if you will access the review data infrequently and the main employee data often you should keep them as separate entities.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="1425b-683">Cuándo usar este patrón</span><span class="sxs-lookup"><span data-stu-id="1425b-683">When to use this pattern</span></span>
<span data-ttu-id="1425b-684">Utilice este patrón cuando necesite almacenar una o más entidades relacionadas que consulte con frecuencia.</span><span class="sxs-lookup"><span data-stu-id="1425b-684">Use this pattern when you need to store one or more related entities that you query frequently.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="1425b-685">Orientación y patrones relacionados</span><span class="sxs-lookup"><span data-stu-id="1425b-685">Related patterns and guidance</span></span>
<span data-ttu-id="1425b-686">Los patrones y las directrices siguientes también pueden ser importantes a la hora de implementar este patrón:</span><span class="sxs-lookup"><span data-stu-id="1425b-686">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="1425b-687">Transacciones de grupos de entidades</span><span class="sxs-lookup"><span data-stu-id="1425b-687">Entity Group Transactions</span></span>](#entity-group-transactions)  
* [<span data-ttu-id="1425b-688">Trabajar con tipos de entidad heterogéneos</span><span class="sxs-lookup"><span data-stu-id="1425b-688">Working with heterogeneous entity types</span></span>](#working-with-heterogeneous-entity-types)  
* [<span data-ttu-id="1425b-689">Patrón final coherente de transacciones</span><span class="sxs-lookup"><span data-stu-id="1425b-689">Eventually consistent transactions pattern</span></span>](#eventually-consistent-transactions-pattern)  

### <a name="log-tail-pattern"></a><span data-ttu-id="1425b-690">Patrón final del registro</span><span class="sxs-lookup"><span data-stu-id="1425b-690">Log tail pattern</span></span>
<span data-ttu-id="1425b-691">Recupere las entidades *n* agregadas recientemente a una partición utilizando un valor **RowKey** que se ordene en orden de fecha y hora inverso.</span><span class="sxs-lookup"><span data-stu-id="1425b-691">Retrieve the *n* entities most recently added to a partition by using a **RowKey** value that sorts in reverse date and time order.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="1425b-692">Contexto y problema</span><span class="sxs-lookup"><span data-stu-id="1425b-692">Context and problem</span></span>
<span data-ttu-id="1425b-693">Un requisito común es ser capaz de recuperar las entidades creadas más recientemente, por ejemplo las últimas diez reclamaciones de gastos enviadas por un empleado.</span><span class="sxs-lookup"><span data-stu-id="1425b-693">A common requirement is be able to retrieve the most recently created entities, for example the ten most recent expense claims submitted by an employee.</span></span> <span data-ttu-id="1425b-694">Las consultas de tabla admiten una operación de consulta **$top** para devolver las primeras entidades *n* de un conjunto: no hay ninguna operación de consulta equivalente para devolver las últimas entidades n en un conjunto.</span><span class="sxs-lookup"><span data-stu-id="1425b-694">Table queries support a **$top** query operation to return the first *n* entities from a set: there is no equivalent query operation to return the last n entities in a set.</span></span>  

#### <a name="solution"></a><span data-ttu-id="1425b-695">Solución</span><span class="sxs-lookup"><span data-stu-id="1425b-695">Solution</span></span>
<span data-ttu-id="1425b-696">Almacene las entidades mediante un valor **RowKey** que ordene naturalmente en orden inverso de fecha y hora de modo que la entrada más reciente sea siempre la primera de la tabla.</span><span class="sxs-lookup"><span data-stu-id="1425b-696">Store the entities using a **RowKey** that naturally sorts in reverse date/time order by using so the most recent entry is always the first one in the table.</span></span>  

<span data-ttu-id="1425b-697">Por ejemplo, para poder recuperar las diez reclamaciones de gastos más recientes enviadas por un empleado, puede utilizar un valor de marca inversa derivado de la fecha y hora actuales.</span><span class="sxs-lookup"><span data-stu-id="1425b-697">For example, to be able to retrieve the ten most recent expense claims submitted by an employee, you can use a reverse tick value derived from the current date/time.</span></span> <span data-ttu-id="1425b-698">El siguiente ejemplo de código de C# muestra una forma de crear un valor de "marcas invertidas" adecuado para un valor **RowKey** que ordene de más reciente a más antiguo:</span><span class="sxs-lookup"><span data-stu-id="1425b-698">The following C# code sample shows one way to create a suitable "inverted ticks" value for a **RowKey** that sorts from the most recent to the oldest:</span></span>  

`string invertedTicks = string.Format("{0:D19}", DateTime.MaxValue.Ticks - DateTime.UtcNow.Ticks);`  

<span data-ttu-id="1425b-699">Puede volver al valor de fecha y hora utilizando el código siguiente:</span><span class="sxs-lookup"><span data-stu-id="1425b-699">You can get back to the date time value using the following code:</span></span>  

`DateTime dt = new DateTime(DateTime.MaxValue.Ticks - Int64.Parse(invertedTicks));`  

<span data-ttu-id="1425b-700">La consulta de la tabla tiene este aspecto:</span><span class="sxs-lookup"><span data-stu-id="1425b-700">The table query looks like this:</span></span>  

`https://myaccount.table.core.windows.net/EmployeeExpense(PartitionKey='empid')?$top=10`  

#### <a name="issues-and-considerations"></a><span data-ttu-id="1425b-701">Problemas y consideraciones</span><span class="sxs-lookup"><span data-stu-id="1425b-701">Issues and considerations</span></span>
<span data-ttu-id="1425b-702">Tenga en cuenta los puntos siguientes al decidir cómo implementar este patrón:</span><span class="sxs-lookup"><span data-stu-id="1425b-702">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="1425b-703">Debe rellenar el valor de tic inverso con ceros a la izquierda para asegurarse de que el valor de cadena se ordene según lo esperado.</span><span class="sxs-lookup"><span data-stu-id="1425b-703">You must pad the reverse tick value with leading zeroes to ensure the string value sorts as expected.</span></span>  
* <span data-ttu-id="1425b-704">Debe ser consciente de los objetivos de escalabilidad en el nivel de una partición.</span><span class="sxs-lookup"><span data-stu-id="1425b-704">You must be aware of the scalability targets at the level of a partition.</span></span> <span data-ttu-id="1425b-705">Tenga cuidado de no crear particiones en la zona activa.</span><span class="sxs-lookup"><span data-stu-id="1425b-705">Be careful not create hot spot partitions.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="1425b-706">Cuándo usar este patrón</span><span class="sxs-lookup"><span data-stu-id="1425b-706">When to use this pattern</span></span>
<span data-ttu-id="1425b-707">Utilice este patrón cuando necesite tener acceso a entidades en orden inverso de fecha y hora o cuando se necesite tener acceso a las entidades que haya agregado más recientemente.</span><span class="sxs-lookup"><span data-stu-id="1425b-707">Use this pattern when you need to access entities in reverse date/time order or when you need to access the most recently added entities.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="1425b-708">Orientación y patrones relacionados</span><span class="sxs-lookup"><span data-stu-id="1425b-708">Related patterns and guidance</span></span>
<span data-ttu-id="1425b-709">Los patrones y las directrices siguientes también pueden ser importantes a la hora de implementar este patrón:</span><span class="sxs-lookup"><span data-stu-id="1425b-709">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="1425b-710">Anteponer/anexar antipatrón</span><span class="sxs-lookup"><span data-stu-id="1425b-710">Prepend / append anti-pattern</span></span>](#prepend-append-anti-pattern)  
* [<span data-ttu-id="1425b-711">Recuperación de entidades</span><span class="sxs-lookup"><span data-stu-id="1425b-711">Retrieving entities</span></span>](#retrieving-entities)  

### <a name="high-volume-delete-pattern"></a><span data-ttu-id="1425b-712">Patrón de eliminación de gran volumen</span><span class="sxs-lookup"><span data-stu-id="1425b-712">High volume delete pattern</span></span>
<span data-ttu-id="1425b-713">Habilite la eliminación de un gran volumen de entidades mediante el almacenamiento de todas las entidades para su eliminación simultánea en su propia tabla independiente; elimine las entidades mediante la eliminación de la tabla.</span><span class="sxs-lookup"><span data-stu-id="1425b-713">Enable the deletion of a high volume of entities by storing all the entities for simultaneous deletion in their own separate table; you delete the entities by deleting the table.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="1425b-714">Contexto y problema</span><span class="sxs-lookup"><span data-stu-id="1425b-714">Context and problem</span></span>
<span data-ttu-id="1425b-715">Muchas aplicaciones eliminarán datos antiguos que ya no necesita que estén disponibles para una aplicación cliente o que la aplicación haya archivado en otro medio de almacenamiento.</span><span class="sxs-lookup"><span data-stu-id="1425b-715">Many applications delete old data which no longer needs to be available to a client application, or that the application has archived to another storage medium.</span></span> <span data-ttu-id="1425b-716">Normalmente se identifican estos datos por una fecha: por ejemplo, tiene un requisito para eliminar registros de todas las solicitudes de inicio de sesión que tengan más de 60 días.</span><span class="sxs-lookup"><span data-stu-id="1425b-716">You typically identify such data by a date: for example, you have a requirement to delete records of all login requests that are more than 60 days old.</span></span>  

<span data-ttu-id="1425b-717">Un diseño posible es utilizar la fecha y hora de la solicitud de inicio de sesión en el valor **RowKey**:</span><span class="sxs-lookup"><span data-stu-id="1425b-717">One possible design is to use the date and time of the login request in the **RowKey**:</span></span>  

![][21]

<span data-ttu-id="1425b-718">Este enfoque evita los problemas de las particiones porque la aplicación puede insertar y eliminar entidades de inicio de sesión para cada usuario en una partición independiente.</span><span class="sxs-lookup"><span data-stu-id="1425b-718">This approach avoids partition hotspots because the application can insert and delete login entities for each user in a separate partition.</span></span> <span data-ttu-id="1425b-719">Sin embargo, este enfoque puede ser costoso y lento si tiene un gran número de entidades porque primero debe realizar un recorrido de tabla para identificar todas las entidades que desea eliminar y, a continuación, debe eliminar cada entidad antigua.</span><span class="sxs-lookup"><span data-stu-id="1425b-719">However, this approach may be costly and time consuming if you have a large number of entities because first you need to perform a table scan in order to identify all the entities to delete, and then you must delete each old entity.</span></span> <span data-ttu-id="1425b-720">Tenga en cuenta que puede reducir el número de viajes de ida y vuelta al servidor necesarios para eliminar las entidades antiguas almacenando por lotes varias solicitudes de eliminación en EGT.</span><span class="sxs-lookup"><span data-stu-id="1425b-720">Note that you can reduce the number of round trips to the server required to delete the old entities by batching multiple delete requests into EGTs.</span></span>  

#### <a name="solution"></a><span data-ttu-id="1425b-721">Solución</span><span class="sxs-lookup"><span data-stu-id="1425b-721">Solution</span></span>
<span data-ttu-id="1425b-722">Utilice una tabla independiente para cada día de intentos de inicio de sesión.</span><span class="sxs-lookup"><span data-stu-id="1425b-722">Use a separate table for each day of login attempts.</span></span> <span data-ttu-id="1425b-723">Puede usar el diseño de la entidad anterior para evitar problemas cuando se insertan entidades y eliminar entidades anteriores ahora es simplemente una cuestión de eliminar una tabla todos los días (una operación de almacenamiento único) en lugar de buscar y eliminar cientos de miles de entidades de inicio de sesión individuales cada día.</span><span class="sxs-lookup"><span data-stu-id="1425b-723">You can use the entity design above to avoid hotspots when you are inserting entities, and deleting old entities is now simply a question of deleting one table every day (a single storage operation) instead of finding and deleting hundreds and thousands of individual login entities every day.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="1425b-724">Problemas y consideraciones</span><span class="sxs-lookup"><span data-stu-id="1425b-724">Issues and considerations</span></span>
<span data-ttu-id="1425b-725">Tenga en cuenta los puntos siguientes al decidir cómo implementar este patrón:</span><span class="sxs-lookup"><span data-stu-id="1425b-725">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="1425b-726">¿Su diseño admite otras formas de uso por parte de su aplicación de los datos como la búsqueda de entidades específicas, vinculación con otros datos o generar información de agregado?</span><span class="sxs-lookup"><span data-stu-id="1425b-726">Does your design support other ways your application will use the data such as looking up specific entities, linking with other data, or generating aggregate information?</span></span>  
* <span data-ttu-id="1425b-727">¿Evita el diseño problemas cuando se insertan nuevas entidades?</span><span class="sxs-lookup"><span data-stu-id="1425b-727">Does your design avoid hot spots when you are inserting new entities?</span></span>  
* <span data-ttu-id="1425b-728">Espere un retraso si desea reutilizar el mismo nombre de tabla después de eliminarlo.</span><span class="sxs-lookup"><span data-stu-id="1425b-728">Expect a delay if you want to reuse the same table name after deleting it.</span></span> <span data-ttu-id="1425b-729">Es mejor utilizar siempre nombres de tabla únicos.</span><span class="sxs-lookup"><span data-stu-id="1425b-729">It's better to always use unique table names.</span></span>  
* <span data-ttu-id="1425b-730">Esperar ciertas limitaciones cuando utilice primero una tabla nueva mientras Table service aprende los patrones de acceso y distribuye las particiones entre los nodos.</span><span class="sxs-lookup"><span data-stu-id="1425b-730">Expect some throttling when you first use a new table while the Table service learns the access patterns and distributes the partitions across nodes.</span></span> <span data-ttu-id="1425b-731">Debe considerar la frecuencia con la que necesita crear nuevas tablas.</span><span class="sxs-lookup"><span data-stu-id="1425b-731">You should consider how frequently you need to create new tables.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="1425b-732">Cuándo usar este patrón</span><span class="sxs-lookup"><span data-stu-id="1425b-732">When to use this pattern</span></span>
<span data-ttu-id="1425b-733">Utilice este patrón cuando tenga un gran volumen de entidades que deba eliminar al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="1425b-733">Use this pattern when you have a high volume of entities that you must delete at the same time.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="1425b-734">Orientación y patrones relacionados</span><span class="sxs-lookup"><span data-stu-id="1425b-734">Related patterns and guidance</span></span>
<span data-ttu-id="1425b-735">Los patrones y las directrices siguientes también pueden ser importantes a la hora de implementar este patrón:</span><span class="sxs-lookup"><span data-stu-id="1425b-735">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="1425b-736">Transacciones de grupos de entidades</span><span class="sxs-lookup"><span data-stu-id="1425b-736">Entity Group Transactions</span></span>](#entity-group-transactions)
* [<span data-ttu-id="1425b-737">Modificación de entidades</span><span class="sxs-lookup"><span data-stu-id="1425b-737">Modifying entities</span></span>](#modifying-entities)  

### <a name="data-series-pattern"></a><span data-ttu-id="1425b-738">Patrón de serie de datos</span><span class="sxs-lookup"><span data-stu-id="1425b-738">Data series pattern</span></span>
<span data-ttu-id="1425b-739">Almacene una serie de datos completa en una sola entidad para minimizar el número de solicitudes que realice.</span><span class="sxs-lookup"><span data-stu-id="1425b-739">Store complete data series in a single entity to minimize the number of requests you make.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="1425b-740">Contexto y problema</span><span class="sxs-lookup"><span data-stu-id="1425b-740">Context and problem</span></span>
<span data-ttu-id="1425b-741">Un escenario común para una aplicación es almacenar una serie de datos que normalmente necesite recuperar al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="1425b-741">A common scenario is for an application to store a series of data that it typically needs to retrieve all at once.</span></span> <span data-ttu-id="1425b-742">Por ejemplo, la aplicación podría registrar el número de mensajes de MI que envía cada hora cada empleado y, a continuación, utilizar esta información para trazar cuántos mensajes envió cada usuario durante las 24 horas anteriores.</span><span class="sxs-lookup"><span data-stu-id="1425b-742">For example, your application might record how many IM messages each employee sends every hour, and then use this information to plot how many messages each user sent over the preceding 24 hours.</span></span> <span data-ttu-id="1425b-743">Un diseño podría ser almacenar 24 entidades para cada empleado:</span><span class="sxs-lookup"><span data-stu-id="1425b-743">One design might be to store 24 entities for each employee:</span></span>  

![][22]

<span data-ttu-id="1425b-744">Con este diseño, puede localizar y actualizar fácilmente la entidad que se va a actualizar para cada empleado, siempre que la aplicación necesite actualizar el valor de recuento de mensajes.</span><span class="sxs-lookup"><span data-stu-id="1425b-744">With this design, you can easily locate and update the entity to update for each employee whenever the application needs to update the message count value.</span></span> <span data-ttu-id="1425b-745">Sin embargo, para recuperar la información para trazar un gráfico de la actividad durante las 24 horas anteriores, debe recuperar 24 entidades.</span><span class="sxs-lookup"><span data-stu-id="1425b-745">However, to retrieve the information to plot a chart of the activity for the preceding 24 hours, you must retrieve 24 entities.</span></span>  

#### <a name="solution"></a><span data-ttu-id="1425b-746">Solución</span><span class="sxs-lookup"><span data-stu-id="1425b-746">Solution</span></span>
<span data-ttu-id="1425b-747">Utilice el siguiente diseño con una propiedad independiente para almacenar el número de mensajes de cada hora:</span><span class="sxs-lookup"><span data-stu-id="1425b-747">Use the following design with a separate property to store the message count for each hour:</span></span>  

![][23]

<span data-ttu-id="1425b-748">Con este diseño, puede utilizar una operación de combinación para actualizar el número de mensajes de un empleado para una hora concreta.</span><span class="sxs-lookup"><span data-stu-id="1425b-748">With this design, you can use a merge operation to update the message count for an employee for a specific hour.</span></span> <span data-ttu-id="1425b-749">Ahora puede recuperar toda la información que necesita para trazar el gráfico mediante una solicitud para una entidad única.</span><span class="sxs-lookup"><span data-stu-id="1425b-749">Now, you can retrieve all the information you need to plot the chart using a request for a single entity.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="1425b-750">Problemas y consideraciones</span><span class="sxs-lookup"><span data-stu-id="1425b-750">Issues and considerations</span></span>
<span data-ttu-id="1425b-751">Tenga en cuenta los puntos siguientes al decidir cómo implementar este patrón:</span><span class="sxs-lookup"><span data-stu-id="1425b-751">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="1425b-752">Si la serie de datos completa no cabe en una única entidad (una entidad puede tener hasta 252 propiedades), utilice un almacén de datos alternativo, como un blob.</span><span class="sxs-lookup"><span data-stu-id="1425b-752">If your complete data series does not fit into a single entity (an entity can have up to 252 properties), use an alternative data store such as a blob.</span></span>  
* <span data-ttu-id="1425b-753">Si tiene varios clientes actualizando una entidad simultáneamente, deberá utilizar el **ETag** para implementar la simultaneidad optimista.</span><span class="sxs-lookup"><span data-stu-id="1425b-753">If you have multiple clients updating an entity simultaneously, you will need to use the **ETag** to implement optimistic concurrency.</span></span> <span data-ttu-id="1425b-754">Si tiene muchos clientes, puede experimentar un alto nivel de contención.</span><span class="sxs-lookup"><span data-stu-id="1425b-754">If you have many clients, you may experience high contention.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="1425b-755">Cuándo usar este patrón</span><span class="sxs-lookup"><span data-stu-id="1425b-755">When to use this pattern</span></span>
<span data-ttu-id="1425b-756">Utilice este patrón cuando necesite actualizar y recuperar una serie de datos asociada con una entidad individual.</span><span class="sxs-lookup"><span data-stu-id="1425b-756">Use this pattern when you need to update and retrieve a data series associated with an individual entity.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="1425b-757">Orientación y patrones relacionados</span><span class="sxs-lookup"><span data-stu-id="1425b-757">Related patterns and guidance</span></span>
<span data-ttu-id="1425b-758">Los patrones y las directrices siguientes también pueden ser importantes a la hora de implementar este patrón:</span><span class="sxs-lookup"><span data-stu-id="1425b-758">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="1425b-759">Patrón de entidades de gran tamaño</span><span class="sxs-lookup"><span data-stu-id="1425b-759">Large entities pattern</span></span>](#large-entities-pattern)  
* [<span data-ttu-id="1425b-760">Combinar o reemplazar</span><span class="sxs-lookup"><span data-stu-id="1425b-760">Merge or replace</span></span>](#merge-or-replace)  
* <span data-ttu-id="1425b-761">[Patrón final coherente de transacciones](#eventually-consistent-transactions-pattern) (si va a almacenar la serie de datos en un blob)</span><span class="sxs-lookup"><span data-stu-id="1425b-761">[Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) (if you are storing the data series in a blob)</span></span>  

### <a name="wide-entities-pattern"></a><span data-ttu-id="1425b-762">Patrón de entidades amplio</span><span class="sxs-lookup"><span data-stu-id="1425b-762">Wide entities pattern</span></span>
<span data-ttu-id="1425b-763">Use varias entidades físicas para almacenar entidades lógicas con más de 252 propiedades.</span><span class="sxs-lookup"><span data-stu-id="1425b-763">Use multiple physical entities to store logical entities with more than 252 properties.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="1425b-764">Contexto y problema</span><span class="sxs-lookup"><span data-stu-id="1425b-764">Context and problem</span></span>
<span data-ttu-id="1425b-765">Una entidad individual no puede tener más de 252 propiedades (excepto las propiedades del sistema obligatorias) y no puede almacenar más de 1 MB de datos en total.</span><span class="sxs-lookup"><span data-stu-id="1425b-765">An individual entity can have no more than 252 properties (excluding the mandatory system properties) and cannot store more than 1 MB of data in total.</span></span> <span data-ttu-id="1425b-766">En una base de datos relacional, normalmente se encontrará con límites en el tamaño de una fila de ida y vuelta al agregar una nueva tabla e imponer una relación de 1 a 1 entre ellas.</span><span class="sxs-lookup"><span data-stu-id="1425b-766">In a relational database, you would typically get round any limits on the size of a row by adding a new table and enforcing a 1-to-1 relationship between them.</span></span>  

#### <a name="solution"></a><span data-ttu-id="1425b-767">Solución</span><span class="sxs-lookup"><span data-stu-id="1425b-767">Solution</span></span>
<span data-ttu-id="1425b-768">Con Table service, puede almacenar varias entidades para representar un objeto único de gran empresa con más de 252 propiedades.</span><span class="sxs-lookup"><span data-stu-id="1425b-768">Using the Table service, you can store multiple entities to represent a single large business object with more than 252 properties.</span></span> <span data-ttu-id="1425b-769">Por ejemplo, si desea almacenar un recuento del número de mensajes de mensajería instantánea enviados por cada empleado durante los últimos 365 días, podría utilizar el siguiente diseño que usa dos entidades con distintos esquemas:</span><span class="sxs-lookup"><span data-stu-id="1425b-769">For example, if you want to store a count of the number of IM messages sent by each employee for the last 365 days, you could use the following design that uses two entities with different schemas:</span></span>  

![][24]

<span data-ttu-id="1425b-770">Si necesita realizar un cambio que requiere la actualización de ambas entidades para mantenerlas sincronizadas entre sí puede utilizar un EGT.</span><span class="sxs-lookup"><span data-stu-id="1425b-770">If you need to make a change that requires updating both entities to keep them synchronized with each other you can use an EGT.</span></span> <span data-ttu-id="1425b-771">De lo contrario, puede utilizar una única operación de combinación para actualizar el número de mensajes para un día concreto.</span><span class="sxs-lookup"><span data-stu-id="1425b-771">Otherwise, you can use a single merge operation to update the message count for a specific day.</span></span> <span data-ttu-id="1425b-772">Para recuperar todos los datos de un empleado individual debe recuperar ambas entidades, lo que puede hacer con dos solicitudes eficaces que se usan un valor **PartitionKey** y **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="1425b-772">To retrieve all the data for an individual employee you must retrieve both entities, which you can do with two efficient requests that use both a **PartitionKey** and a **RowKey** value.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="1425b-773">Problemas y consideraciones</span><span class="sxs-lookup"><span data-stu-id="1425b-773">Issues and considerations</span></span>
<span data-ttu-id="1425b-774">Tenga en cuenta los puntos siguientes al decidir cómo implementar este patrón:</span><span class="sxs-lookup"><span data-stu-id="1425b-774">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="1425b-775">Recuperar una entidad lógica completa implica al menos dos transacciones de almacenamiento: una para recuperar cada entidad física.</span><span class="sxs-lookup"><span data-stu-id="1425b-775">Retrieving a complete logical entity involves at least two storage transactions: one to retrieve each physical entity.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="1425b-776">Cuándo usar este patrón</span><span class="sxs-lookup"><span data-stu-id="1425b-776">When to use this pattern</span></span>
<span data-ttu-id="1425b-777">Utilice este patrón cuando necesite almacenar entidades cuyo tamaño o número de propiedades supere los límites de una entidad individual en Table service.</span><span class="sxs-lookup"><span data-stu-id="1425b-777">Use this pattern when  need to store entities whose size or number of properties exceeds the limits for an individual entity in the Table service.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="1425b-778">Orientación y patrones relacionados</span><span class="sxs-lookup"><span data-stu-id="1425b-778">Related patterns and guidance</span></span>
<span data-ttu-id="1425b-779">Los patrones y las directrices siguientes también pueden ser importantes a la hora de implementar este patrón:</span><span class="sxs-lookup"><span data-stu-id="1425b-779">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="1425b-780">Transacciones de grupos de entidades</span><span class="sxs-lookup"><span data-stu-id="1425b-780">Entity Group Transactions</span></span>](#entity-group-transactions)
* [<span data-ttu-id="1425b-781">Combinar o reemplazar</span><span class="sxs-lookup"><span data-stu-id="1425b-781">Merge or replace</span></span>](#merge-or-replace)

### <a name="large-entities-pattern"></a><span data-ttu-id="1425b-782">Patrón de entidades de gran tamaño</span><span class="sxs-lookup"><span data-stu-id="1425b-782">Large entities pattern</span></span>
<span data-ttu-id="1425b-783">Use Blob Storage para almacenar valores de propiedad de gran tamaño.</span><span class="sxs-lookup"><span data-stu-id="1425b-783">Use blob storage to store large property values.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="1425b-784">Contexto y problema</span><span class="sxs-lookup"><span data-stu-id="1425b-784">Context and problem</span></span>
<span data-ttu-id="1425b-785">Una entidad individual no puede almacenar más de 1 MB de datos en total.</span><span class="sxs-lookup"><span data-stu-id="1425b-785">An individual entity cannot store more than 1 MB of data in total.</span></span> <span data-ttu-id="1425b-786">Si una o varias de sus propiedades almacenan valores que provocan que el tamaño total de la entidad supere este valor, no puede almacenar toda la entidad en Table service.</span><span class="sxs-lookup"><span data-stu-id="1425b-786">If one or several of your properties store values that cause the total size of your entity to exceed this value, you cannot store the entire entity in the Table service.</span></span>  

#### <a name="solution"></a><span data-ttu-id="1425b-787">Solución</span><span class="sxs-lookup"><span data-stu-id="1425b-787">Solution</span></span>
<span data-ttu-id="1425b-788">Si la entidad supera 1 MB de tamaño porque una o más propiedades contienen una gran cantidad de datos, puede almacenar datos en Blob service y, a continuación, almacenar la dirección del blob en una propiedad de la entidad.</span><span class="sxs-lookup"><span data-stu-id="1425b-788">If your entity exceeds 1 MB in size because one or more properties contain a large amount of data, you can store data in the Blob service and then store the address of the blob in a property in the entity.</span></span> <span data-ttu-id="1425b-789">Por ejemplo, puede almacenar la foto de un empleado en Blob Storage y almacenar un vínculo a la foto en la propiedad **Photo** de la entidad employee:</span><span class="sxs-lookup"><span data-stu-id="1425b-789">For example, you can store the photo of an employee in blob storage and store a link to the photo in the **Photo** property of your employee entity:</span></span>  

![][25]

#### <a name="issues-and-considerations"></a><span data-ttu-id="1425b-790">Problemas y consideraciones</span><span class="sxs-lookup"><span data-stu-id="1425b-790">Issues and considerations</span></span>
<span data-ttu-id="1425b-791">Tenga en cuenta los puntos siguientes al decidir cómo implementar este patrón:</span><span class="sxs-lookup"><span data-stu-id="1425b-791">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="1425b-792">Para mantener la coherencia eventual entre la entidad de Table service y los datos de Blob service, utilice el [patrón final coherente de transacciones](#eventually-consistent-transactions-pattern) para mantener las entidades.</span><span class="sxs-lookup"><span data-stu-id="1425b-792">To maintain eventual consistency between the entity in the Table service and the data in the Blob service, use the [Eventually consistent transactions pattern](#eventually-consistent-transactions-pattern) to maintain your entities.</span></span>
* <span data-ttu-id="1425b-793">Recuperar una entidad completa implica al menos dos transacciones de almacenamiento: una para recuperar la entidad y otra para recuperar los datos del blob.</span><span class="sxs-lookup"><span data-stu-id="1425b-793">Retrieving a complete entity involves at least two storage transactions: one to retrieve the entity and one to retrieve the blob data.</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="1425b-794">Cuándo usar este patrón</span><span class="sxs-lookup"><span data-stu-id="1425b-794">When to use this pattern</span></span>
<span data-ttu-id="1425b-795">Utilice este patrón cuando necesite almacenar entidades cuyo tamaño supere los límites para una entidad individual en Table service.</span><span class="sxs-lookup"><span data-stu-id="1425b-795">Use this pattern when you need to store entities whose size exceeds the limits for an individual entity in the Table service.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="1425b-796">Orientación y patrones relacionados</span><span class="sxs-lookup"><span data-stu-id="1425b-796">Related patterns and guidance</span></span>
<span data-ttu-id="1425b-797">Los patrones y las directrices siguientes también pueden ser importantes a la hora de implementar este patrón:</span><span class="sxs-lookup"><span data-stu-id="1425b-797">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="1425b-798">Patrón final coherente de transacciones</span><span class="sxs-lookup"><span data-stu-id="1425b-798">Eventually consistent transactions pattern</span></span>](#eventually-consistent-transactions-pattern)  
* [<span data-ttu-id="1425b-799">Patrón de entidades amplio</span><span class="sxs-lookup"><span data-stu-id="1425b-799">Wide entities pattern</span></span>](#wide-entities-pattern)

<a name="prepend-append-anti-pattern"></a>

### <a name="prependappend-anti-pattern"></a><span data-ttu-id="1425b-800">Antipatrón de anteponer/anexar</span><span class="sxs-lookup"><span data-stu-id="1425b-800">Prepend/append anti-pattern</span></span>
<span data-ttu-id="1425b-801">Aumente la escalabilidad cuando tenga un alto volumen de inserciones al repartir estas en varias particiones.</span><span class="sxs-lookup"><span data-stu-id="1425b-801">Increase scalability when you have a high volume of inserts by spreading the inserts across multiple partitions.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="1425b-802">Contexto y problema</span><span class="sxs-lookup"><span data-stu-id="1425b-802">Context and problem</span></span>
<span data-ttu-id="1425b-803">Anteponer o anexar las entidades a las entidades almacenadas normalmente provoca en la aplicación la adición de nuevas entidades a la primera o última partición de una secuencia de particiones.</span><span class="sxs-lookup"><span data-stu-id="1425b-803">Prepending or appending entities to your stored entities typically results in the application adding new entities to the first or last partition of a sequence of partitions.</span></span> <span data-ttu-id="1425b-804">En este caso, todas las inserciones en un momento determinado están teniendo lugar en la misma partición, creando un punto de conflicto que impide que Table service efectúe el equilibrio de cargas en varios nodos, provocando posiblemente que la aplicación alcance los objetivos de escalabilidad de la partición.</span><span class="sxs-lookup"><span data-stu-id="1425b-804">In this case, all of the inserts at any given time are taking place in the same partition, creating a hotspot that prevents the table service from load balancing inserts across multiple nodes, and possibly causing your application to hit the scalability targets for partition.</span></span> <span data-ttu-id="1425b-805">Por ejemplo, si tiene una aplicación que registra el acceso a la red y a recursos por parte de los empleados, una estructura de entidad como la mostrada a continuación podría provocar que la partición de la hora actual se convierta en un punto de conflicto si el volumen de transacciones alcanza el objetivo de escalabilidad de una partición individual:</span><span class="sxs-lookup"><span data-stu-id="1425b-805">For example, if you have an application that logs network and resource access by employees, then an entity structure as shown below could result in the current hour's partition becoming a hotspot if the volume of transactions reaches the scalability target for an individual partition:</span></span>  

![][26]

#### <a name="solution"></a><span data-ttu-id="1425b-806">Solución</span><span class="sxs-lookup"><span data-stu-id="1425b-806">Solution</span></span>
<span data-ttu-id="1425b-807">La siguiente estructura de una entidad alternativa evita puntos de conflicto en una partición determinada a medida que la aplicación registra eventos:</span><span class="sxs-lookup"><span data-stu-id="1425b-807">The following alternative entity structure avoids a hotspot on any particular partition as the application logs events:</span></span>  

![][27]

<span data-ttu-id="1425b-808">Observe en este ejemplo que tanto **PartitionKey** como **RowKey** son claves compuestas.</span><span class="sxs-lookup"><span data-stu-id="1425b-808">Notice with this example how both the **PartitionKey** and **RowKey** are compound keys.</span></span> <span data-ttu-id="1425b-809">**PartitionKey** usa tanto el departamento como el identificador de empleado para distribuir el registro en varias particiones.</span><span class="sxs-lookup"><span data-stu-id="1425b-809">The **PartitionKey** uses both the department and employee id to distribute the logging across multiple partitions.</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="1425b-810">Problemas y consideraciones</span><span class="sxs-lookup"><span data-stu-id="1425b-810">Issues and considerations</span></span>
<span data-ttu-id="1425b-811">Tenga en cuenta los puntos siguientes al decidir cómo implementar este patrón:</span><span class="sxs-lookup"><span data-stu-id="1425b-811">Consider the following points when deciding how to implement this pattern:</span></span>  

* <span data-ttu-id="1425b-812">¿Admite la estructura de clave alternativa que evita la creación de particiones activas en inserciones eficazmente las consultas que realiza la aplicación cliente?</span><span class="sxs-lookup"><span data-stu-id="1425b-812">Does the alternative key structure that avoids creating hot partitions on inserts efficiently support the queries your client application makes?</span></span>  
* <span data-ttu-id="1425b-813">¿El volumen de transacciones previstas significa que es probable alcanzar los objetivos de escalabilidad para una partición individual y estar limitada por el servicio de almacenamiento?</span><span class="sxs-lookup"><span data-stu-id="1425b-813">Does your anticipated volume of transactions mean that you are likely to reach the scalability targets for an individual partition and be throttled by the storage service?</span></span>  

#### <a name="when-to-use-this-pattern"></a><span data-ttu-id="1425b-814">Cuándo usar este patrón</span><span class="sxs-lookup"><span data-stu-id="1425b-814">When to use this pattern</span></span>
<span data-ttu-id="1425b-815">Evite el antipatrón anteponer/anexar cuando es posible que el volumen de transacciones provoque una limitación por parte del servicio de almacenamiento cuando acceda a una partición activa.</span><span class="sxs-lookup"><span data-stu-id="1425b-815">Avoid the prepend/append anti-pattern when your volume of transactions is likely to result in throttling by the storage service when you access a hot partition.</span></span>  

#### <a name="related-patterns-and-guidance"></a><span data-ttu-id="1425b-816">Orientación y patrones relacionados</span><span class="sxs-lookup"><span data-stu-id="1425b-816">Related patterns and guidance</span></span>
<span data-ttu-id="1425b-817">Los patrones y las directrices siguientes también pueden ser importantes a la hora de implementar este patrón:</span><span class="sxs-lookup"><span data-stu-id="1425b-817">The following patterns and guidance may also be relevant when implementing this pattern:</span></span>  

* [<span data-ttu-id="1425b-818">Patrón de clave compuesta</span><span class="sxs-lookup"><span data-stu-id="1425b-818">Compound key pattern</span></span>](#compound-key-pattern)  
* [<span data-ttu-id="1425b-819">Patrón de cola de registro</span><span class="sxs-lookup"><span data-stu-id="1425b-819">Log tail pattern</span></span>](#log-tail-pattern)  
* [<span data-ttu-id="1425b-820">Modificación de entidades</span><span class="sxs-lookup"><span data-stu-id="1425b-820">Modifying entities</span></span>](#modifying-entities)  

### <a name="log-data-anti-pattern"></a><span data-ttu-id="1425b-821">Antipatrón de datos de registro</span><span class="sxs-lookup"><span data-stu-id="1425b-821">Log data anti-pattern</span></span>
<span data-ttu-id="1425b-822">Normalmente, debe utilizar Blob service en lugar de Table service para almacenar los datos de registro.</span><span class="sxs-lookup"><span data-stu-id="1425b-822">Typically, you should use the Blob service instead of the Table service to store log data.</span></span>  

#### <a name="context-and-problem"></a><span data-ttu-id="1425b-823">Contexto y problema</span><span class="sxs-lookup"><span data-stu-id="1425b-823">Context and problem</span></span>
<span data-ttu-id="1425b-824">Un caso de uso común para los datos del registro es recuperar una selección de entradas de registro para un intervalo de fecha y hora específico: por ejemplo, desea buscar todos los mensajes de error y críticos que ha registrado la aplicación entre las 15:04 y las 15:06 en una fecha concreta.</span><span class="sxs-lookup"><span data-stu-id="1425b-824">A common use case for log data is to retrieve a selection of log entries for a specific date/time range: for example, you want to find all the error and critical messages that your application logged between 15:04 and 15:06 on a specific date.</span></span> <span data-ttu-id="1425b-825">No desea utilizar la fecha y hora del mensaje del registro para determinar la partición en la que se guardan las entidades del registro: esto da como resultado una partición activa porque en un momento dado, todas las entidades de registro compartirán el mismo valor **PartitionKey** (consulte la sección [Anteponer o anexar antipatrón](#prepend-append-anti-pattern)).</span><span class="sxs-lookup"><span data-stu-id="1425b-825">You do not want to use the date and time of the log message to determine the partition you save log entities to: that results in a hot partition because at any given time, all the log entities will share the same **PartitionKey** value (see the section [Prepend/append anti-pattern](#prepend-append-anti-pattern)).</span></span> <span data-ttu-id="1425b-826">Por ejemplo, el siguiente esquema de entidad para un mensaje de registro produce una partición activa debido a que la aplicación escribe todos los mensajes de registro en la partición en la fecha y la hora actuales:</span><span class="sxs-lookup"><span data-stu-id="1425b-826">For example, the following entity schema for a log message results in a hot partition because the application writes all log messages to the partition for the current date and hour:</span></span>  

![][28]

<span data-ttu-id="1425b-827">En este ejemplo, **RowKey** incluye la fecha y hora del mensaje del registro para asegurarse de que los mensajes de registro se almacenan ordenados por fecha y hora e incluye un identificador de mensaje en caso de que varios mensajes de registro compartan la misma fecha y hora.</span><span class="sxs-lookup"><span data-stu-id="1425b-827">In this example, the **RowKey** includes the date and time of the log message to ensure that log messages are stored sorted in date/time order, and includes a message id in case multiple log messages share the same date and time.</span></span>  

<span data-ttu-id="1425b-828">Otro enfoque consiste en utilizar un valor **PartitionKey** que garantice que la aplicación escriba los mensajes en un intervalo de particiones.</span><span class="sxs-lookup"><span data-stu-id="1425b-828">Another approach is to use a **PartitionKey** that ensures that the application writes messages across a range of partitions.</span></span> <span data-ttu-id="1425b-829">Por ejemplo, si el origen del mensaje de registro proporciona una manera de distribuir los mensajes entre muchas particiones, podría utilizar el siguiente esquema de entidad:</span><span class="sxs-lookup"><span data-stu-id="1425b-829">For example, if the source of the log message provides a way to distribute messages across many partitions, you could use the following entity schema:</span></span>  

![][29]

<span data-ttu-id="1425b-830">Sin embargo, el problema con este esquema es que para recuperar todos los mensajes de registro de un intervalo de tiempo específico debe buscar todas las particiones de la tabla.</span><span class="sxs-lookup"><span data-stu-id="1425b-830">However, the problem with this schema is that to retrieve all the log messages for a specific time span you must search every partition in the table.</span></span>

#### <a name="solution"></a><span data-ttu-id="1425b-831">Solución</span><span class="sxs-lookup"><span data-stu-id="1425b-831">Solution</span></span>
<span data-ttu-id="1425b-832">En la sección anterior se resaltó el problema de intentar utilizar Table service para almacenar las entradas del registro y se sugirieron dos diseños no satisfactorios.</span><span class="sxs-lookup"><span data-stu-id="1425b-832">The previous section highlighted the problem of trying to use the Table service to store log entries and suggested two, unsatisfactory, designs.</span></span> <span data-ttu-id="1425b-833">Una solución provocó una partición activa con el riesgo de obtener un bajo rendimiento de escritura de mensajes de registro; la otra solución ocasionó un bajo rendimiento de consultas debido a la necesidad de examinar cada partición de la tabla para recuperar los mensajes de registro de un intervalo de tiempo específico.</span><span class="sxs-lookup"><span data-stu-id="1425b-833">One solution led to a hot partition with the risk of poor performance writing log messages; the other solution resulted in poor query performance because of the requirement to scan every partition in the table to retrieve log messages for a specific time span.</span></span> <span data-ttu-id="1425b-834">Blob Storage ofrece una mejor solución para este tipo de escenario y así es como almacena Azure Storage Analytics los datos de registro que recopila.</span><span class="sxs-lookup"><span data-stu-id="1425b-834">Blob storage offers a better solution for this type of scenario and this is how Azure Storage Analytics stores the log data it collects.</span></span>  

<span data-ttu-id="1425b-835">En esta sección se describe cómo almacena Storage Analytics los datos de registro en Blob Storage para ilustrar este método de almacenamiento de datos que se suele consultar por intervalo.</span><span class="sxs-lookup"><span data-stu-id="1425b-835">This section outlines how Storage Analytics stores log data in blob storage as an illustration of this approach to storing data that you typically query by range.</span></span>  

<span data-ttu-id="1425b-836">Storage Analytics almacena los mensajes de registro en un formato delimitado en varios blobs.</span><span class="sxs-lookup"><span data-stu-id="1425b-836">Storage Analytics stores log messages in a delimited format in multiple blobs.</span></span> <span data-ttu-id="1425b-837">El formato delimitado facilita a una aplicación cliente analizar los datos del mensaje de registro.</span><span class="sxs-lookup"><span data-stu-id="1425b-837">The delimited format makes it easy for a client application to parse the data in the log message.</span></span>  

<span data-ttu-id="1425b-838">Storage Analytics utiliza una convención de nomenclatura para los blobs que le permite localizar el blob (o blobs) que contienen los mensajes de registro que está buscando.</span><span class="sxs-lookup"><span data-stu-id="1425b-838">Storage Analytics uses a naming convention for blobs that enables you to locate the blob (or blobs) that contain the log messages for which you are searching.</span></span> <span data-ttu-id="1425b-839">Por ejemplo, un blob denominado "queue/2014/07/31/1800/000001.log" contiene los mensajes de registro relacionados con el servicio de cola con hora de inicio a las 18:00 del 31 de julio de 2014.</span><span class="sxs-lookup"><span data-stu-id="1425b-839">For example, a blob named "queue/2014/07/31/1800/000001.log" contains log messages that relate to the queue service for the hour starting at 18:00 on 31 July 2014.</span></span> <span data-ttu-id="1425b-840">El "000001" indica que se trata del primer archivo de registro de este período.</span><span class="sxs-lookup"><span data-stu-id="1425b-840">The "000001" indicates that this is the first log file for this period.</span></span> <span data-ttu-id="1425b-841">Storage Analytics también registra las marcas de tiempo del primer y último mensaje de registro almacenados en el archivo como parte de los metadatos del blob.</span><span class="sxs-lookup"><span data-stu-id="1425b-841">Storage Analytics also records the timestamps of the first and last log messages stored in the file as part of the blob's metadata.</span></span> <span data-ttu-id="1425b-842">La API de Blob Storage le permite buscar blobs en un contenedor basándose en un prefijo de nombre: para encontrar todos los blobs que contienen datos de registro de cola con hora de inicio a las 18:00, puede usar el prefijo "cola/2014/07/31/1800".</span><span class="sxs-lookup"><span data-stu-id="1425b-842">The API for blob storage enables you locate blobs in a container based on a name prefix: to locate all the blobs that contain queue log data for the hour starting at 18:00, you can use the prefix "queue/2014/07/31/1800."</span></span>  

<span data-ttu-id="1425b-843">Storage Analytics almacena en búfer los mensajes de registro internamente y, a continuación, periódicamente actualiza el blob adecuado o crea uno nuevo con el último lote de entradas de registro.</span><span class="sxs-lookup"><span data-stu-id="1425b-843">Storage Analytics buffers log messages internally and then periodically updates the appropriate blob or creates a new one with the latest batch of log entries.</span></span> <span data-ttu-id="1425b-844">Esto reduce el número de escrituras que se debe realizar en Blob service.</span><span class="sxs-lookup"><span data-stu-id="1425b-844">This reduces the number of writes it must perform to the blob service.</span></span>  

<span data-ttu-id="1425b-845">Si está implementando una solución similar en su propia aplicación, debe considerar cómo administrar el equilibrio entre la fiabilidad (escribir cada entrada de registro en Blob Storage según se van produciendo) y el coste y la escalabilidad (almacenamiento en búfer de las actualizaciones en su aplicación y escribirlos en Blob Storage por lotes).</span><span class="sxs-lookup"><span data-stu-id="1425b-845">If you are implementing a similar solution in your own application, you must consider how to manage the trade-off between reliability (writing every log entry to blob storage as it happens) and cost and scalability (buffering updates in your application and writing them to blob storage in batches).</span></span>  

#### <a name="issues-and-considerations"></a><span data-ttu-id="1425b-846">Problemas y consideraciones</span><span class="sxs-lookup"><span data-stu-id="1425b-846">Issues and considerations</span></span>
<span data-ttu-id="1425b-847">Tenga en cuenta los siguientes puntos cuando decida cómo almacenar los datos del registro:</span><span class="sxs-lookup"><span data-stu-id="1425b-847">Consider the following points when deciding how to store log data:</span></span>  

* <span data-ttu-id="1425b-848">Si crea un diseño de tabla que evite posibles particiones activas, observará que no tiene acceso a los datos del registro de forma eficaz.</span><span class="sxs-lookup"><span data-stu-id="1425b-848">If you create a table design that avoids potential hot partitions, you may find that you cannot access your log data efficiently.</span></span>  
* <span data-ttu-id="1425b-849">Para procesar los datos de registro, un cliente a menudo necesita cargar muchos registros.</span><span class="sxs-lookup"><span data-stu-id="1425b-849">To process log data, a client often needs to load many records.</span></span>  
* <span data-ttu-id="1425b-850">Aunque a menudo se estructuran de datos del registro, Blob Storage puede ser una solución mejor.</span><span class="sxs-lookup"><span data-stu-id="1425b-850">Although log data is often structured, blob storage may be a better solution.</span></span>  

### <a name="implementation-considerations"></a><span data-ttu-id="1425b-851">Consideraciones de implementación</span><span class="sxs-lookup"><span data-stu-id="1425b-851">Implementation considerations</span></span>
<span data-ttu-id="1425b-852">En esta sección se describen algunas de las consideraciones a tener en cuenta al implementar los modelos descritos en las secciones anteriores.</span><span class="sxs-lookup"><span data-stu-id="1425b-852">This section discusses some of the considerations to bear in mind when you implement the patterns described in the previous sections.</span></span> <span data-ttu-id="1425b-853">En la mayor parte de esta sección se utilizan ejemplos escritos en C# que utilizan la biblioteca de clientes de Storage (versión 4.3.0 en el momento de escribir).</span><span class="sxs-lookup"><span data-stu-id="1425b-853">Most of this section uses examples written in C# that use the Storage Client Library (version 4.3.0 at the time of writing).</span></span>  

### <a name="retrieving-entities"></a><span data-ttu-id="1425b-854">Recuperación de entidades</span><span class="sxs-lookup"><span data-stu-id="1425b-854">Retrieving entities</span></span>
<span data-ttu-id="1425b-855">Como se describe en la sección [Diseño para consultas](#design-for-querying), la consulta más eficaz es una puntual.</span><span class="sxs-lookup"><span data-stu-id="1425b-855">As discussed in the section [Design for querying](#design-for-querying), the most efficient query is a point query.</span></span> <span data-ttu-id="1425b-856">Sin embargo, en algunos casos puede que necesite recuperar varias entidades.</span><span class="sxs-lookup"><span data-stu-id="1425b-856">However, in some scenarios you may need to retrieve multiple entities.</span></span> <span data-ttu-id="1425b-857">En esta sección se describen algunos enfoques comunes para recuperar entidades mediante la biblioteca de clientes de Storage.</span><span class="sxs-lookup"><span data-stu-id="1425b-857">This section describes some common approaches to retrieving entities using the Storage Client Library.</span></span>  

#### <a name="executing-a-point-query-using-the-storage-client-library"></a><span data-ttu-id="1425b-858">Ejecutar una consulta de punto mediante la biblioteca de clientes de Storage </span><span class="sxs-lookup"><span data-stu-id="1425b-858">Executing a point query using the Storage Client Library</span></span>
<span data-ttu-id="1425b-859">La manera más sencilla de ejecutar una consulta puntual es usar la operación de tabla **Retrieve**, como se muestra en el siguiente fragmento de código de C# que recupera una entidad con el valor **PartitionKey** "Sales" y el valor **RowKey** "212":</span><span class="sxs-lookup"><span data-stu-id="1425b-859">The easiest way to execute a point query is to use the **Retrieve** table operation as shown in the following C# code snippet that retrieves an entity with a **PartitionKey** of value "Sales" and a **RowKey** of value "212":</span></span>  

```csharp
TableOperation retrieveOperation = TableOperation.Retrieve<EmployeeEntity>("Sales", "212");
var retrieveResult = employeeTable.Execute(retrieveOperation);
if (retrieveResult.Result != null)
{
    EmployeeEntity employee = (EmployeeEntity)retrieveResult.Result;
    ...
}  
```

<span data-ttu-id="1425b-860">Observe cómo este ejemplo espera que la entidad que recupera sea del tipo **EmployeeEntity**.</span><span class="sxs-lookup"><span data-stu-id="1425b-860">Notice how this example expects the entity it retrieves to be of type **EmployeeEntity**.</span></span>  

#### <a name="retrieving-multiple-entities-using-linq"></a><span data-ttu-id="1425b-861">Recuperar varias entidades con LINQ</span><span class="sxs-lookup"><span data-stu-id="1425b-861">Retrieving multiple entities using LINQ</span></span>
<span data-ttu-id="1425b-862">Puede recuperar varias entidades mediante LINQ con la biblioteca de clientes de Storage y especificar una consulta con una cláusula **where** .</span><span class="sxs-lookup"><span data-stu-id="1425b-862">You can retrieve multiple entities by using LINQ with Storage Client Library and specifying a query with a **where** clause.</span></span> <span data-ttu-id="1425b-863">Para evitar un examen de tabla, debe incluir siempre el valor **PartitionKey** en la cláusula where y, si es posible, el valor **RowKey** para evitar exámenes de tablas y de particiones.</span><span class="sxs-lookup"><span data-stu-id="1425b-863">To avoid a table scan, you should always include the **PartitionKey** value in the where clause, and if possible the **RowKey** value to avoid table and partition scans.</span></span> <span data-ttu-id="1425b-864">Table service admite un conjunto limitado de operadores de comparación (mayor que, mayor o igual que, menor que, menor o igual que, igual y no igual a) para utilizar en la cláusula where.</span><span class="sxs-lookup"><span data-stu-id="1425b-864">The table service supports a limited set of comparison operators (greater than, greater than or equal, less than, less than or equal, equal, and not equal) to use in the where clause.</span></span> <span data-ttu-id="1425b-865">El siguiente fragmento de código de C# busca todos los empleados cuyo apellido empieza por "B" (suponiendo que **RowKey** almacene el apellido) del departamento de ventas (suponiendo que **PartitionKey** almacene el nombre del departamento):</span><span class="sxs-lookup"><span data-stu-id="1425b-865">The following C# code snippet finds all the employees whose last name starts with "B" (assuming that the **RowKey** stores the last name) in the sales department (assuming the **PartitionKey** stores the department name):</span></span>  

```csharp
TableQuery<EmployeeEntity> employeeQuery = employeeTable.CreateQuery<EmployeeEntity>();
var query = (from employee in employeeQuery
            where employee.PartitionKey == "Sales" &&
            employee.RowKey.CompareTo("B") >= 0 &&
            employee.RowKey.CompareTo("C") < 0
            select employee).AsTableQuery();
var employees = query.Execute();  
```

<span data-ttu-id="1425b-866">Observe que la consulta especifica un valor **RowKey** y un valor **PartitionKey** para asegurar un mejor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="1425b-866">Notice how the query specifies both a **RowKey** and a **PartitionKey** to ensure better performance.</span></span>  

<span data-ttu-id="1425b-867">El siguiente ejemplo de código muestra una funcionalidad equivalente mediante la API fluida (para obtener más información acerca de las API fluidas en general, consulte [Procedimientos recomendados para diseñar una API fluida](http://visualstudiomagazine.com/articles/2013/12/01/best-practices-for-designing-a-fluent-api.aspx)):</span><span class="sxs-lookup"><span data-stu-id="1425b-867">The following code sample shows equivalent functionality using the fluent API (for more information about fluent APIs in general, see [Best Practices for Designing a Fluent API](http://visualstudiomagazine.com/articles/2013/12/01/best-practices-for-designing-a-fluent-api.aspx)):</span></span>  

```csharp
TableQuery<EmployeeEntity> employeeQuery = new TableQuery<EmployeeEntity>().Where(
    TableQuery.CombineFilters(
    TableQuery.CombineFilters(
        TableQuery.GenerateFilterCondition(
    "PartitionKey", QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.GenerateFilterCondition(
    "RowKey", QueryComparisons.GreaterThanOrEqual, "B")
),
TableOperators.And,
TableQuery.GenerateFilterCondition("RowKey", QueryComparisons.LessThan, "C")
    )
);
var employees = employeeTable.ExecuteQuery(employeeQuery);  
```

> [!NOTE]
> <span data-ttu-id="1425b-868">El ejemplo anida varios métodos **CombineFilters** para incluir las tres condiciones de filtro.</span><span class="sxs-lookup"><span data-stu-id="1425b-868">The sample nests multiple **CombineFilters** methods to include the three filter conditions.</span></span>  
> 
> 

#### <a name="retrieving-large-numbers-of-entities-from-a-query"></a><span data-ttu-id="1425b-869">Recuperar una gran cantidad de entidades de una consulta</span><span class="sxs-lookup"><span data-stu-id="1425b-869">Retrieving large numbers of entities from a query</span></span>
<span data-ttu-id="1425b-870">Una consulta óptima devuelve una entidad individual basada en un valor **PartitionKey** y un valor **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="1425b-870">An optimal query returns an individual entity based on a **PartitionKey** value and a **RowKey** value.</span></span> <span data-ttu-id="1425b-871">Sin embargo, en algunos escenarios puede tener el requisito de devolver varias entidades de la misma partición o incluso de varias particiones.</span><span class="sxs-lookup"><span data-stu-id="1425b-871">However, in some scenarios you may have a requirement to return many entities from the same partition or even from many partitions.</span></span>  

<span data-ttu-id="1425b-872">Siempre se debe probar a fondo el rendimiento de la aplicación en estas situaciones.</span><span class="sxs-lookup"><span data-stu-id="1425b-872">You should always fully test the performance of your application in such scenarios.</span></span>  

<span data-ttu-id="1425b-873">Una consulta en Table service puede devolver un máximo de 1.000 entidades al mismo tiempo y se puede ejecutar durante un máximo de cinco segundos.</span><span class="sxs-lookup"><span data-stu-id="1425b-873">A query against the table service may return a maximum of 1,000 entities at one time and may execute for a maximum of five seconds.</span></span> <span data-ttu-id="1425b-874">Si el conjunto de resultados contiene más de 1.000 entidades, si la consulta no se completa antes de cinco segundos, o si la consulta cruza el límite de partición, Table service devuelve un token de continuación para habilitar la aplicación cliente para solicitar el siguiente conjunto de entidades.</span><span class="sxs-lookup"><span data-stu-id="1425b-874">If the result set contains more than 1,000 entities, if the query did not complete within five seconds, or if the query crosses the partition boundary, the Table service returns a continuation token to enable the client application to request the next set of entities.</span></span> <span data-ttu-id="1425b-875">Para más información sobre el funcionamiento de los tokens de continuación, consulte [Tiempo de espera de consulta y paginación](http://msdn.microsoft.com/library/azure/dd135718.aspx).</span><span class="sxs-lookup"><span data-stu-id="1425b-875">For more information about how continuation tokens work, see [Query Timeout and Pagination](http://msdn.microsoft.com/library/azure/dd135718.aspx).</span></span>  

<span data-ttu-id="1425b-876">Si utiliza la biblioteca de clientes de Storage, puede controlar automáticamente los tokens de continuación cuando devuelve entidades de Table service.</span><span class="sxs-lookup"><span data-stu-id="1425b-876">If you are using the Storage Client Library, it can automatically handle continuation tokens for you as it returns entities from the Table service.</span></span> <span data-ttu-id="1425b-877">El siguiente ejemplo de código de C# que utiliza la biblioteca de clientes de Storage maneja automáticamente tokens de continuación si Table service los devuelve en una respuesta:</span><span class="sxs-lookup"><span data-stu-id="1425b-877">The following C# code sample using the Storage Client Library automatically handles continuation tokens if the table service returns them in a response:</span></span>  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

var employees = employeeTable.ExecuteQuery(employeeQuery);
foreach (var emp in employees)
{
        ...
}  
```

<span data-ttu-id="1425b-878">El siguiente código C# administra los tokens de continuación explícitamente:</span><span class="sxs-lookup"><span data-stu-id="1425b-878">The following C# code handles continuation tokens explicitly:</span></span>  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

TableContinuationToken continuationToken = null;

do
{
        var employees = employeeTable.ExecuteQuerySegmented(
        employeeQuery, continuationToken);
    foreach (var emp in employees)
    {
    ...
    }
    continuationToken = employees.ContinuationToken;
} while (continuationToken != null);  
```

<span data-ttu-id="1425b-879">Mediante el uso de tokens de continuación explícitamente, puede controlar cuando recupera la aplicación el siguiente segmento de datos.</span><span class="sxs-lookup"><span data-stu-id="1425b-879">By using continuation tokens explicitly, you can control when your application retrieves the next segment of data.</span></span> <span data-ttu-id="1425b-880">Por ejemplo, si la aplicación cliente permite a los usuarios desplazarse por las entidades que se almacenan en una tabla, un usuario puede decidir no desplazarse a través de todas las entidades recuperadas por la consulta, por lo que la aplicación solo usaría un token de continuación para recuperar el siguiente segmento cuando el usuario hubiese terminado la paginación a través de todas las entidades en el segmento actual.</span><span class="sxs-lookup"><span data-stu-id="1425b-880">For example, if your client application enables users to page through the entities stored in a table, a user may decide not to page through all the entities retrieved by the query so your application would only use a continuation token to retrieve the next segment when the user had finished paging through all the entities in the current segment.</span></span> <span data-ttu-id="1425b-881">Este enfoque tiene varias ventajas:</span><span class="sxs-lookup"><span data-stu-id="1425b-881">This approach has several benefits:</span></span>  

* <span data-ttu-id="1425b-882">Le permite limitar la cantidad de datos que desea recuperar de Table service y desplazarse a través de la red.</span><span class="sxs-lookup"><span data-stu-id="1425b-882">It enables you to limit the amount of data to retrieve from the Table service and that you move over the network.</span></span>  
* <span data-ttu-id="1425b-883">Le permite realizar E/S asincrónicas en. NET.</span><span class="sxs-lookup"><span data-stu-id="1425b-883">It enables you to perform asynchronous IO in .NET.</span></span>  
* <span data-ttu-id="1425b-884">Le permite serializar el token de continuación en un almacenamiento persistente para que pueda continuar en caso de un bloqueo de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="1425b-884">It enables you to serialize the continuation token to persistent storage so you can continue in the event of an application crash.</span></span>  

> [!NOTE]
> <span data-ttu-id="1425b-885">Normalmente, un token de continuación devuelve un segmento que contiene 1.000 entidades, aunque pueden ser menos.</span><span class="sxs-lookup"><span data-stu-id="1425b-885">A continuation token typically returns a segment containing 1,000 entities, although it may be fewer.</span></span> <span data-ttu-id="1425b-886">Esto también sucede si se limita el número de entradas que devuelve una consulta mediante el uso de **Take** para devolver las n primeras entidades que cumplen los criterios de búsqueda: Table service puede devolver un segmento que contenga menos de n entidades, junto con un token de continuación que permita recuperar las entidades restantes.</span><span class="sxs-lookup"><span data-stu-id="1425b-886">This is also the case if you limit the number of entries a query returns by using **Take** to return the first n entities that match your lookup criteria: the table service may return a segment containing fewer than n entities along with a continuation token to enable you to retrieve the remaining entities.</span></span>  
> 
> 

<span data-ttu-id="1425b-887">El siguiente código de C# muestra cómo modificar el número de entidades devueltas dentro de un segmento:</span><span class="sxs-lookup"><span data-stu-id="1425b-887">The following C# code shows how to modify the number of entities returned inside a segment:</span></span>  

```csharp
employeeQuery.TakeCount = 50;  
```

#### <a name="server-side-projection"></a><span data-ttu-id="1425b-888">Proyección de servidor</span><span class="sxs-lookup"><span data-stu-id="1425b-888">Server-side projection</span></span>
<span data-ttu-id="1425b-889">Una sola entidad puede tener hasta 255 propiedades y ocupar hasta 1 MB.</span><span class="sxs-lookup"><span data-stu-id="1425b-889">A single entity can have up to 255 properties and be up to 1 MB in size.</span></span> <span data-ttu-id="1425b-890">Al consultar la tabla y recuperar las entidades, puede que no necesite todas las propiedades y puede evitar la transferencia de datos innecesariamente (para ayudar a reducir la latencia y el coste).</span><span class="sxs-lookup"><span data-stu-id="1425b-890">When you query the table and retrieve entities, you may not need all the properties and can avoid transferring data unnecessarily (to help reduce latency and cost).</span></span> <span data-ttu-id="1425b-891">Puede usar proyección de servidor para transferir solo las propiedades que necesita.</span><span class="sxs-lookup"><span data-stu-id="1425b-891">You can use server-side projection to transfer just the properties you need.</span></span> <span data-ttu-id="1425b-892">En el ejemplo siguiente se recupera solo la propiedad **Email** (junto con **PartitionKey**, **RowKey**, **Timestamp** y **ETag**) de las entidades seleccionadas por la consulta.</span><span class="sxs-lookup"><span data-stu-id="1425b-892">The following example is retrieves just the **Email** property (along with **PartitionKey**, **RowKey**, **Timestamp**, and **ETag**) from the entities selected by the query.</span></span>  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
List<string> columns = new List<string>() { "Email" };
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter).Select(columns);

var entities = employeeTable.ExecuteQuery(employeeQuery);
foreach (var e in entities)
{
        Console.WriteLine("RowKey: {0}, EmployeeEmail: {1}", e.RowKey, e.Email);
}  
```

<span data-ttu-id="1425b-893">Observe que el valor **RowKey** está disponible incluso no se incluyó en la lista de propiedades a recuperar.</span><span class="sxs-lookup"><span data-stu-id="1425b-893">Notice how the **RowKey** value is available even though it was not included in the list of properties to retrieve.</span></span>  

### <a name="modifying-entities"></a><span data-ttu-id="1425b-894">Modificación de entidades</span><span class="sxs-lookup"><span data-stu-id="1425b-894">Modifying entities</span></span>
<span data-ttu-id="1425b-895">La biblioteca de clientes de Storage permite modificar las entidades almacenadas en Table service, insertando, eliminando y actualizando entidades.</span><span class="sxs-lookup"><span data-stu-id="1425b-895">The Storage Client Library enables you to modify your entities stored in the table service by inserting, deleting, and updating entities.</span></span> <span data-ttu-id="1425b-896">Puede usar EGT para procesar por lotes varias operaciones de inserción, actualización y eliminación conjuntamente para reducir el número de viajes de ida y vuelta requeridos y mejorar el rendimiento de la solución.</span><span class="sxs-lookup"><span data-stu-id="1425b-896">You can use EGTs to batch multiple insert, update, and delete operations together to reduce the number of round trips required and improve the performance of your solution.</span></span>  

<span data-ttu-id="1425b-897">Tenga en cuenta que entre las excepciones que se producen cuando la biblioteca de clientes de Storage ejecuta un EGT normalmente se incluyen el índice de la entidad que ha provocado el error del lote.</span><span class="sxs-lookup"><span data-stu-id="1425b-897">Note that exceptions thrown when the Storage Client Library executes an EGT typically include the index of the entity that caused the batch to fail.</span></span> <span data-ttu-id="1425b-898">Esto resulta útil cuando se depura código que usa EGT.</span><span class="sxs-lookup"><span data-stu-id="1425b-898">This is helpful when you are debugging code that uses EGTs.</span></span>  

<span data-ttu-id="1425b-899">También debe considerar cómo afecta su diseño a la forma en que la aplicación cliente trata las operaciones de simultaneidad y actualización.</span><span class="sxs-lookup"><span data-stu-id="1425b-899">You should also consider how your design affects how your client application handles concurrency and update operations.</span></span>  

#### <a name="managing-concurrency"></a><span data-ttu-id="1425b-900">Administrar la simultaneidad</span><span class="sxs-lookup"><span data-stu-id="1425b-900">Managing concurrency</span></span>
<span data-ttu-id="1425b-901">De forma predeterminada, Table service implementa comprobaciones de simultaneidad optimista en el nivel de entidades individuales para las operaciones **Insertar**, **Combinar** y **Eliminar**, aunque es posible que un cliente fuerce a Table service a omitir estas comprobaciones.</span><span class="sxs-lookup"><span data-stu-id="1425b-901">By default, the table service implements optimistic concurrency checks at the level of individual entities for **Insert**, **Merge**, and **Delete** operations, although it is possible for a client to force the table service to bypass these checks.</span></span> <span data-ttu-id="1425b-902">Para más información sobre cómo Table service administra la simultaneidad, consulte [Administración de la simultaneidad en Microsoft Azure Storage](storage-concurrency.md).</span><span class="sxs-lookup"><span data-stu-id="1425b-902">For more information about how the table service manages concurrency, see  [Managing Concurrency in Microsoft Azure Storage](storage-concurrency.md).</span></span>  

#### <a name="merge-or-replace"></a><span data-ttu-id="1425b-903">Combinar o reemplazar</span><span class="sxs-lookup"><span data-stu-id="1425b-903">Merge or replace</span></span>
<span data-ttu-id="1425b-904">El método **Replace** de la clase **TableOperation** siempre reemplaza toda la entidad en Table service.</span><span class="sxs-lookup"><span data-stu-id="1425b-904">The **Replace** method of the **TableOperation** class always replaces the complete entity in the Table service.</span></span> <span data-ttu-id="1425b-905">Si no incluye una propiedad en la solicitud cuando esa propiedad existe en la entidad almacenada, la solicitud quita esa propiedad de la entidad almacenada.</span><span class="sxs-lookup"><span data-stu-id="1425b-905">If you do not include a property in the request when that property exists in the stored entity, the request removes that property from the stored entity.</span></span> <span data-ttu-id="1425b-906">A menos que desee quitar una propiedad de forma explícita de entidad almacenada, debe incluir todas las propiedades en la solicitud.</span><span class="sxs-lookup"><span data-stu-id="1425b-906">Unless you want to remove a property explicitly from a stored entity, you must include every property in the request.</span></span>  

<span data-ttu-id="1425b-907">Puede utilizar el método **Merge** de la clase **TableOperation** para reducir la cantidad de datos que envía a Table service si desea actualizar una entidad.</span><span class="sxs-lookup"><span data-stu-id="1425b-907">You can use the **Merge** method of the **TableOperation** class to reduce the amount of data that you send to the Table service when you want to update an entity.</span></span> <span data-ttu-id="1425b-908">El método **Merge** reemplaza cualquier propiedad de la entidad almacenada por valores de propiedad de la entidad que se incluyen en la solicitud, pero deja intactas las propiedades de la entidad almacenada no incluidas en la solicitud.</span><span class="sxs-lookup"><span data-stu-id="1425b-908">The **Merge** method replaces any properties in the stored entity with property values from the entity included in the request, but leaves intact any properties in the stored entity that are not included in the request.</span></span> <span data-ttu-id="1425b-909">Esto es útil si tiene entidades de gran tamaño y solo tiene que actualizar un pequeño número de propiedades en una solicitud.</span><span class="sxs-lookup"><span data-stu-id="1425b-909">This is useful if you have large entities and only need to update a small number of properties in a request.</span></span>  

> [!NOTE]
> <span data-ttu-id="1425b-910">Los métodos **Replace** y **Merge** generarán un error si la entidad no existe.</span><span class="sxs-lookup"><span data-stu-id="1425b-910">The **Replace** and **Merge** methods fail if the entity does not exist.</span></span> <span data-ttu-id="1425b-911">Como alternativa, puede usar los métodos **InsertOrReplace** e **InsertOrMerge**, que crean una nueva entidad si todavía no existe.</span><span class="sxs-lookup"><span data-stu-id="1425b-911">As an alternative, you can use the **InsertOrReplace** and **InsertOrMerge** methods that create a new entity if it doesn't exist.</span></span>  
> 
> 

### <a name="working-with-heterogeneous-entity-types"></a><span data-ttu-id="1425b-912">Trabajar con tipos de entidad heterogéneos</span><span class="sxs-lookup"><span data-stu-id="1425b-912">Working with heterogeneous entity types</span></span>
<span data-ttu-id="1425b-913">Table service es un almacenamiento de tablas *sin esquema*, lo que significa que una sola tabla puede almacenar entidades de varios tipos, lo que proporciona gran flexibilidad en el diseño.</span><span class="sxs-lookup"><span data-stu-id="1425b-913">The Table service is a *schema-less* table store that means that a single table can store entities of multiple types providing great flexibility in your design.</span></span> <span data-ttu-id="1425b-914">En el ejemplo siguiente se muestra una tabla que almacena entidades de empleado y de departamento:</span><span class="sxs-lookup"><span data-stu-id="1425b-914">The following example illustrates a table storing both employee and department entities:</span></span>  

<table>
<tr>
<th><span data-ttu-id="1425b-915">PartitionKey</span><span class="sxs-lookup"><span data-stu-id="1425b-915">PartitionKey</span></span></th>
<th><span data-ttu-id="1425b-916">RowKey</span><span class="sxs-lookup"><span data-stu-id="1425b-916">RowKey</span></span></th>
<th><span data-ttu-id="1425b-917">Timestamp</span><span class="sxs-lookup"><span data-stu-id="1425b-917">Timestamp</span></span></th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="1425b-918">Nombre</span><span class="sxs-lookup"><span data-stu-id="1425b-918">FirstName</span></span></th>
<th><span data-ttu-id="1425b-919">Apellidos</span><span class="sxs-lookup"><span data-stu-id="1425b-919">LastName</span></span></th>
<th><span data-ttu-id="1425b-920">Edad</span><span class="sxs-lookup"><span data-stu-id="1425b-920">Age</span></span></th>
<th><span data-ttu-id="1425b-921">Email</span><span class="sxs-lookup"><span data-stu-id="1425b-921">Email</span></span></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="1425b-922">Nombre</span><span class="sxs-lookup"><span data-stu-id="1425b-922">FirstName</span></span></th>
<th><span data-ttu-id="1425b-923">Apellidos</span><span class="sxs-lookup"><span data-stu-id="1425b-923">LastName</span></span></th>
<th><span data-ttu-id="1425b-924">Edad</span><span class="sxs-lookup"><span data-stu-id="1425b-924">Age</span></span></th>
<th><span data-ttu-id="1425b-925">Email</span><span class="sxs-lookup"><span data-stu-id="1425b-925">Email</span></span></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="1425b-926">DepartmentName</span><span class="sxs-lookup"><span data-stu-id="1425b-926">DepartmentName</span></span></th>
<th><span data-ttu-id="1425b-927">EmployeeCount</span><span class="sxs-lookup"><span data-stu-id="1425b-927">EmployeeCount</span></span></th>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="1425b-928">Nombre</span><span class="sxs-lookup"><span data-stu-id="1425b-928">FirstName</span></span></th>
<th><span data-ttu-id="1425b-929">Apellidos</span><span class="sxs-lookup"><span data-stu-id="1425b-929">LastName</span></span></th>
<th><span data-ttu-id="1425b-930">Edad</span><span class="sxs-lookup"><span data-stu-id="1425b-930">Age</span></span></th>
<th><span data-ttu-id="1425b-931">Email</span><span class="sxs-lookup"><span data-stu-id="1425b-931">Email</span></span></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

<span data-ttu-id="1425b-932">Tenga en cuenta que cada entidad aún debe tener valores **PartitionKey**, **RowKey** y **Timestamp**, pero puede tener cualquier conjunto de propiedades.</span><span class="sxs-lookup"><span data-stu-id="1425b-932">Note that each entity must still have **PartitionKey**, **RowKey**, and **Timestamp** values, but may have any set of properties.</span></span> <span data-ttu-id="1425b-933">Además, no hay nada que indique el tipo de una entidad a menos que elija almacenar esa información en algún lugar.</span><span class="sxs-lookup"><span data-stu-id="1425b-933">Furthermore, there is nothing to indicate the type of an entity unless you choose to store that information somewhere.</span></span> <span data-ttu-id="1425b-934">Hay dos opciones para identificar el tipo de entidad:</span><span class="sxs-lookup"><span data-stu-id="1425b-934">There are two options for identifying the entity type:</span></span>  

* <span data-ttu-id="1425b-935">Anteponer el tipo de entidad al valor **RowKey** (o posiblemente a **PartitionKey**).</span><span class="sxs-lookup"><span data-stu-id="1425b-935">Prepend the entity type to the **RowKey** (or possibly the **PartitionKey**).</span></span> <span data-ttu-id="1425b-936">Por ejemplo, **EMPLOYEE_000123** o **DEPARTMENT_SALES** como valores **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="1425b-936">For example, **EMPLOYEE_000123** or **DEPARTMENT_SALES** as **RowKey** values.</span></span>  
* <span data-ttu-id="1425b-937">Utilice una propiedad independiente para registrar el tipo de entidad como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="1425b-937">Use a separate property to record the entity type as shown in the table below.</span></span>  

<table>
<tr>
<th><span data-ttu-id="1425b-938">PartitionKey</span><span class="sxs-lookup"><span data-stu-id="1425b-938">PartitionKey</span></span></th>
<th><span data-ttu-id="1425b-939">RowKey</span><span class="sxs-lookup"><span data-stu-id="1425b-939">RowKey</span></span></th>
<th><span data-ttu-id="1425b-940">Timestamp</span><span class="sxs-lookup"><span data-stu-id="1425b-940">Timestamp</span></span></th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="1425b-941">EntityType</span><span class="sxs-lookup"><span data-stu-id="1425b-941">EntityType</span></span></th>
<th><span data-ttu-id="1425b-942">Nombre</span><span class="sxs-lookup"><span data-stu-id="1425b-942">FirstName</span></span></th>
<th><span data-ttu-id="1425b-943">Apellidos</span><span class="sxs-lookup"><span data-stu-id="1425b-943">LastName</span></span></th>
<th><span data-ttu-id="1425b-944">Edad</span><span class="sxs-lookup"><span data-stu-id="1425b-944">Age</span></span></th>
<th><span data-ttu-id="1425b-945">Email</span><span class="sxs-lookup"><span data-stu-id="1425b-945">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="1425b-946">Employee</span><span class="sxs-lookup"><span data-stu-id="1425b-946">Employee</span></span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="1425b-947">EntityType</span><span class="sxs-lookup"><span data-stu-id="1425b-947">EntityType</span></span></th>
<th><span data-ttu-id="1425b-948">Nombre</span><span class="sxs-lookup"><span data-stu-id="1425b-948">FirstName</span></span></th>
<th><span data-ttu-id="1425b-949">Apellidos</span><span class="sxs-lookup"><span data-stu-id="1425b-949">LastName</span></span></th>
<th><span data-ttu-id="1425b-950">Edad</span><span class="sxs-lookup"><span data-stu-id="1425b-950">Age</span></span></th>
<th><span data-ttu-id="1425b-951">Email</span><span class="sxs-lookup"><span data-stu-id="1425b-951">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="1425b-952">Employee</span><span class="sxs-lookup"><span data-stu-id="1425b-952">Employee</span></span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="1425b-953">EntityType</span><span class="sxs-lookup"><span data-stu-id="1425b-953">EntityType</span></span></th>
<th><span data-ttu-id="1425b-954">DepartmentName</span><span class="sxs-lookup"><span data-stu-id="1425b-954">DepartmentName</span></span></th>
<th><span data-ttu-id="1425b-955">EmployeeCount</span><span class="sxs-lookup"><span data-stu-id="1425b-955">EmployeeCount</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="1425b-956">department</span><span class="sxs-lookup"><span data-stu-id="1425b-956">Department</span></span></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th><span data-ttu-id="1425b-957">EntityType</span><span class="sxs-lookup"><span data-stu-id="1425b-957">EntityType</span></span></th>
<th><span data-ttu-id="1425b-958">Nombre</span><span class="sxs-lookup"><span data-stu-id="1425b-958">FirstName</span></span></th>
<th><span data-ttu-id="1425b-959">Apellidos</span><span class="sxs-lookup"><span data-stu-id="1425b-959">LastName</span></span></th>
<th><span data-ttu-id="1425b-960">Edad</span><span class="sxs-lookup"><span data-stu-id="1425b-960">Age</span></span></th>
<th><span data-ttu-id="1425b-961">Email</span><span class="sxs-lookup"><span data-stu-id="1425b-961">Email</span></span></th>
</tr>
<tr>
<td><span data-ttu-id="1425b-962">Employee</span><span class="sxs-lookup"><span data-stu-id="1425b-962">Employee</span></span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

<span data-ttu-id="1425b-963">La primera opción, anteponer el tipo de entidad a **RowKey**, resulta útil si existe la posibilidad de que dos entidades de tipos diferentes tengan el mismo valor de clave.</span><span class="sxs-lookup"><span data-stu-id="1425b-963">The first option, prepending the entity type to the **RowKey**, is useful if there is a possibility that two entities of different types might have the same key value.</span></span> <span data-ttu-id="1425b-964">También agrupa las entidades del mismo tipo juntas en la partición.</span><span class="sxs-lookup"><span data-stu-id="1425b-964">It also groups entities of the same type together in the partition.</span></span>  

<span data-ttu-id="1425b-965">Las técnicas que se describen en esta sección son especialmente relevantes en el tema [Relaciones de herencia](#inheritance-relationships), que ya ha aparecido en esta guía, en la sección [Relaciones de modelos](#modelling-relationships).</span><span class="sxs-lookup"><span data-stu-id="1425b-965">The techniques discussed in this section are especially relevant to the discussion [Inheritance relationships](#inheritance-relationships) earlier in this guide in the section [Modelling relationships](#modelling-relationships).</span></span>  

> [!NOTE]
> <span data-ttu-id="1425b-966">Considere la posibilidad de incluir un número de versión en el valor de tipo de entidad para permitir a las aplicaciones de cliente evolucionar objetos POCO y trabajar con distintas versiones.</span><span class="sxs-lookup"><span data-stu-id="1425b-966">You should consider including a version number in the entity type value to enable client applications to evolve POCO objects and work with different versions.</span></span>  
> 
> 

<span data-ttu-id="1425b-967">En el resto de esta sección se describen algunas de las características de la biblioteca de clientes de Storage que facilitan el trabajo con varios tipos de entidad en la misma tabla.</span><span class="sxs-lookup"><span data-stu-id="1425b-967">The remainder of this section describes some of the features in the Storage Client Library that facilitate working with multiple entity types in the same table.</span></span>  

#### <a name="retrieving-heterogeneous-entity-types"></a><span data-ttu-id="1425b-968">Recuperar tipos de entidad heterogéneos</span><span class="sxs-lookup"><span data-stu-id="1425b-968">Retrieving heterogeneous entity types</span></span>
<span data-ttu-id="1425b-969">Si utiliza la biblioteca de clientes de Storage, tiene tres opciones para trabajar con varios tipos de entidad.</span><span class="sxs-lookup"><span data-stu-id="1425b-969">If you are using the Storage Client Library, you have three options for working with multiple entity types.</span></span>  

<span data-ttu-id="1425b-970">Si conoce el tipo de la entidad que se almacena con un valor concreto **RowKey** y **PartitionKey**, podrá especificar el tipo de entidad al recuperar la entidad, como se muestra en los dos ejemplos anteriores que recuperan entidades de tipo **EmployeeEntity**: [Ejecutar una consulta de punto mediante la biblioteca de clientes de Storage](#executing-a-point-query-using-the-storage-client-library) y [Recuperar varias entidades con LINQ](#retrieving-multiple-entities-using-linq).</span><span class="sxs-lookup"><span data-stu-id="1425b-970">If you know the type of the entity stored with a specific **RowKey** and **PartitionKey** values, then you can specify the entity type when you retrieve the entity as shown in the previous two examples that retrieve entities of type **EmployeeEntity**: [Executing a point query using the Storage Client Library](#executing-a-point-query-using-the-storage-client-library) and [Retrieving multiple entities using LINQ](#retrieving-multiple-entities-using-linq).</span></span>  

<span data-ttu-id="1425b-971">La segunda opción es usar el tipo **DynamicTableEntity** (un contenedor de propiedades), en lugar de un tipo concreto de entidad POCO (esta opción también puede mejorar el rendimiento, ya que no es preciso serializar y deserializar la entidad de los tipos .NET).</span><span class="sxs-lookup"><span data-stu-id="1425b-971">The second option is to use the **DynamicTableEntity** type (a property bag) instead of a concrete POCO entity type (this option may also improve performance because there is no need to serialize and deserialize the entity to .NET types).</span></span> <span data-ttu-id="1425b-972">Potencialmente, el siguiente código de C# recupera varias entidades de distintos tipos de la tabla, pero devuelve todas las entidades como instancias de **DynamicTableEntity**.</span><span class="sxs-lookup"><span data-stu-id="1425b-972">The following C# code potentially retrieves multiple entities of different types from the table, but returns all entities as **DynamicTableEntity** instances.</span></span> <span data-ttu-id="1425b-973">A continuación, usa la propiedad **EntityType** para determinar el tipo de cada entidad:</span><span class="sxs-lookup"><span data-stu-id="1425b-973">It then uses the **EntityType** property to determine the type of each entity:</span></span>  

```csharp
string filter = TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("PartitionKey",
    QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("RowKey",
                    QueryComparisons.GreaterThanOrEqual, "B"),
        TableOperators.And,
        TableQuery.GenerateFilterCondition("RowKey",
        QueryComparisons.LessThan, "F")
    )
);
TableQuery<DynamicTableEntity> entityQuery =
    new TableQuery<DynamicTableEntity>().Where(filter);
var employees = employeeTable.ExecuteQuery(entityQuery);

IEnumerable<DynamicTableEntity> entities = employeeTable.ExecuteQuery(entityQuery);
foreach (var e in entities)
{
EntityProperty entityTypeProperty;
if (e.Properties.TryGetValue("EntityType", out entityTypeProperty))
{
    if (entityTypeProperty.StringValue == "Employee")
    {
        // Use entityTypeProperty, RowKey, PartitionKey, Etag, and Timestamp
        }
    }
}  
```

<span data-ttu-id="1425b-974">Tenga en cuenta que para recuperar otras propiedades debe utilizar el método **TryGetValue** en la propiedad **Properties** de la clase **DynamicTableEntity**.</span><span class="sxs-lookup"><span data-stu-id="1425b-974">Note that to retrieve other properties you must use the **TryGetValue** method on the **Properties** property of the **DynamicTableEntity** class.</span></span>  

<span data-ttu-id="1425b-975">Una tercera opción consiste en combinar el tipo **DynamicTableEntity** con una instancia de **EntityResolver**.</span><span class="sxs-lookup"><span data-stu-id="1425b-975">A third option is to combine using the **DynamicTableEntity** type and an **EntityResolver** instance.</span></span> <span data-ttu-id="1425b-976">Esto le permite resolver en varios tipos POCO en la misma consulta.</span><span class="sxs-lookup"><span data-stu-id="1425b-976">This enables you to resolve to multiple POCO types in the same query.</span></span> <span data-ttu-id="1425b-977">En este ejemplo, el delegado **EntityResolver** usa la propiedad **EntityType** para distinguir entre los dos tipos de entidad que devuelve la consulta.</span><span class="sxs-lookup"><span data-stu-id="1425b-977">In this example, the **EntityResolver** delegate is using the **EntityType** property to distinguish between the two types of entity that the query returns.</span></span> <span data-ttu-id="1425b-978">El método **Resolve** usa el delegado **resolver** para resolver instancias de **DynamicTableEntity** en instancias de **TableEntity**.</span><span class="sxs-lookup"><span data-stu-id="1425b-978">The **Resolve** method uses the **resolver** delegate to resolve **DynamicTableEntity** instances to **TableEntity** instances.</span></span>  

```csharp
EntityResolver<TableEntity> resolver = (pk, rk, ts, props, etag) =>
{

        TableEntity resolvedEntity = null;
        if (props["EntityType"].StringValue == "Department")
        {
        resolvedEntity = new DepartmentEntity();
        }
        else if (props["EntityType"].StringValue == "Employee")
        {
        resolvedEntity = new EmployeeEntity();
        }
        else throw new ArgumentException("Unrecognized entity", "props");

        resolvedEntity.PartitionKey = pk;
        resolvedEntity.RowKey = rk;
        resolvedEntity.Timestamp = ts;
        resolvedEntity.ETag = etag;
        resolvedEntity.ReadEntity(props, null);
        return resolvedEntity;
};

string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<DynamicTableEntity> entityQuery =
        new TableQuery<DynamicTableEntity>().Where(filter);

var entities = employeeTable.ExecuteQuery(entityQuery, resolver);
foreach (var e in entities)
{
        if (e is DepartmentEntity)
        {
    ...
        }
        if (e is EmployeeEntity)
        {
    ...
        }
}  
```

#### <a name="modifying-heterogeneous-entity-types"></a><span data-ttu-id="1425b-979">Modificar tipos de entidad heterogéneos</span><span class="sxs-lookup"><span data-stu-id="1425b-979">Modifying heterogeneous entity types</span></span>
<span data-ttu-id="1425b-980">No es necesario conocer el tipo de una entidad para eliminarla, y siempre sabe el tipo de una entidad al insertarla.</span><span class="sxs-lookup"><span data-stu-id="1425b-980">You do not need to know the type of an entity to delete it, and you always know the type of an entity when you insert it.</span></span> <span data-ttu-id="1425b-981">Sin embargo, puede usar el tipo **DynamicTableEntity** para actualizar una entidad sin conocer su tipo y sin utilizar una clase de entidad POCO.</span><span class="sxs-lookup"><span data-stu-id="1425b-981">However, you can use **DynamicTableEntity** type to update an entity without knowing its type and without using a POCO entity class.</span></span> <span data-ttu-id="1425b-982">En el código de ejemplo siguiente se recupera una entidad individual y comprueba que la propiedad **EmployeeCount** existe antes de actualizarla.</span><span class="sxs-lookup"><span data-stu-id="1425b-982">The following code sample retrieves a single entity, and checks the **EmployeeCount** property exists before updating it.</span></span>  

```csharp
TableResult result =
        employeeTable.Execute(TableOperation.Retrieve(partitionKey, rowKey));
DynamicTableEntity department = (DynamicTableEntity)result.Result;

EntityProperty countProperty;

if (!department.Properties.TryGetValue("EmployeeCount", out countProperty))
{
        throw new
        InvalidOperationException("Invalid entity, EmployeeCount property not found.");
}
countProperty.Int32Value += 1;
employeeTable.Execute(TableOperation.Merge(department));  
```

### <a name="controlling-access-with-shared-access-signatures"></a><span data-ttu-id="1425b-983">Control de acceso con firmas de acceso compartido</span><span class="sxs-lookup"><span data-stu-id="1425b-983">Controlling access with Shared Access Signatures</span></span>
<span data-ttu-id="1425b-984">Puede utilizar tokens de firma de acceso compartido (SAS) para permitir a las aplicaciones de cliente modificar (y consultar) entidades de tabla directamente sin necesidad de autenticarse directamente con Table service.</span><span class="sxs-lookup"><span data-stu-id="1425b-984">You can use Shared Access Signature (SAS) tokens to enable client applications to modify (and query) table entities directly without the need to authenticate directly with the table service.</span></span> <span data-ttu-id="1425b-985">Normalmente, hay tres ventajas principales de utilizar SAS en su aplicación:</span><span class="sxs-lookup"><span data-stu-id="1425b-985">Typically, there are three main benefits to using SAS in your application:</span></span>  

* <span data-ttu-id="1425b-986">No es necesario distribuir la clave de la cuenta de almacenamiento a una plataforma no segura (por ejemplo, un dispositivo móvil) para permitir que ese dispositivo acceda y modifique entidades en Table service.</span><span class="sxs-lookup"><span data-stu-id="1425b-986">You do not need to distribute your storage account key to an insecure platform (such as a mobile device) in order to allow that device to access and modify entities in the Table service.</span></span>  
* <span data-ttu-id="1425b-987">Puede descargar parte del trabajo que realizan los roles de web y trabajador en la administración de las entidades en dispositivos cliente como los equipos de usuario final y los dispositivos móviles.</span><span class="sxs-lookup"><span data-stu-id="1425b-987">You can offload some of the work that web and worker roles perform in managing your entities to client devices such as end-user computers and mobile devices.</span></span>  
* <span data-ttu-id="1425b-988">Puede asignar un conjunto de permisos restringido y con limitación de tiempo a un cliente (por ejemplo, para permitir el acceso de solo lectura a recursos específicos).</span><span class="sxs-lookup"><span data-stu-id="1425b-988">You can assign a constrained and time limited set of permissions to a client (such as allowing read-only access to specific resources).</span></span>  

<span data-ttu-id="1425b-989">Para más información sobre el uso de tokens de SAS con Table service, consulte [Uso de Firmas de acceso compartido (SAS)](storage-dotnet-shared-access-signature-part-1.md).</span><span class="sxs-lookup"><span data-stu-id="1425b-989">For more information about using SAS tokens with the Table service, see [Using Shared Access Signatures (SAS)](storage-dotnet-shared-access-signature-part-1.md).</span></span>  

<span data-ttu-id="1425b-990">Sin embargo, todavía debe generar los tokens SAS que concedan una aplicación cliente a las entidades en Table service: debe hacerlo en un entorno que tenga acceso seguro a las claves de cuenta de almacenamiento.</span><span class="sxs-lookup"><span data-stu-id="1425b-990">However, you must still generate the SAS tokens that grant a client application to the entities in the table service: you should do this in an environment that has secure access to your storage account keys.</span></span> <span data-ttu-id="1425b-991">Normalmente, se utiliza un rol web o de trabajador para generar los tokens SAS y entregarlos a las aplicaciones cliente que necesitan tener acceso a las entidades.</span><span class="sxs-lookup"><span data-stu-id="1425b-991">Typically, you use a web or worker role to generate the SAS tokens and deliver them to the client applications that need access to your entities.</span></span> <span data-ttu-id="1425b-992">Dado que todavía hay una sobrecarga implicada en la generación y entrega tokens SAS a los clientes, debería considerar cómo reducir mejor esta sobrecarga, especialmente en escenarios de gran volumen.</span><span class="sxs-lookup"><span data-stu-id="1425b-992">Because there is still an overhead involved in generating and delivering SAS tokens to clients, you should consider how best to reduce this overhead, especially in high-volume scenarios.</span></span>  

<span data-ttu-id="1425b-993">Es posible generar un token SAS que conceda acceso a un subconjunto de las entidades de una tabla.</span><span class="sxs-lookup"><span data-stu-id="1425b-993">It is possible to generate a SAS token that grants access to a subset of the entities in a table.</span></span> <span data-ttu-id="1425b-994">De forma predeterminada, se crea un token SAS para toda la tabla, pero también es posible especificar que el token SAS conceda acceso a un intervalo de valores **PartitionKey** o a un intervalo de valores **PartitionKey** y **RowKey**.</span><span class="sxs-lookup"><span data-stu-id="1425b-994">By default, you create a SAS token for an entire table, but it is also possible to specify that the SAS token grant access to either a range of **PartitionKey** values, or a range of **PartitionKey** and **RowKey** values.</span></span> <span data-ttu-id="1425b-995">Puede elegir generar tokens de SAS para usuarios individuales del sistema, de forma que el token de SAS de cada usuario solo les permita acceder a sus propias entidades en Table service.</span><span class="sxs-lookup"><span data-stu-id="1425b-995">You might choose to generate SAS tokens for individual users of your system such that each user's SAS token only allows them access to their own entities in the table service.</span></span>  

### <a name="asynchronous-and-parallel-operations"></a><span data-ttu-id="1425b-996">Operaciones asincrónicas y paralelas</span><span class="sxs-lookup"><span data-stu-id="1425b-996">Asynchronous and parallel operations</span></span>
<span data-ttu-id="1425b-997">En caso de que reparta las solicitudes entre varias particiones, puede mejorar el rendimiento y la capacidad de respuesta del cliente mediante consultas asincrónicas o paralelas.</span><span class="sxs-lookup"><span data-stu-id="1425b-997">Provided you are spreading your requests across multiple partitions, you can improve throughput and client responsiveness by using asynchronous or parallel queries.</span></span>
<span data-ttu-id="1425b-998">Por ejemplo, podría tener dos o más instancias de rol de trabajo con acceso a las tablas en paralelo.</span><span class="sxs-lookup"><span data-stu-id="1425b-998">For example, you might have two or more worker role instances accessing your tables in parallel.</span></span> <span data-ttu-id="1425b-999">Podría tiene roles de trabajador individual responsables de determinados conjuntos de particiones, o simplemente tener varias instancias de rol de trabajo, cada una de ellas con acceso a todas las particiones de una tabla.</span><span class="sxs-lookup"><span data-stu-id="1425b-999">You could have individual worker roles responsible for particular sets of partitions, or simply have multiple worker role instances, each able to access all the partitions in a table.</span></span>  

<span data-ttu-id="1425b-1000">Dentro de una instancia de cliente, puede mejorar el rendimiento mediante la ejecución de operaciones de almacenamiento de forma asincrónica.</span><span class="sxs-lookup"><span data-stu-id="1425b-1000">Within a client instance, you can improve throughput by executing storage operations asynchronously.</span></span> <span data-ttu-id="1425b-1001">La biblioteca de clientes de Storage facilita la escritura de modificaciones y consultas asíncronas.</span><span class="sxs-lookup"><span data-stu-id="1425b-1001">The Storage Client Library makes it easy to write asynchronous queries and modifications.</span></span> <span data-ttu-id="1425b-1002">Por ejemplo, puede comenzar con el método sincrónico que recupera todas las entidades de una partición como se muestra en el siguiente código de C#:</span><span class="sxs-lookup"><span data-stu-id="1425b-1002">For example, you might start with the synchronous method that retrieves all the entities in a partition as shown in the following C# code:</span></span>  

```csharp
private static void ManyEntitiesQuery(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

        TableContinuationToken continuationToken = null;

        do
        {
        var employees = employeeTable.ExecuteQuerySegmented(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
    {
        ...
    }
        continuationToken = employees.ContinuationToken;
        } while (continuationToken != null);
}  
```

<span data-ttu-id="1425b-1003">Este código puede se modificar fácilmente para que la consulta se ejecute de forma asincrónica del modo siguiente:</span><span class="sxs-lookup"><span data-stu-id="1425b-1003">You can easily modify this code so that the query runs asynchronously as follows:</span></span>  

```csharp
private static async Task ManyEntitiesQueryAsync(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);
        TableContinuationToken continuationToken = null;

        do
        {
        var employees = await employeeTable.ExecuteQuerySegmentedAsync(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
        {
            ...
        }
        continuationToken = employees.ContinuationToken;
            } while (continuationToken != null);
}  
```

<span data-ttu-id="1425b-1004">En este ejemplo asincrónico, puede ver los cambios siguientes desde la versión sincrónica:</span><span class="sxs-lookup"><span data-stu-id="1425b-1004">In this asynchronous example, you can see the following changes from the synchronous version:</span></span>  

* <span data-ttu-id="1425b-1005">La firma del método incluye ahora el modificador **async** y devuelve una instancia de **Tarea**.</span><span class="sxs-lookup"><span data-stu-id="1425b-1005">The method signature now includes the **async** modifier and returns a **Task** instance.</span></span>  
* <span data-ttu-id="1425b-1006">En lugar de llamar al método **ExecuteSegmented** para recuperar los resultados, ahora el método llama al método **ExecuteSegmentedAsync** y usa el modificador **await** para recuperar resultados de forma asincrónica.</span><span class="sxs-lookup"><span data-stu-id="1425b-1006">Instead of calling the **ExecuteSegmented** method to retrieve results, the method now calls the **ExecuteSegmentedAsync** method and uses the **await** modifier to retrieve results asynchronously.</span></span>  

<span data-ttu-id="1425b-1007">La aplicación cliente puede llamar a este método varias veces (con valores diferentes en el parámetro **department** ) y cada consulta se ejecutará en un subproceso independiente.</span><span class="sxs-lookup"><span data-stu-id="1425b-1007">The client application can call this method multiple times (with different values for the **department** parameter), and each query will run on a separate thread.</span></span>  

<span data-ttu-id="1425b-1008">Tenga en cuenta que no hay ninguna versión asincrónica del método **Execute** en la clase **TableQuery** porque la interfaz **IEnumerable** no admite la enumeración asincrónica.</span><span class="sxs-lookup"><span data-stu-id="1425b-1008">Note that there is no asynchronous version of the **Execute** method in the **TableQuery** class because the **IEnumerable** interface does not support asynchronous enumeration.</span></span>  

<span data-ttu-id="1425b-1009">También puede insertar, actualizar y eliminar entidades de forma asincrónica.</span><span class="sxs-lookup"><span data-stu-id="1425b-1009">You can also insert, update, and delete entities asynchronously.</span></span> <span data-ttu-id="1425b-1010">En el ejemplo de C# siguiente se muestra un método sencillo y sincrónico para insertar o reemplazar una entidad de empleado:</span><span class="sxs-lookup"><span data-stu-id="1425b-1010">The following C# example shows a simple, synchronous method to insert or replace an employee entity:</span></span>  

```csharp
private static void SimpleEmployeeUpsert(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = employeeTable
        .Execute(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

<span data-ttu-id="1425b-1011">Este código se puede modificar fácilmente para que la actualización se ejecute de forma asincrónica del modo siguiente:</span><span class="sxs-lookup"><span data-stu-id="1425b-1011">You can easily modify this code so that the update runs asynchronously as follows:</span></span>  

```csharp
private static async Task SimpleEmployeeUpsertAsync(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = await employeeTable
        .ExecuteAsync(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

<span data-ttu-id="1425b-1012">En este ejemplo asincrónico, puede ver los cambios siguientes desde la versión sincrónica:</span><span class="sxs-lookup"><span data-stu-id="1425b-1012">In this asynchronous example, you can see the following changes from the synchronous version:</span></span>  

* <span data-ttu-id="1425b-1013">La firma del método incluye ahora el modificador **async** y devuelve una instancia de **Tarea**.</span><span class="sxs-lookup"><span data-stu-id="1425b-1013">The method signature now includes the **async** modifier and returns a **Task** instance.</span></span>  
* <span data-ttu-id="1425b-1014">En lugar de llamar al método **Execute** para actualizar la entidad, el método llama al método **ExecuteAsync** y usa el modificador **await** para recuperar resultados de forma asincrónica.</span><span class="sxs-lookup"><span data-stu-id="1425b-1014">Instead of calling the **Execute** method to update the entity, the method now calls the **ExecuteAsync** method and uses the **await** modifier to retrieve results asynchronously.</span></span>  

<span data-ttu-id="1425b-1015">La aplicación cliente puede llamar a varios métodos asincrónicos como este, y cada invocación de método se ejecutará en un subproceso independiente.</span><span class="sxs-lookup"><span data-stu-id="1425b-1015">The client application can call multiple asynchronous methods like this one, and each method invocation will run on a separate thread.</span></span>  

### <a name="credits"></a><span data-ttu-id="1425b-1016">Créditos</span><span class="sxs-lookup"><span data-stu-id="1425b-1016">Credits</span></span>
<span data-ttu-id="1425b-1017">Nos gustaría dar las gracias a los siguientes miembros del equipo de Azure por sus contribuciones: Dominic Betts, Jason Hogg, Jean Ghanem, Jai Haridas, Jeff Irwin, Vamshidhar Kommineni, Vinay Shah y Serdar Ozler, así como Tom Hollander de Microsoft DX.</span><span class="sxs-lookup"><span data-stu-id="1425b-1017">We would like to thank the following members of the Azure team for their contributions: Dominic Betts, Jason Hogg, Jean Ghanem, Jai Haridas, Jeff Irwin, Vamshidhar Kommineni, Vinay Shah and Serdar Ozler as well as  Tom Hollander from Microsoft DX.</span></span> 

<span data-ttu-id="1425b-1018">También nos gustaría dar las gracias a los siguientes MVP de Microsoft por sus valiosos comentarios durante los ciclos de revisión: Igor Papirov y Edward Bakker.</span><span class="sxs-lookup"><span data-stu-id="1425b-1018">We would also like to thank the following Microsoft MVP's for their valuable feedback during review cycles: Igor Papirov and Edward Bakker.</span></span>

[1]: ./media/storage-table-design-guide/storage-table-design-IMAGE01.png
[2]: ./media/storage-table-design-guide/storage-table-design-IMAGE02.png
[3]: ./media/storage-table-design-guide/storage-table-design-IMAGE03.png
[4]: ./media/storage-table-design-guide/storage-table-design-IMAGE04.png
[5]: ./media/storage-table-design-guide/storage-table-design-IMAGE05.png
[6]: ./media/storage-table-design-guide/storage-table-design-IMAGE06.png
[7]: ./media/storage-table-design-guide/storage-table-design-IMAGE07.png
[8]: ./media/storage-table-design-guide/storage-table-design-IMAGE08.png
[9]: ./media/storage-table-design-guide/storage-table-design-IMAGE09.png
[10]: ./media/storage-table-design-guide/storage-table-design-IMAGE10.png
[11]: ./media/storage-table-design-guide/storage-table-design-IMAGE11.png
[12]: ./media/storage-table-design-guide/storage-table-design-IMAGE12.png
[13]: ./media/storage-table-design-guide/storage-table-design-IMAGE13.png
[14]: ./media/storage-table-design-guide/storage-table-design-IMAGE14.png
[15]: ./media/storage-table-design-guide/storage-table-design-IMAGE15.png
[16]: ./media/storage-table-design-guide/storage-table-design-IMAGE16.png
[17]: ./media/storage-table-design-guide/storage-table-design-IMAGE17.png
[18]: ./media/storage-table-design-guide/storage-table-design-IMAGE18.png
[19]: ./media/storage-table-design-guide/storage-table-design-IMAGE19.png
[20]: ./media/storage-table-design-guide/storage-table-design-IMAGE20.png
[21]: ./media/storage-table-design-guide/storage-table-design-IMAGE21.png
[22]: ./media/storage-table-design-guide/storage-table-design-IMAGE22.png
[23]: ./media/storage-table-design-guide/storage-table-design-IMAGE23.png
[24]: ./media/storage-table-design-guide/storage-table-design-IMAGE24.png
[25]: ./media/storage-table-design-guide/storage-table-design-IMAGE25.png
[26]: ./media/storage-table-design-guide/storage-table-design-IMAGE26.png
[27]: ./media/storage-table-design-guide/storage-table-design-IMAGE27.png
[28]: ./media/storage-table-design-guide/storage-table-design-IMAGE28.png
[29]: ./media/storage-table-design-guide/storage-table-design-IMAGE29.png

