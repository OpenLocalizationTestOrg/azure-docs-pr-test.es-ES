---
title: "Lista de comprobación de rendimiento y escalabilidad de Azure Storage | Microsoft Docs"
description: "Lista de comprobación de prácticas probadas para su uso con Azure Storage para desarrollar aplicaciones de alto rendimiento."
services: storage
documentationcenter: 
author: robinsh
manager: timlt
editor: tysonn
ms.assetid: 959d831b-a4fd-4634-a646-0d2c0c462ef8
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 12/08/2016
ms.author: robinsh
ms.openlocfilehash: d2683bf9a2833485467bf2b4edff527876102f7d
ms.sourcegitcommit: 18ad9bc049589c8e44ed277f8f43dcaa483f3339
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/29/2017
---
# <a name="microsoft-azure-storage-performance-and-scalability-checklist"></a><span data-ttu-id="77afa-103">Lista de comprobación de rendimiento y escalabilidad de Microsoft Azure Storage</span><span class="sxs-lookup"><span data-stu-id="77afa-103">Microsoft Azure Storage Performance and Scalability Checklist</span></span>
## <a name="overview"></a><span data-ttu-id="77afa-104">Información general</span><span class="sxs-lookup"><span data-stu-id="77afa-104">Overview</span></span>
<span data-ttu-id="77afa-105">Desde el lanzamiento de los servicios de Microsoft Azure Storage, Microsoft ha desarrollado numerosos procedimientos para usar estos servicios de una manera eficiente. Este artículo pretende consolidar lo más importante de ellos en una lista de tipo “lista de comprobación”.</span><span class="sxs-lookup"><span data-stu-id="77afa-105">Since the release of the Microsoft Azure Storage services, Microsoft has developed a number of proven practices for using these services in a performant manner, and this article serves to consolidate the most important of them into a checklist-style list.</span></span> <span data-ttu-id="77afa-106">El objetivo de este artículo es ayudar a los desarrolladores de aplicaciones a comprobar que están usando prácticas probadas con Azure Storage y ayudarles a identificar otras prácticas probadas cuya adopción deben plantearse.</span><span class="sxs-lookup"><span data-stu-id="77afa-106">The intention of this article is to help application developers verify they are using proven practices with Azure Storage and to help them identify other proven practices they should consider adopting.</span></span> <span data-ttu-id="77afa-107">Este artículo no pretende cubrir todas las posibilidades de rendimiento y escalabilidad posibles y excluye aquellas cuyo impacto es pequeño o tienen poco margen de aplicación.</span><span class="sxs-lookup"><span data-stu-id="77afa-107">This article does not attempt to cover every possible performance and scalability optimization — it excludes those that are small in their impact or not broadly applicable.</span></span> <span data-ttu-id="77afa-108">En la medida en que el comportamiento de la aplicación se puede predecir durante el diseño, es útil recordar esto en las primeras etapas para evitar diseños que tengan problemas de rendimiento.</span><span class="sxs-lookup"><span data-stu-id="77afa-108">To the extent that the application's behavior can be predicted during design, it's useful to keep these in mind early on to avoid designs that will run into performance problems.</span></span>  

<span data-ttu-id="77afa-109">Todos los desarrolladores de aplicaciones que usen Azure Storage deben invertir tiempo en leer este artículo y comprobar que su aplicación sigue todas las prácticas probadas que se enumeran a continuación.</span><span class="sxs-lookup"><span data-stu-id="77afa-109">Every application developer using Azure Storage should take the time to read this article, and check that his or her application follows each of the proven practices listed below.</span></span>  

## <a name="checklist"></a><span data-ttu-id="77afa-110">Lista de comprobación</span><span class="sxs-lookup"><span data-stu-id="77afa-110">Checklist</span></span>
<span data-ttu-id="77afa-111">Este artículo organiza las prácticas probadas en los siguientes grupos.</span><span class="sxs-lookup"><span data-stu-id="77afa-111">This article organizes the proven practices into the following groups.</span></span> <span data-ttu-id="77afa-112">Prácticas probadas aplicables a:</span><span class="sxs-lookup"><span data-stu-id="77afa-112">Proven practices applicable to:</span></span>  

* <span data-ttu-id="77afa-113">Todos los servicios de Azure Storage (Blob, Table, Queue y Files)</span><span class="sxs-lookup"><span data-stu-id="77afa-113">All Azure Storage services (blobs, tables, queues, and files)</span></span>
* <span data-ttu-id="77afa-114">Blobs</span><span class="sxs-lookup"><span data-stu-id="77afa-114">Blobs</span></span>
* <span data-ttu-id="77afa-115">Tablas</span><span class="sxs-lookup"><span data-stu-id="77afa-115">Tables</span></span>
* <span data-ttu-id="77afa-116">Colas</span><span class="sxs-lookup"><span data-stu-id="77afa-116">Queues</span></span>  

| <span data-ttu-id="77afa-117">¡Listo!</span><span class="sxs-lookup"><span data-stu-id="77afa-117">Done</span></span> | <span data-ttu-id="77afa-118">Ámbito</span><span class="sxs-lookup"><span data-stu-id="77afa-118">Area</span></span> | <span data-ttu-id="77afa-119">Categoría</span><span class="sxs-lookup"><span data-stu-id="77afa-119">Category</span></span> | <span data-ttu-id="77afa-120">Pregunta</span><span class="sxs-lookup"><span data-stu-id="77afa-120">Question</span></span> |
| --- | --- | --- | --- |
| &nbsp; | <span data-ttu-id="77afa-121">Todos los servicios</span><span class="sxs-lookup"><span data-stu-id="77afa-121">All Services</span></span> |<span data-ttu-id="77afa-122">Objetivos de escalabilidad</span><span class="sxs-lookup"><span data-stu-id="77afa-122">Scalability Targets</span></span> |[<span data-ttu-id="77afa-123">¿Está su aplicación diseñada para evitar aproximarse a los objetivos de escalabilidad?</span><span class="sxs-lookup"><span data-stu-id="77afa-123">Is your application designed to avoid approaching the scalability targets?</span></span>](#subheading1) |
| &nbsp; | <span data-ttu-id="77afa-124">Todos los servicios</span><span class="sxs-lookup"><span data-stu-id="77afa-124">All Services</span></span> |<span data-ttu-id="77afa-125">Objetivos de escalabilidad</span><span class="sxs-lookup"><span data-stu-id="77afa-125">Scalability Targets</span></span> |[<span data-ttu-id="77afa-126">Is your naming convention designed to enable better load-balancing? (¿Está su convención de nomenclatura diseñada para habilitar un mejor equilibrio de carga?)</span><span class="sxs-lookup"><span data-stu-id="77afa-126">Is your naming convention designed to enable better load-balancing?</span></span>](#subheading47) |
| &nbsp; | <span data-ttu-id="77afa-127">Todos los servicios</span><span class="sxs-lookup"><span data-stu-id="77afa-127">All Services</span></span> |<span data-ttu-id="77afa-128">Redes</span><span class="sxs-lookup"><span data-stu-id="77afa-128">Networking</span></span> |[<span data-ttu-id="77afa-129">¿Tienen los dispositivos del cliente un ancho de banda grande y una latencia baja suficientes como para lograr el rendimiento necesario?</span><span class="sxs-lookup"><span data-stu-id="77afa-129">Do client side devices have sufficiently high bandwidth and low latency to achieve the performance needed?</span></span>](#subheading2) |
| &nbsp; | <span data-ttu-id="77afa-130">Todos los servicios</span><span class="sxs-lookup"><span data-stu-id="77afa-130">All Services</span></span> |<span data-ttu-id="77afa-131">Redes</span><span class="sxs-lookup"><span data-stu-id="77afa-131">Networking</span></span> |[<span data-ttu-id="77afa-132">¿Tienen los dispositivos del lado cliente un enlace con una calidad suficientemente alta?</span><span class="sxs-lookup"><span data-stu-id="77afa-132">Do client side devices have a high enough quality link?</span></span>](#subheading3) |
| &nbsp; | <span data-ttu-id="77afa-133">Todos los servicios</span><span class="sxs-lookup"><span data-stu-id="77afa-133">All Services</span></span> |<span data-ttu-id="77afa-134">Redes</span><span class="sxs-lookup"><span data-stu-id="77afa-134">Networking</span></span> |[<span data-ttu-id="77afa-135">¿Está la aplicación cliente ubicada "cerca" de la cuenta de almacenamiento?</span><span class="sxs-lookup"><span data-stu-id="77afa-135">Is the client application located "near" the storage account?</span></span>](#subheading4) |
| &nbsp; | <span data-ttu-id="77afa-136">Todos los servicios</span><span class="sxs-lookup"><span data-stu-id="77afa-136">All Services</span></span> |<span data-ttu-id="77afa-137">Distribución de contenido</span><span class="sxs-lookup"><span data-stu-id="77afa-137">Content Distribution</span></span> |[<span data-ttu-id="77afa-138">¿Usa una red CDN para distribución de contenido?</span><span class="sxs-lookup"><span data-stu-id="77afa-138">Are you using a CDN for content distribution?</span></span>](#subheading5) |
| &nbsp; | <span data-ttu-id="77afa-139">Todos los servicios</span><span class="sxs-lookup"><span data-stu-id="77afa-139">All Services</span></span> |<span data-ttu-id="77afa-140">Acceso directo del cliente</span><span class="sxs-lookup"><span data-stu-id="77afa-140">Direct Client Access</span></span> |[<span data-ttu-id="77afa-141">¿Usa SAS y CORS para permitir el acceso directo al almacenamiento en lugar de proxy?</span><span class="sxs-lookup"><span data-stu-id="77afa-141">Are you using SAS and CORS to allow direct access to storage instead of proxy?</span></span>](#subheading6) |
| &nbsp; | <span data-ttu-id="77afa-142">Todos los servicios</span><span class="sxs-lookup"><span data-stu-id="77afa-142">All Services</span></span> |<span data-ttu-id="77afa-143">Almacenamiento en caché</span><span class="sxs-lookup"><span data-stu-id="77afa-143">Caching</span></span> |[<span data-ttu-id="77afa-144">¿Su aplicación almacena datos en caché que se usan repetidamente y rara vez cambian?</span><span class="sxs-lookup"><span data-stu-id="77afa-144">Is your application caching data that is repeatedly used and changes rarely?</span></span>](#subheading7) |
| &nbsp; | <span data-ttu-id="77afa-145">Todos los servicios</span><span class="sxs-lookup"><span data-stu-id="77afa-145">All Services</span></span> |<span data-ttu-id="77afa-146">Almacenamiento en caché</span><span class="sxs-lookup"><span data-stu-id="77afa-146">Caching</span></span> |[<span data-ttu-id="77afa-147">¿Su aplicación procesa por lotes las actualizaciones (almacenándolas en caché en el cliente y, a continuación, cargándolas en conjuntos más grandes)?</span><span class="sxs-lookup"><span data-stu-id="77afa-147">Is your application batching updates (caching them client side and then uploading in larger sets)?</span></span>](#subheading8) |
| &nbsp; | <span data-ttu-id="77afa-148">Todos los servicios</span><span class="sxs-lookup"><span data-stu-id="77afa-148">All Services</span></span> |<span data-ttu-id="77afa-149">Configuración .NET</span><span class="sxs-lookup"><span data-stu-id="77afa-149">.NET Configuration</span></span> |[<span data-ttu-id="77afa-150">¿Ha configurado el cliente para usar un número suficiente de conexiones simultáneas?</span><span class="sxs-lookup"><span data-stu-id="77afa-150">Have you configured your client to use a sufficient number of concurrent connections?</span></span>](#subheading9) |
| &nbsp; | <span data-ttu-id="77afa-151">Todos los servicios</span><span class="sxs-lookup"><span data-stu-id="77afa-151">All Services</span></span> |<span data-ttu-id="77afa-152">Configuración .NET</span><span class="sxs-lookup"><span data-stu-id="77afa-152">.NET Configuration</span></span> |[<span data-ttu-id="77afa-153">¿Ha configurado .NET para usar un número suficiente de subprocesos?</span><span class="sxs-lookup"><span data-stu-id="77afa-153">Have you configured .NET to use a sufficient number of threads?</span></span>](#subheading10) |
| &nbsp; | <span data-ttu-id="77afa-154">Todos los servicios</span><span class="sxs-lookup"><span data-stu-id="77afa-154">All Services</span></span> |<span data-ttu-id="77afa-155">Configuración .NET</span><span class="sxs-lookup"><span data-stu-id="77afa-155">.NET Configuration</span></span> |[<span data-ttu-id="77afa-156">¿Usa .NET 4.5 o posterior, que ha mejorado la recolección de elementos no usados?</span><span class="sxs-lookup"><span data-stu-id="77afa-156">Are you using .NET 4.5 or later, which has improved garbage collection?</span></span>](#subheading11) |
| &nbsp; | <span data-ttu-id="77afa-157">Todos los servicios</span><span class="sxs-lookup"><span data-stu-id="77afa-157">All Services</span></span> |<span data-ttu-id="77afa-158">Paralelismo</span><span class="sxs-lookup"><span data-stu-id="77afa-158">Parallelism</span></span> |[<span data-ttu-id="77afa-159">¿Se ha asegurado de que el paralelismo está vinculado correctamente de forma que no se sobrecarguen las funcionalidades del cliente o los objetivos de escalabilidad?</span><span class="sxs-lookup"><span data-stu-id="77afa-159">Have you ensured that parallelism is bounded appropriately so that you don't overload either your client capabilities or the scalability targets?</span></span>](#subheading12) |
| &nbsp; | <span data-ttu-id="77afa-160">Todos los servicios</span><span class="sxs-lookup"><span data-stu-id="77afa-160">All Services</span></span> |<span data-ttu-id="77afa-161">Herramientas</span><span class="sxs-lookup"><span data-stu-id="77afa-161">Tools</span></span> |[<span data-ttu-id="77afa-162">¿Usa la versión más reciente de las herramientas y bibliotecas de cliente proporcionadas por Microsoft?</span><span class="sxs-lookup"><span data-stu-id="77afa-162">Are you using the latest version of Microsoft provided client libraries and tools?</span></span>](#subheading13) |
| &nbsp; | <span data-ttu-id="77afa-163">Todos los servicios</span><span class="sxs-lookup"><span data-stu-id="77afa-163">All Services</span></span> |<span data-ttu-id="77afa-164">Reintentos</span><span class="sxs-lookup"><span data-stu-id="77afa-164">Retries</span></span> |[<span data-ttu-id="77afa-165">¿Usa una directiva de reintentos de retroceso exponencial para errores de limitación y tiempos de espera?</span><span class="sxs-lookup"><span data-stu-id="77afa-165">Are you using an exponential backoff retry policy for throttling errors and timeouts?</span></span>](#subheading14) |
| &nbsp; | <span data-ttu-id="77afa-166">Todos los servicios</span><span class="sxs-lookup"><span data-stu-id="77afa-166">All Services</span></span> |<span data-ttu-id="77afa-167">Reintentos</span><span class="sxs-lookup"><span data-stu-id="77afa-167">Retries</span></span> |[<span data-ttu-id="77afa-168">¿Evita su aplicación reintentos para errores que no se pueden reintentar?</span><span class="sxs-lookup"><span data-stu-id="77afa-168">Is your application avoiding retries for non-retryable errors?</span></span>](#subheading15) |
| &nbsp; | <span data-ttu-id="77afa-169">Blobs</span><span class="sxs-lookup"><span data-stu-id="77afa-169">Blobs</span></span> |<span data-ttu-id="77afa-170">Objetivos de escalabilidad</span><span class="sxs-lookup"><span data-stu-id="77afa-170">Scalability Targets</span></span> |[<span data-ttu-id="77afa-171">¿Tiene un gran número de clientes que acceden simultáneamente a un único objeto?</span><span class="sxs-lookup"><span data-stu-id="77afa-171">Do you have a large number of clients accessing a single object concurrently?</span></span>](#subheading46) |
| &nbsp; | <span data-ttu-id="77afa-172">Blobs</span><span class="sxs-lookup"><span data-stu-id="77afa-172">Blobs</span></span> |<span data-ttu-id="77afa-173">Objetivos de escalabilidad</span><span class="sxs-lookup"><span data-stu-id="77afa-173">Scalability Targets</span></span> |[<span data-ttu-id="77afa-174">¿Permanece su aplicación dentro del ancho de banda o de los objetivos de escalabilidad de las operaciones para un solo blob?</span><span class="sxs-lookup"><span data-stu-id="77afa-174">Is your application staying within the bandwidth or operations scalability target for a single blob?</span></span>](#subheading16) |
| &nbsp; | <span data-ttu-id="77afa-175">Blobs</span><span class="sxs-lookup"><span data-stu-id="77afa-175">Blobs</span></span> |<span data-ttu-id="77afa-176">Copia de blobs</span><span class="sxs-lookup"><span data-stu-id="77afa-176">Copying Blobs</span></span> |[<span data-ttu-id="77afa-177">¿Copia blobs de una manera eficiente?</span><span class="sxs-lookup"><span data-stu-id="77afa-177">Are you copying blobs in an efficient manner?</span></span>](#subheading17) |
| &nbsp; | <span data-ttu-id="77afa-178">Blobs</span><span class="sxs-lookup"><span data-stu-id="77afa-178">Blobs</span></span> |<span data-ttu-id="77afa-179">Copia de blobs</span><span class="sxs-lookup"><span data-stu-id="77afa-179">Copying Blobs</span></span> |[<span data-ttu-id="77afa-180">¿Usa AzCopy para copias de blobs en masa?</span><span class="sxs-lookup"><span data-stu-id="77afa-180">Are you using AzCopy for bulk copies of blobs?</span></span>](#subheading18) |
| &nbsp; | <span data-ttu-id="77afa-181">Blobs</span><span class="sxs-lookup"><span data-stu-id="77afa-181">Blobs</span></span> |<span data-ttu-id="77afa-182">Copia de blobs</span><span class="sxs-lookup"><span data-stu-id="77afa-182">Copying Blobs</span></span> |[<span data-ttu-id="77afa-183">¿Usa Microsoft Azure Import/Export para transferir grandes volúmenes de datos?</span><span class="sxs-lookup"><span data-stu-id="77afa-183">Are you using Azure Import/Export to transfer very large volumes of data?</span></span>](#subheading19) |
| &nbsp; | <span data-ttu-id="77afa-184">Blobs</span><span class="sxs-lookup"><span data-stu-id="77afa-184">Blobs</span></span> |<span data-ttu-id="77afa-185">Usar metadatos</span><span class="sxs-lookup"><span data-stu-id="77afa-185">Use Metadata</span></span> |[<span data-ttu-id="77afa-186">¿Almacena metadatos usados frecuentemente acerca de blobs en los metadatos de estos?</span><span class="sxs-lookup"><span data-stu-id="77afa-186">Are you storing frequently used metadata about blobs in their metadata?</span></span>](#subheading20) |
| &nbsp; | <span data-ttu-id="77afa-187">Blobs</span><span class="sxs-lookup"><span data-stu-id="77afa-187">Blobs</span></span> |<span data-ttu-id="77afa-188">Carga rápida</span><span class="sxs-lookup"><span data-stu-id="77afa-188">Uploading Fast</span></span> |[<span data-ttu-id="77afa-189">Cuando intenta cargar un blob rápidamente, ¿carga blobs en paralelo?</span><span class="sxs-lookup"><span data-stu-id="77afa-189">When trying to upload one blob quickly, are you uploading blocks in parallel?</span></span>](#subheading21) |
| &nbsp; | <span data-ttu-id="77afa-190">Blobs</span><span class="sxs-lookup"><span data-stu-id="77afa-190">Blobs</span></span> |<span data-ttu-id="77afa-191">Carga rápida</span><span class="sxs-lookup"><span data-stu-id="77afa-191">Uploading Fast</span></span> |[<span data-ttu-id="77afa-192">Cuando intenta cargar muchos blobs rápidamente, ¿carga blobs en paralelo?</span><span class="sxs-lookup"><span data-stu-id="77afa-192">When trying to upload many blobs quickly, are you uploading blobs in parallel?</span></span>](#subheading22) |
| &nbsp; | <span data-ttu-id="77afa-193">Blobs</span><span class="sxs-lookup"><span data-stu-id="77afa-193">Blobs</span></span> |<span data-ttu-id="77afa-194">Tipo de blob correcto</span><span class="sxs-lookup"><span data-stu-id="77afa-194">Correct Blob Type</span></span> |[<span data-ttu-id="77afa-195">¿Usa blobs en páginas o blobs en bloques cuando es apropiado?</span><span class="sxs-lookup"><span data-stu-id="77afa-195">Are you using page blobs or block blobs when appropriate?</span></span>](#subheading23) |
| &nbsp; | <span data-ttu-id="77afa-196">Tablas</span><span class="sxs-lookup"><span data-stu-id="77afa-196">Tables</span></span> |<span data-ttu-id="77afa-197">Objetivos de escalabilidad</span><span class="sxs-lookup"><span data-stu-id="77afa-197">Scalability Targets</span></span> |[<span data-ttu-id="77afa-198">¿Se aproxima a los objetivos de escalabilidad para entidades por segundo?</span><span class="sxs-lookup"><span data-stu-id="77afa-198">Are you approaching the scalability targets for entities per second?</span></span>](#subheading24) |
| &nbsp; | <span data-ttu-id="77afa-199">Tablas</span><span class="sxs-lookup"><span data-stu-id="77afa-199">Tables</span></span> |<span data-ttu-id="77afa-200">Configuración</span><span class="sxs-lookup"><span data-stu-id="77afa-200">Configuration</span></span> |[<span data-ttu-id="77afa-201">¿Usa JSON para sus solicitudes de tabla?</span><span class="sxs-lookup"><span data-stu-id="77afa-201">Are you using JSON for your table requests?</span></span>](#subheading25) |
| &nbsp; | <span data-ttu-id="77afa-202">Tablas</span><span class="sxs-lookup"><span data-stu-id="77afa-202">Tables</span></span> |<span data-ttu-id="77afa-203">Configuración</span><span class="sxs-lookup"><span data-stu-id="77afa-203">Configuration</span></span> |[<span data-ttu-id="77afa-204">¿Ha desactivado el algoritmo de Nagle para mejorar el rendimiento de solicitudes pequeñas?</span><span class="sxs-lookup"><span data-stu-id="77afa-204">Have you turned Nagle off to improve the performance of small requests?</span></span>](#subheading26) |
| &nbsp; | <span data-ttu-id="77afa-205">Tablas</span><span class="sxs-lookup"><span data-stu-id="77afa-205">Tables</span></span> |<span data-ttu-id="77afa-206">Tablas y particiones</span><span class="sxs-lookup"><span data-stu-id="77afa-206">Tables and Partitions</span></span> |[<span data-ttu-id="77afa-207">¿Ha particionado sus datos correctamente?</span><span class="sxs-lookup"><span data-stu-id="77afa-207">Have you properly partitioned your data?</span></span>](#subheading27) |
| &nbsp; | <span data-ttu-id="77afa-208">Tablas</span><span class="sxs-lookup"><span data-stu-id="77afa-208">Tables</span></span> |<span data-ttu-id="77afa-209">Particiones calientes</span><span class="sxs-lookup"><span data-stu-id="77afa-209">Hot Partitions</span></span> |[<span data-ttu-id="77afa-210">¿Evita los patrones Solo anexar y Solo anteponer?</span><span class="sxs-lookup"><span data-stu-id="77afa-210">Are you avoiding append-only and prepend-only patterns?</span></span>](#subheading28) |
| &nbsp; | <span data-ttu-id="77afa-211">Tablas</span><span class="sxs-lookup"><span data-stu-id="77afa-211">Tables</span></span> |<span data-ttu-id="77afa-212">Particiones calientes</span><span class="sxs-lookup"><span data-stu-id="77afa-212">Hot Partitions</span></span> |[<span data-ttu-id="77afa-213">¿Se despliegan sus inserciones y actualizaciones por muchas particiones?</span><span class="sxs-lookup"><span data-stu-id="77afa-213">Are your inserts/updates spread across many partitions?</span></span>](#subheading29) |
| &nbsp; | <span data-ttu-id="77afa-214">Tablas</span><span class="sxs-lookup"><span data-stu-id="77afa-214">Tables</span></span> |<span data-ttu-id="77afa-215">Ámbito de las consultas</span><span class="sxs-lookup"><span data-stu-id="77afa-215">Query Scope</span></span> |[<span data-ttu-id="77afa-216">¿Ha diseñado su esquema para permitir el uso de consultas puntuales en la mayoría de los casos y el uso de consultas de tabla con moderación?</span><span class="sxs-lookup"><span data-stu-id="77afa-216">Have you designed your schema to allow for point queries to be used in most cases, and table queries to be used sparingly?</span></span>](#subheading30) |
| &nbsp; | <span data-ttu-id="77afa-217">Tablas</span><span class="sxs-lookup"><span data-stu-id="77afa-217">Tables</span></span> |<span data-ttu-id="77afa-218">Densidad de las consultas</span><span class="sxs-lookup"><span data-stu-id="77afa-218">Query Density</span></span> |[<span data-ttu-id="77afa-219">¿Normalmente sus consultas solamente examinan y devuelven filas que usará su aplicación?</span><span class="sxs-lookup"><span data-stu-id="77afa-219">Do your queries typically only scan and return rows that your application will use?</span></span>](#subheading31) |
| &nbsp; | <span data-ttu-id="77afa-220">Tablas</span><span class="sxs-lookup"><span data-stu-id="77afa-220">Tables</span></span> |<span data-ttu-id="77afa-221">Limitación de datos devueltos</span><span class="sxs-lookup"><span data-stu-id="77afa-221">Limiting Returned Data</span></span> |[<span data-ttu-id="77afa-222">¿Usa filtros para evitar la devolución de entidades que no se necesitan?</span><span class="sxs-lookup"><span data-stu-id="77afa-222">Are you using filtering to avoid returning entities that are not needed?</span></span>](#subheading32) |
| &nbsp; | <span data-ttu-id="77afa-223">Tablas</span><span class="sxs-lookup"><span data-stu-id="77afa-223">Tables</span></span> |<span data-ttu-id="77afa-224">Limitación de datos devueltos</span><span class="sxs-lookup"><span data-stu-id="77afa-224">Limiting Returned Data</span></span> |[<span data-ttu-id="77afa-225">¿Usa proyección para evitar la devolución de propiedades que no se necesitan?</span><span class="sxs-lookup"><span data-stu-id="77afa-225">Are you using projection to avoid returning properties that are not needed?</span></span>](#subheading33) |
| &nbsp; | <span data-ttu-id="77afa-226">Tablas</span><span class="sxs-lookup"><span data-stu-id="77afa-226">Tables</span></span> |<span data-ttu-id="77afa-227">Desnormalización</span><span class="sxs-lookup"><span data-stu-id="77afa-227">Denormalization</span></span> |[<span data-ttu-id="77afa-228">¿Ha desnormalizado los datos de forma que evite consultas ineficientes o varias solicitudes de lectura cuando intenta obtener datos?</span><span class="sxs-lookup"><span data-stu-id="77afa-228">Have you denormalized your data such that you avoid inefficient queries or multiple read requests when trying to get data?</span></span>](#subheading34) |
| &nbsp; | <span data-ttu-id="77afa-229">Tablas</span><span class="sxs-lookup"><span data-stu-id="77afa-229">Tables</span></span> |<span data-ttu-id="77afa-230">Inserción, actualización y eliminación</span><span class="sxs-lookup"><span data-stu-id="77afa-230">Insert/Update/Delete</span></span> |[<span data-ttu-id="77afa-231">¿Procesa por lotes solicitudes que necesitan ser transaccionales o se pueden realizar al mismo tiempo para reducir recorridos de ida y vuelta?</span><span class="sxs-lookup"><span data-stu-id="77afa-231">Are you batching requests that need to be transactional or can be done at the same time to reduce round-trips?</span></span>](#subheading35) |
| &nbsp; | <span data-ttu-id="77afa-232">Tablas</span><span class="sxs-lookup"><span data-stu-id="77afa-232">Tables</span></span> |<span data-ttu-id="77afa-233">Inserción, actualización y eliminación</span><span class="sxs-lookup"><span data-stu-id="77afa-233">Insert/Update/Delete</span></span> |[<span data-ttu-id="77afa-234">¿Evita la recuperación de una entidad simplemente para determinar si llama a la inserción o a la actualización?</span><span class="sxs-lookup"><span data-stu-id="77afa-234">Are you avoiding retrieving an entity just to determine whether to call insert or update?</span></span>](#subheading36) |
| &nbsp; | <span data-ttu-id="77afa-235">Tablas</span><span class="sxs-lookup"><span data-stu-id="77afa-235">Tables</span></span> |<span data-ttu-id="77afa-236">Inserción, actualización y eliminación</span><span class="sxs-lookup"><span data-stu-id="77afa-236">Insert/Update/Delete</span></span> |[<span data-ttu-id="77afa-237">¿Ha pensado en almacenar series de datos que se recuperarán frecuentemente de forma conjunta en una sola entidad como propiedades en lugar de varias entidades?</span><span class="sxs-lookup"><span data-stu-id="77afa-237">Have you considered storing series of data that will frequently be retrieved together in a single entity as properties instead of multiple entities?</span></span>](#subheading37) |
| &nbsp; | <span data-ttu-id="77afa-238">Tablas</span><span class="sxs-lookup"><span data-stu-id="77afa-238">Tables</span></span> |<span data-ttu-id="77afa-239">Inserción, actualización y eliminación</span><span class="sxs-lookup"><span data-stu-id="77afa-239">Insert/Update/Delete</span></span> |[<span data-ttu-id="77afa-240">Para entidades que siempre se recuperarán conjuntamente y que se pueden escribir en lotes (por ejemplo, datos de serie de temporales), ¿ha pensado en usar blobs en lugar de tablas?</span><span class="sxs-lookup"><span data-stu-id="77afa-240">For entities that will always be retrieved together and can be written in batches (e.g. time series data), have you considered using blobs instead of tables?</span></span>](#subheading38) |
| &nbsp; | <span data-ttu-id="77afa-241">Colas</span><span class="sxs-lookup"><span data-stu-id="77afa-241">Queues</span></span> |<span data-ttu-id="77afa-242">Objetivos de escalabilidad</span><span class="sxs-lookup"><span data-stu-id="77afa-242">Scalability Targets</span></span> |[<span data-ttu-id="77afa-243">¿Se aproxima a los objetivos de escalabilidad para mensajes por segundo?</span><span class="sxs-lookup"><span data-stu-id="77afa-243">Are you approaching the scalability targets for messages per second?</span></span>](#subheading39) |
| &nbsp; | <span data-ttu-id="77afa-244">Colas</span><span class="sxs-lookup"><span data-stu-id="77afa-244">Queues</span></span> |<span data-ttu-id="77afa-245">Configuración</span><span class="sxs-lookup"><span data-stu-id="77afa-245">Configuration</span></span> |[<span data-ttu-id="77afa-246">¿Ha desactivado el algoritmo de Nagle para mejorar el rendimiento de solicitudes pequeñas?</span><span class="sxs-lookup"><span data-stu-id="77afa-246">Have you turned Nagle off to improve the performance of small requests?</span></span>](#subheading40) |
| &nbsp; | <span data-ttu-id="77afa-247">Colas</span><span class="sxs-lookup"><span data-stu-id="77afa-247">Queues</span></span> |<span data-ttu-id="77afa-248">Tamaño de los mensajes</span><span class="sxs-lookup"><span data-stu-id="77afa-248">Message Size</span></span> |[<span data-ttu-id="77afa-249">¿Son sus mensajes compactos para mejorar el rendimiento de la cola?</span><span class="sxs-lookup"><span data-stu-id="77afa-249">Are your messages compact to improve the performance of the queue?</span></span>](#subheading41) |
| &nbsp; | <span data-ttu-id="77afa-250">Colas</span><span class="sxs-lookup"><span data-stu-id="77afa-250">Queues</span></span> |<span data-ttu-id="77afa-251">Recuperación en masa</span><span class="sxs-lookup"><span data-stu-id="77afa-251">Bulk Retrieve</span></span> |[<span data-ttu-id="77afa-252">¿Recupera varios mensajes en una sola operación "Get"?</span><span class="sxs-lookup"><span data-stu-id="77afa-252">Are you retrieving multiple messages in a single "Get" operation?</span></span>](#subheading42) |
| &nbsp; | <span data-ttu-id="77afa-253">Colas</span><span class="sxs-lookup"><span data-stu-id="77afa-253">Queues</span></span> |<span data-ttu-id="77afa-254">Frecuencia de sondeo</span><span class="sxs-lookup"><span data-stu-id="77afa-254">Polling Frequency</span></span> |[<span data-ttu-id="77afa-255">¿Realiza sondeos con la suficiente frecuencia para reducir la latencia percibida de su aplicación?</span><span class="sxs-lookup"><span data-stu-id="77afa-255">Are you polling frequently enough to reduce the perceived latency of your application?</span></span>](#subheading43) |
| &nbsp; | <span data-ttu-id="77afa-256">Colas</span><span class="sxs-lookup"><span data-stu-id="77afa-256">Queues</span></span> |<span data-ttu-id="77afa-257">Actualizar mensaje</span><span class="sxs-lookup"><span data-stu-id="77afa-257">Update Message</span></span> |[<span data-ttu-id="77afa-258">¿Usa UpdateMessage para almacenar el progreso en mensajes de procesamiento evitando tener que volver a procesar todo el mensaje si se produce un error?</span><span class="sxs-lookup"><span data-stu-id="77afa-258">Are you using UpdateMessage to store progress in processing messages, avoiding having to reprocess the entire message if an error occurs?</span></span>](#subheading44) |
| &nbsp; | <span data-ttu-id="77afa-259">Colas</span><span class="sxs-lookup"><span data-stu-id="77afa-259">Queues</span></span> |<span data-ttu-id="77afa-260">Arquitectura</span><span class="sxs-lookup"><span data-stu-id="77afa-260">Architecture</span></span> |[<span data-ttu-id="77afa-261">¿Usa colas para hacer que toda su aplicación sea más escalable manteniendo cargas de trabajo de ejecución prolongada fuera de la ruta de acceso crítica y escala después de forma independiente?</span><span class="sxs-lookup"><span data-stu-id="77afa-261">Are you using queues to make your entire application more scalable by keeping long-running workloads out of the critical path and scale then independently?</span></span>](#subheading45) |

## <span data-ttu-id="77afa-262"><a name="allservices"></a>Todos los servicios</span><span class="sxs-lookup"><span data-stu-id="77afa-262"><a name="allservices"></a>All Services</span></span>
<span data-ttu-id="77afa-263">En esta sección se enumeran las prácticas probadas aplicables al uso de cualquier servicio de Azure Storage (Blob, Table, Queue o Files).</span><span class="sxs-lookup"><span data-stu-id="77afa-263">This section lists proven practices that are applicable to the use of any of the Azure Storage services (blobs, tables, queues, or files).</span></span>  

### <span data-ttu-id="77afa-264"><a name="subheading1"></a>Objetivos de escalabilidad</span><span class="sxs-lookup"><span data-stu-id="77afa-264"><a name="subheading1"></a>Scalability Targets</span></span>
<span data-ttu-id="77afa-265">Cada uno de los servicios de Azure Storage tiene objetivos de escalabilidad en lo que se refiere a capacidad (GB), tasa de transacciones y ancho de banda.</span><span class="sxs-lookup"><span data-stu-id="77afa-265">Each of the Azure Storage services has scalability targets for capacity (GB), transaction rate, and bandwidth.</span></span> <span data-ttu-id="77afa-266">Si su aplicación se aproxima o supera cualquiera de estos objetivos de escalabilidad, puede encontrar un aumento en la limitación o latencias de transacción.</span><span class="sxs-lookup"><span data-stu-id="77afa-266">If your application approaches or exceeds any of the scalability targets, it may encounter increased transaction latencies or throttling.</span></span> <span data-ttu-id="77afa-267">Cuando un servicio de Storage limita su aplicación, comienza a devolver códigos de error “503 Servidor ocupado” o “500 Tiempo de espera de la operación” en algunas transacciones de Storage.</span><span class="sxs-lookup"><span data-stu-id="77afa-267">When a Storage service throttles your application, the service begins to return "503 Server busy" or "500 Operation timeout" error codes for some storage transactions.</span></span> <span data-ttu-id="77afa-268">En esta sección se describen tanto el enfoque general para abordar los objetivos de escalabilidad como los objetivos de escalabilidad de ancho de banda en particular.</span><span class="sxs-lookup"><span data-stu-id="77afa-268">This section discusses both the general approach to dealing with scalability targets and bandwidth scalability targets in particular.</span></span> <span data-ttu-id="77afa-269">En secciones posteriores, que abordan cada uno de los servicios de Storage, se describen objetivos de escalabilidad en el contexto de ese servicio específico:</span><span class="sxs-lookup"><span data-stu-id="77afa-269">Later sections that deal with individual storage services discuss scalability targets in the context of that specific service:</span></span>  

* [<span data-ttu-id="77afa-270">Ancho de banda de blob y solicitudes por segundo</span><span class="sxs-lookup"><span data-stu-id="77afa-270">Blob bandwidth and requests per second</span></span>](#subheading16)
* [<span data-ttu-id="77afa-271">Entidades de tabla por segundo</span><span class="sxs-lookup"><span data-stu-id="77afa-271">Table entities per second</span></span>](#subheading24)
* [<span data-ttu-id="77afa-272">Mensajes de cola por segundo</span><span class="sxs-lookup"><span data-stu-id="77afa-272">Queue messages per second</span></span>](#subheading39)  

#### <span data-ttu-id="77afa-273"><a name="sub1bandwidth"></a>Objetivo de escalabilidad de ancho de banda para todos los servicios</span><span class="sxs-lookup"><span data-stu-id="77afa-273"><a name="sub1bandwidth"></a>Bandwidth Scalability Target for All Services</span></span>
<span data-ttu-id="77afa-274">En el momento de escribir estas líneas, los objetivos de ancho de banda en EE. UU. para una cuenta de almacenamiento con redundancia geográfica (GRS) son 10 gigabits por segundo (Gbps) para entrada (datos enviados a la cuenta de almacenamiento) y 20 Gbps para salida (datos enviados desde la cuenta de almacenamiento).</span><span class="sxs-lookup"><span data-stu-id="77afa-274">At the time of writing, the bandwidth targets in the US for a geo-redundant storage (GRS) account are 10 gigabits per second (Gbps) for ingress (data sent to the storage account) and 20 Gbps for egress (data sent from the storage account).</span></span> <span data-ttu-id="77afa-275">Para una cuenta de almacenamiento con redundancia local (LRS), los límites son mayores: 20 Gbps para entrada y 30 Gbps para salida.</span><span class="sxs-lookup"><span data-stu-id="77afa-275">For a locally redundant storage (LRS) account, the limits are higher – 20 Gbps for ingress and 30 Gbps for egress.</span></span>  <span data-ttu-id="77afa-276">Los límites de ancho de banda internacionales pueden ser menores y puede encontrarlos en nuestra [página de objetivos de escalabilidad](http://msdn.microsoft.com/library/azure/dn249410.aspx).</span><span class="sxs-lookup"><span data-stu-id="77afa-276">International bandwidth limits may be lower and can be found on our [scalability targets page](http://msdn.microsoft.com/library/azure/dn249410.aspx).</span></span>  <span data-ttu-id="77afa-277">Para más información acerca de las opciones de redundancia de almacenamiento, consulte los vínculos de [Recursos útiles](#sub1useful) que se indican a continuación.</span><span class="sxs-lookup"><span data-stu-id="77afa-277">For more information on the storage redundancy options, see the links in [Useful Resources](#sub1useful) below.</span></span>  

#### <a name="what-to-do-when-approaching-a-scalability-target"></a><span data-ttu-id="77afa-278">¿Qué debo hacer cuando un objetivo de escalabilidad está próximo?</span><span class="sxs-lookup"><span data-stu-id="77afa-278">What to do when approaching a scalability target</span></span>
<span data-ttu-id="77afa-279">Si su aplicación se aproxima a los objetivos de escalabilidad para una sola cuenta de almacenamiento, plantéese la adopción de uno de los siguientes enfoques:</span><span class="sxs-lookup"><span data-stu-id="77afa-279">If your application is approaching the scalability targets for a single storage account, consider adopting one of the following approaches:</span></span>  

* <span data-ttu-id="77afa-280">Reconsidere la carga de trabajo que hace que su aplicación se aproxime al objetivo de escalabilidad o lo supere.</span><span class="sxs-lookup"><span data-stu-id="77afa-280">Reconsider the workload that causes your application to approach or exceed the scalability target.</span></span> <span data-ttu-id="77afa-281">¿Puede designarla de forma diferente para que use menos ancho de banda o capacidad, o menos transacciones?</span><span class="sxs-lookup"><span data-stu-id="77afa-281">Can you design it differently to use less bandwidth or capacity, or fewer transactions?</span></span>
* <span data-ttu-id="77afa-282">Si una aplicación debe superar uno de los objetivos de escalabilidad, debe crear varias cuentas de almacenamiento y particionar los datos de su aplicación entre dichas cuentas.</span><span class="sxs-lookup"><span data-stu-id="77afa-282">If an application must exceed one of the scalability targets, you should create multiple storage accounts and partition your application data across those multiple storage accounts.</span></span> <span data-ttu-id="77afa-283">Si usa este patrón, entonces debe asegurarse de designar la aplicación de forma que pueda agregar más cuentas de almacenamiento en el futuro para equilibrio de carga.</span><span class="sxs-lookup"><span data-stu-id="77afa-283">If you use this pattern, then be sure to design your application so that you can add more storage accounts in the future for load balancing.</span></span> <span data-ttu-id="77afa-284">En el momento escribir estas líneas, cada suscripción de Azure puede tener hasta 100 cuentas de almacenamiento.</span><span class="sxs-lookup"><span data-stu-id="77afa-284">At time of writing, each Azure subscription can have up to 100 storage accounts.</span></span>  <span data-ttu-id="77afa-285">Las cuentas de almacenamiento tampoco tienen ningún costo que no sea el de su uso en términos de datos almacenados, transacciones realizadas o datos transferidos.</span><span class="sxs-lookup"><span data-stu-id="77afa-285">Storage accounts also have no cost other than your usage in terms of data stored, transactions made, or data transferred.</span></span>
* <span data-ttu-id="77afa-286">Si su aplicación alcanza los objetivos de ancho de banda, plantéese comprimir los datos contenidos en el cliente para reducir el ancho de banda requerido para enviar los datos al servicio de almacenamiento.</span><span class="sxs-lookup"><span data-stu-id="77afa-286">If your application hits the bandwidth targets, consider compressing data in the client to reduce the bandwidth required to send the data to the storage service.</span></span>  <span data-ttu-id="77afa-287">Tenga en cuenta que aunque esto puede ahorrar ancho de banda y mejorar el rendimiento de la red, también puede tener algunos impactos negativos.</span><span class="sxs-lookup"><span data-stu-id="77afa-287">Note that while this may save bandwidth and improve network performance, it can also have some negative impacts.</span></span>  <span data-ttu-id="77afa-288">Debe evaluar el impacto de rendimiento de todo esto debido a los requisitos de procesamiento adicionales para comprimir y descomprimir datos en el cliente.</span><span class="sxs-lookup"><span data-stu-id="77afa-288">You should evaluate the performance impact of this due to the additional processing requirements for compressing and decompressing data in the client.</span></span> <span data-ttu-id="77afa-289">Además, el almacenamiento de datos comprimidos puede dificultar la solución de problemas porque podría ser más complejo ver datos almacenados usando herramientas estándar.</span><span class="sxs-lookup"><span data-stu-id="77afa-289">In addition, storing compressed data can make it more difficult to troubleshoot issues since it could be more difficult to view stored data using standard tools.</span></span>
* <span data-ttu-id="77afa-290">Si su aplicación alcanza los objetivos de escalabilidad, asegúrese de usar un retroceso exponencial para reintentos (consulte [Reintentos](#subheading14)).</span><span class="sxs-lookup"><span data-stu-id="77afa-290">If your application hits the scalability targets, then ensure that you are using an exponential backoff for retries (see [Retries](#subheading14)).</span></span>  <span data-ttu-id="77afa-291">Es mejor asegurarse de que nunca se acerca a los objetivos de escalabilidad (para lo que debe usar uno de los métodos anteriores), pero esto garantizará que la aplicación deja de realizar reintentos constantes, ya que ello empeora la limitación.</span><span class="sxs-lookup"><span data-stu-id="77afa-291">It's better to make sure you never approach the scalability targets (by using one of the above methods), but this will ensure your application won't just keep retrying rapidly, making the throttling worse.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="77afa-292">Recursos útiles</span><span class="sxs-lookup"><span data-stu-id="77afa-292">Useful Resources</span></span>
<span data-ttu-id="77afa-293">Los siguientes vínculos proporcionan detalles adicionales sobre objetivos de escalabilidad:</span><span class="sxs-lookup"><span data-stu-id="77afa-293">The following links provide additional detail on scalability targets:</span></span>

* <span data-ttu-id="77afa-294">Consulte [Objetivos de escalabilidad y rendimiento de Azure Storage](storage-scalability-targets.md) para obtener información sobre los objetivos de escalabilidad.</span><span class="sxs-lookup"><span data-stu-id="77afa-294">See [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md) for information about scalability targets.</span></span>
* <span data-ttu-id="77afa-295">Consulte [Replicación de Azure Storage](storage-redundancy.md) y la entrada de blog [Azure Storage Redundancy Options and Read Access Geo Redundant Storage](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/11/introducing-read-access-geo-replicated-storage-ra-grs-for-windows-azure-storage.aspx) (Opciones de redundancia de Azure Storage y almacenamiento con redundancia geográfica con acceso de lectura) para obtener información sobre las opciones de redundancia de almacenamiento.</span><span class="sxs-lookup"><span data-stu-id="77afa-295">See [Azure Storage replication](storage-redundancy.md) and the blog post [Azure Storage Redundancy Options and Read Access Geo Redundant Storage](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/11/introducing-read-access-geo-replicated-storage-ra-grs-for-windows-azure-storage.aspx) for information about storage redundancy options.</span></span>
* <span data-ttu-id="77afa-296">Para obtener información actual sobre los precios de los servicios de Azure, consulte [Precios de Azure](https://azure.microsoft.com/pricing/overview/).</span><span class="sxs-lookup"><span data-stu-id="77afa-296">For current information about pricing for Azure services, see [Azure pricing](https://azure.microsoft.com/pricing/overview/).</span></span>  

### <span data-ttu-id="77afa-297"><a name="subheading47"></a>Convención de nomenclatura de particiones</span><span class="sxs-lookup"><span data-stu-id="77afa-297"><a name="subheading47"></a>Partition Naming Convention</span></span>
<span data-ttu-id="77afa-298">Azure Storage usa un esquema de particiones basado en intervalo para escalar y equilibrar la carga del sistema.</span><span class="sxs-lookup"><span data-stu-id="77afa-298">Azure Storage uses a range-based partitioning scheme to scale and load balance the system.</span></span> <span data-ttu-id="77afa-299">La clave de partición se usa para particionar datos en intervalos con una carga equilibrada en el sistema.</span><span class="sxs-lookup"><span data-stu-id="77afa-299">The partition key is used to partition data into ranges and these ranges are load-balanced across the system.</span></span> <span data-ttu-id="77afa-300">Esto significa que convenciones de nomenclatura como la ordenación léxica (p. ej., msftpayroll, msftperformance, msftemployees, etc.) o el uso de marcas de tiempo (log20160101, log20160102, log20160102, etc.) se prestarán a las particiones potencialmente colocadas en el mismo servidor de particiones, hasta que una operación de equilibrio de carga las divida en intervalos más pequeños.</span><span class="sxs-lookup"><span data-stu-id="77afa-300">This means naming conventions such as lexical ordering (e.g. msftpayroll, msftperformance, msftemployees, etc) or using time-stamps (log20160101, log20160102, log20160102, etc) will lend itself to the partitions being potentially co-located on the same partition server, until a load balancing operation splits them out into smaller ranges.</span></span> <span data-ttu-id="77afa-301">Por ejemplo, un servidor único puede atender a todos los blobs de un contenedor hasta que la carga de estos requiera un reequilibrado adicional de los intervalos de partición.</span><span class="sxs-lookup"><span data-stu-id="77afa-301">For example, all blobs within a container can be served by a single server until the load on these blobs requires further rebalancing of the partition ranges.</span></span> <span data-ttu-id="77afa-302">De forma similar, un servidor único puede atender a un grupo de cuentas ligeramente cargadas con sus nombres organizados en orden léxico hasta que la carga de una o de todas ellas requiera su división en varios servidores de particiones.</span><span class="sxs-lookup"><span data-stu-id="77afa-302">Similarly, a group of lightly loaded accounts with their names arranged in lexical order may be served by a single server until the load on one or all of these accounts require them to be split across multiple partitions servers.</span></span> <span data-ttu-id="77afa-303">Cada una de las operaciones de equilibrio de carga puede afectar a la latencia de las llamadas de almacenamiento realizadas durante la operación.</span><span class="sxs-lookup"><span data-stu-id="77afa-303">Each load balancing operation may impact the latency of storage calls during the operation.</span></span> <span data-ttu-id="77afa-304">La capacidad del sistema para controlar un aumento súbito del tráfico en una partición la limita la escalabilidad de un servidor de una sola partición hasta que la operación de equilibrio de carga se inicia y se vuelve a equilibrar el intervalo de claves de la partición.</span><span class="sxs-lookup"><span data-stu-id="77afa-304">The system's ability to handle a sudden burst of traffic to a partition is limited by the scalability of a single partition server until the load balancing operation kicks-in and rebalances the partition key range.</span></span>  

<span data-ttu-id="77afa-305">Puede seguir algunas prácticas recomendadas para reducir la frecuencia de dichas operaciones.</span><span class="sxs-lookup"><span data-stu-id="77afa-305">You can follow some best practices to reduce the frequency of such operations.</span></span>  

* <span data-ttu-id="77afa-306">Examine estrechamente la convención de nomenclatura que usa para las cuentas, contenedores, blobs, tablas y colas.</span><span class="sxs-lookup"><span data-stu-id="77afa-306">Examine the naming convention you use for accounts, containers, blobs, tables and queues, closely.</span></span> <span data-ttu-id="77afa-307">Considere la posibilidad de prefijar nombres de cuenta con un hash de 3 dígitos con la función hash que mejor se adapte a sus necesidades.</span><span class="sxs-lookup"><span data-stu-id="77afa-307">Consider prefixing account names with a 3-digit hash using a hashing function that best suits your needs.</span></span>  
* <span data-ttu-id="77afa-308">Si organiza sus datos mediante marcas de tiempo o identificadores numéricos, debe asegurarse de no usar patrones de tráfico Solo anexar (o Solo anteponer).</span><span class="sxs-lookup"><span data-stu-id="77afa-308">If you organize your data using timestamps or numerical identifiers, you have to ensure you are not using an append-only (or prepend-only) traffic patterns.</span></span> <span data-ttu-id="77afa-309">Estos patrones no son adecuados para un sistema de creación de particiones basado en intervalo y podrían dar lugar a todo el tráfico que se dirige a una sola partición e impide un eficaz equilibrio de carga del sistema.</span><span class="sxs-lookup"><span data-stu-id="77afa-309">These patterns are not suitable for a range -based partitioning system, and could lead to all the traffic going to a single partition and limiting the system from effectively load balancing.</span></span> <span data-ttu-id="77afa-310">Por ejemplo, si tiene operaciones diarias que usan un objeto blob con una marca de tiempo como aaaammdd, todo el tráfico de esa operación diaria se dirige a un solo objeto atendido por un solo servidor de particiones.</span><span class="sxs-lookup"><span data-stu-id="77afa-310">For instance, if you have daily operations that use a blob object with a timestamp such as yyyymmdd, then all the traffic for that daily operation is directed to a single object which is served by a single partition server.</span></span> <span data-ttu-id="77afa-311">Compruebe si los límites por blob y por partición cubren sus necesidades y considere la posibilidad de dividir esta operación en varios blobs según sea necesario.</span><span class="sxs-lookup"><span data-stu-id="77afa-311">Look at whether the per blob limits and per partition limits meet your needs, and consider breaking this operation into multiple blobs if needed.</span></span> <span data-ttu-id="77afa-312">De forma similar, si almacena datos de series temporales en sus tablas, todo el tráfico podría dirigirse a la última parte del espacio de nombres clave.</span><span class="sxs-lookup"><span data-stu-id="77afa-312">Similarly, if you store time series data in your tables, all the traffic could be directed to the last part of the key namespace.</span></span> <span data-ttu-id="77afa-313">Si tiene que usar marcas de tiempo o identificadores numéricos, prefíjelos con un hash de 3 dígitos o, en el caso de las marcas de tiempo, prefije la parte referente a los segundos de la hora como, por ejemplo, ssaaaammdd.</span><span class="sxs-lookup"><span data-stu-id="77afa-313">If you must use timestamps or numerical IDs, prefix the id with a 3-digit hash, or in the case of timestamps prefix the seconds part of the time such as ssyyyymmdd.</span></span> <span data-ttu-id="77afa-314">Si se realizan operaciones de enumeración y consulta de manera habitual, elija una función hash que limite su número de consultas.</span><span class="sxs-lookup"><span data-stu-id="77afa-314">If listing and querying operations are routinely performed, choose a hashing function that will limit your number of queries.</span></span> <span data-ttu-id="77afa-315">En otros casos, un prefijo aleatorio puede ser suficiente.</span><span class="sxs-lookup"><span data-stu-id="77afa-315">In other cases, a random prefix may be sufficient.</span></span>  
* <span data-ttu-id="77afa-316">Para obtener información adicional sobre el esquema de particiones usado en Azure Storage, lea el documento de SOSP [aquí](http://sigops.org/sosp/sosp11/current/2011-Cascais/printable/11-calder.pdf).</span><span class="sxs-lookup"><span data-stu-id="77afa-316">For additional information on the partitioning scheme used in Azure Storage, read the SOSP paper [here](http://sigops.org/sosp/sosp11/current/2011-Cascais/printable/11-calder.pdf).</span></span>

### <a name="networking"></a><span data-ttu-id="77afa-317">Redes</span><span class="sxs-lookup"><span data-stu-id="77afa-317">Networking</span></span>
<span data-ttu-id="77afa-318">Si bien las llamadas de API son importantes, a menudo las restricciones de red físicas de la aplicación tienen un impacto significativo en el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="77afa-318">While the API calls matter, often the physical network constraints of the application have a significant impact on performance.</span></span> <span data-ttu-id="77afa-319">A continuación se describen algunas de las limitaciones que pueden encontrar los usuarios.</span><span class="sxs-lookup"><span data-stu-id="77afa-319">The following describe some of limitations users may encounter.</span></span>  

#### <a name="client-network-capability"></a><span data-ttu-id="77afa-320">Capacidad de red del cliente</span><span class="sxs-lookup"><span data-stu-id="77afa-320">Client Network Capability</span></span>
##### <span data-ttu-id="77afa-321"><a name="subheading2"></a>Capacidad de proceso</span><span class="sxs-lookup"><span data-stu-id="77afa-321"><a name="subheading2"></a>Throughput</span></span>
<span data-ttu-id="77afa-322">Para el ancho de banda, el problema suele residir en las capacidades del cliente.</span><span class="sxs-lookup"><span data-stu-id="77afa-322">For bandwidth, the problem is often the capabilities of the client.</span></span> <span data-ttu-id="77afa-323">Por ejemplo, mientras una sola cuenta de almacenamiento puede controlar 10 Gbps, o más, de entrada (consulte [destinos de escalabilidad de ancho de banda](#sub1bandwidth)), la velocidad de la red en una instancia del rol de trabajo de Azure “pequeña” solo puede controlar aproximadamente 100 Mbps.</span><span class="sxs-lookup"><span data-stu-id="77afa-323">For example, while a single storage account can handle 10 Gbps or more of ingress (see [bandwidth scalability targets](#sub1bandwidth)), the network speed in a "Small" Azure Worker Role instance is only capable of approximately 100 Mbps.</span></span> <span data-ttu-id="77afa-324">Las instancias de Azure mayores tienen NIC con mayor capacidad, por lo que debe plantearse la posibilidad de usar una instancia mayor o más máquinas virtuales si necesita aumentar los límites de red de una sola máquina.</span><span class="sxs-lookup"><span data-stu-id="77afa-324">Larger Azure instances have NICs with greater capacity, so you should consider using a larger instance or more VM's if you need higher network limits from a single machine.</span></span> <span data-ttu-id="77afa-325">Si accede a un servicio de Storage desde una aplicación local, se aplica la misma regla: comprender las funcionalidades de red del dispositivo cliente y la conectividad de red con la ubicación de Azure Storage y, bien mejorarlas según sea necesario o diseñar la aplicación para que funcione según sus funcionalidades.</span><span class="sxs-lookup"><span data-stu-id="77afa-325">If you are accessing a Storage service from an on premises application, then the same rule applies: understand the network capabilities of the client device and the network connectivity to the Azure Storage location and either improve them as needed or design your application to work within their capabilities.</span></span>  

##### <span data-ttu-id="77afa-326"><a name="subheading3"></a>Calidad del enlace</span><span class="sxs-lookup"><span data-stu-id="77afa-326"><a name="subheading3"></a>Link Quality</span></span>
<span data-ttu-id="77afa-327">Como con cualquier uso de red, sea consciente de que las condiciones de la red dan lugar a errores y la pérdida de paquetes reducirá el rendimiento efectivo.</span><span class="sxs-lookup"><span data-stu-id="77afa-327">As with any network usage, be aware that network conditions resulting in errors and packet loss will slow effective throughput.</span></span>  <span data-ttu-id="77afa-328">El uso de WireShark o NetMon puede ayudar a diagnosticar este problema.</span><span class="sxs-lookup"><span data-stu-id="77afa-328">Using WireShark or NetMon may help in diagnosing this issue.</span></span>  

##### <a name="useful-resources"></a><span data-ttu-id="77afa-329">Recursos útiles</span><span class="sxs-lookup"><span data-stu-id="77afa-329">Useful Resources</span></span>
<span data-ttu-id="77afa-330">Para obtener información sobre los tamaños de máquina virtual y el ancho de banda asignado, consulte los artículos sobre [Tamaños de las máquinas virtuales Windows](../../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) o [Tamaños de las máquinas virtuales Linux](../../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).</span><span class="sxs-lookup"><span data-stu-id="77afa-330">For more information about virtual machine sizes and allocated bandwidth, see [Windows VM sizes](../../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) or [Linux VM sizes](../../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).</span></span>  

#### <span data-ttu-id="77afa-331"><a name="subheading4"></a>Ubicación</span><span class="sxs-lookup"><span data-stu-id="77afa-331"><a name="subheading4"></a>Location</span></span>
<span data-ttu-id="77afa-332">En cualquier entorno distribuido, la ubicación del cliente cerca del servidor ofrece el mejor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="77afa-332">In any distributed environment, placing the client near to the server delivers in the best performance.</span></span> <span data-ttu-id="77afa-333">Para acceder a Azure Storage con la mínima latencia, la mejor ubicación para el cliente es dentro de la misma región de Azure.</span><span class="sxs-lookup"><span data-stu-id="77afa-333">For accessing Azure Storage with the lowest latency, the best location for your client is within the same Azure region.</span></span> <span data-ttu-id="77afa-334">Por ejemplo, si tiene un sitio web Azure que usa Azure Storage, debe colocar ambos dentro de una sola región (por ejemplo Oeste de EE. UU. o Sudeste de Asia).</span><span class="sxs-lookup"><span data-stu-id="77afa-334">For example, if you have an Azure Web Site that uses Azure Storage, you should locate them both within a single region (for example, US West or Asia Southeast).</span></span> <span data-ttu-id="77afa-335">Esto reduce la latencia y el costo (en el momento de escribir estas líneas, el uso de ancho de banda dentro de una sola región es gratuito).</span><span class="sxs-lookup"><span data-stu-id="77afa-335">This reduces the latency and the cost — at the time of writing, bandwidth usage within a single region is free.</span></span>  

<span data-ttu-id="77afa-336">Si las aplicaciones cliente no están hospedadas dentro de Azure (como por ejemplo aplicaciones de dispositivos móviles o servicios empresariales locales), una vez más la ubicación de la cuenta de almacenamiento en una región próxima a los dispositivos a los que obtendrá acceso, generalmente reducirá la latencia.</span><span class="sxs-lookup"><span data-stu-id="77afa-336">If your client applications are not hosted within Azure (such as mobile device apps or on premises enterprise services), then again placing the storage account in a region near to the devices that will access it, will generally reduce latency.</span></span> <span data-ttu-id="77afa-337">Si los clientes están muy distribuidos (por ejemplo algunos en Norteamérica y otros en Europa), debe plantearse el uso de varias cuentas de almacenamiento: una ubicada en una región de Norteamérica y otra en una región de Europa.</span><span class="sxs-lookup"><span data-stu-id="77afa-337">If your clients are broadly distributed (for example, some in North America, and some in Europe), then you should consider using multiple storage accounts: one located in a North American region and one in a European region.</span></span> <span data-ttu-id="77afa-338">Esto ayudará a reducir la latencia para los usuarios de ambas regiones.</span><span class="sxs-lookup"><span data-stu-id="77afa-338">This will help to reduce latency for users in both regions.</span></span> <span data-ttu-id="77afa-339">Este enfoque normalmente es más sencillo de implementar si los datos que almacena la aplicación son específicos de usuarios individuales y no se requiere la replicación de datos entre cuentas de almacenamiento.</span><span class="sxs-lookup"><span data-stu-id="77afa-339">This approach is usually easier to implement if the data the application stores is specific to individual users, and does not require replicating data between storage accounts.</span></span>  <span data-ttu-id="77afa-340">Para distribución de contenido amplio, se recomienda una red CDN (consulte la siguiente sección para obtener más detalles).</span><span class="sxs-lookup"><span data-stu-id="77afa-340">For broad content distribution, a CDN is recommended – see the next section for more details.</span></span>  

### <span data-ttu-id="77afa-341"><a name="subheading5"></a>Distribución de contenido</span><span class="sxs-lookup"><span data-stu-id="77afa-341"><a name="subheading5"></a>Content Distribution</span></span>
<span data-ttu-id="77afa-342">Algunas veces, una aplicación necesita servir el mismo contenido a muchos usuarios (por ejemplo, un vídeo de demostración de producto o usado en la página principal de un sitio web) ubicados bien en la misma región, bien en varias regiones.</span><span class="sxs-lookup"><span data-stu-id="77afa-342">Sometimes, an application needs to serve the same content to many users (e.g. a product demo video used in the home page of a website), located in either the same or multiple regions.</span></span> <span data-ttu-id="77afa-343">En este escenario, debe usar una red de entrega de contenido (CDN), como por ejemplo Azure CDN, y dicha red CDN debe usar Azure Storage como origen de los datos.</span><span class="sxs-lookup"><span data-stu-id="77afa-343">In this scenario, you should use a Content Delivery Network (CDN) such as Azure CDN, and the CDN would use Azure storage as the origin of the data.</span></span> <span data-ttu-id="77afa-344">A diferencia de la cuenta de Azure Storage que existe en una sola región y que no puede entregar contenido con baja latencia a otras regiones, la red CDN de Azure usa servidores en varios centros de datos alrededor del mundo.</span><span class="sxs-lookup"><span data-stu-id="77afa-344">Unlike an Azure Storage account that exists in a single region and that cannot deliver content with low latency to other regions, Azure CDN uses servers in multiple data centers around the world.</span></span> <span data-ttu-id="77afa-345">Además, una red CDN normalmente puede admitir límites de salida mucho más altos que una sola cuenta de almacenamiento.</span><span class="sxs-lookup"><span data-stu-id="77afa-345">Additionally, a CDN can typically support much higher egress limits than a single storage account.</span></span>  

<span data-ttu-id="77afa-346">Para obtener más información acerca de la red CDN de Azure, consulte [Red CDN de Azure](https://azure.microsoft.com/services/cdn/).</span><span class="sxs-lookup"><span data-stu-id="77afa-346">For more information about Azure CDN, see [Azure CDN](https://azure.microsoft.com/services/cdn/).</span></span>  

### <span data-ttu-id="77afa-347"><a name="subheading6"></a>Uso de SAS y CORS</span><span class="sxs-lookup"><span data-stu-id="77afa-347"><a name="subheading6"></a>Using SAS and CORS</span></span>
<span data-ttu-id="77afa-348">Cuando hace falta autorizar código, como por ejemplo JavaScript, en el explorador web de un usuario o en una aplicación para teléfonos móviles para acceder a los datos en Azure Storage, un enfoque es usar una aplicación de rol web como proxy: el dispositivo del usuario se autentica con el rol web que, a su vez, se autentica con el servicio de Storage.</span><span class="sxs-lookup"><span data-stu-id="77afa-348">When you need to authorize code such as JavaScript in a user's web browser or a mobile phone app to access data in Azure Storage, one approach is to use an application in web role as a proxy: the user's device authenticates with the web role, which in turn authenticates with the storage service.</span></span> <span data-ttu-id="77afa-349">De esta forma, puede evitar la exposición de sus claves de cuenta de almacenamiento en dispositivos no seguros.</span><span class="sxs-lookup"><span data-stu-id="77afa-349">In this way, you can avoid exposing your storage account keys on insecure devices.</span></span> <span data-ttu-id="77afa-350">Sin embargo, este enfoque coloca una gran sobrecarga sobre el rol web, ya que todos los datos transferidos entre el dispositivo del usuario y el servicio de Storage deben pasar a través de dicho rol.</span><span class="sxs-lookup"><span data-stu-id="77afa-350">However, this places a big overhead on the web role because all the data transferred between the user's device and the storage service must pass through the web role.</span></span> <span data-ttu-id="77afa-351">Puede evitar el uso de un rol web como un proxy para el servicio de almacenamiento usando firmas de acceso compartido (SAS), algunas veces junto con encabezados de uso compartido de recursos entre orígenes (CORS).</span><span class="sxs-lookup"><span data-stu-id="77afa-351">You can avoid using a web role as a proxy for the storage service by using Shared Access Signatures (SAS), sometimes in conjunction with Cross-Origin Resource Sharing headers (CORS).</span></span> <span data-ttu-id="77afa-352">Mediante SAS se puede permitir que el dispositivo del usuario realice solicitudes directamente a un servicio de Storage por medio de un token de acceso limitado.</span><span class="sxs-lookup"><span data-stu-id="77afa-352">Using SAS, you can allow your user's device to make requests directly to a storage service by means of a limited access token.</span></span> <span data-ttu-id="77afa-353">Por ejemplo, si un usuario desea cargar una foto en su aplicación, su rol web puede generar y enviar al dispositivo del usuario un token SAS que conceda el permiso para escribir en un blob o contenedor concretos durante los próximos 30 minutos (tras los cuales el token SAS expira).</span><span class="sxs-lookup"><span data-stu-id="77afa-353">For example, if a user wants to upload a photo to your application, your web role can generate and send to the user's device a SAS token that grants permission to write to a specific blob or container for the next 30 minutes (after which the SAS token expires).</span></span>

<span data-ttu-id="77afa-354">Normalmente, un explorador no permitirá que haya código JavaScript en una página hospedada por un sitio web en un dominio que realice operaciones específicas, como “PUT”, en otro dominio.</span><span class="sxs-lookup"><span data-stu-id="77afa-354">Normally, a browser will not allow JavaScript in a page hosted by a website on one domain to perform specific operations such as a "PUT" to another domain.</span></span> <span data-ttu-id="77afa-355">Por ejemplo, si hospeda un rol web en “contosomarketing.cloudapp.net” y desea usar el código JavaScript del cliente para cargar un blob en la cuenta de almacenamiento en “contosoproducts.blob.core.windows.net”, la “misma directiva de origen” del explorador prohibirá esta operación.</span><span class="sxs-lookup"><span data-stu-id="77afa-355">For example, if you host a web role at "contosomarketing.cloudapp.net," and want to use client side JavaScript to upload a blob to your storage account at "contosoproducts.blob.core.windows.net," the browser's "same origin policy" will forbid this operation.</span></span> <span data-ttu-id="77afa-356">CORS es una característica de explorador que permite al dominio de destino (en este caso la cuenta de almacenamiento) comunicar al explorador en el que confía solicitudes que se originan en el dominio de origen (en este caso el rol web).</span><span class="sxs-lookup"><span data-stu-id="77afa-356">CORS is a browser feature that allows the target domain (in this case the storage account) to communicate to the browser that it trusts requests originating in the source domain (in this case the web role).</span></span>  

<span data-ttu-id="77afa-357">Estas dos tecnologías pueden ayudarle a evitar una carga innecesaria (y cuellos de botella) en la aplicación web.</span><span class="sxs-lookup"><span data-stu-id="77afa-357">Both of these technologies can help you avoid unnecessary load (and bottlenecks) on your web application.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="77afa-358">Recursos útiles</span><span class="sxs-lookup"><span data-stu-id="77afa-358">Useful Resources</span></span>
<span data-ttu-id="77afa-359">Para obtener más información acerca de SAS, consulte [Firmas de acceso compartido, parte 1: Descripción del modelo de firmas de acceso compartido](../storage-dotnet-shared-access-signature-part-1.md).</span><span class="sxs-lookup"><span data-stu-id="77afa-359">For more information about SAS, see [Shared Access Signatures, Part 1: Understanding the SAS Model](../storage-dotnet-shared-access-signature-part-1.md).</span></span>  

<span data-ttu-id="77afa-360">Para obtener más información sobre CORS, vea [Compatibilidad del Uso compartido de recursos entre orígenes (CORS) para los servicios de Azure Storage](http://msdn.microsoft.com/library/azure/dn535601.aspx).</span><span class="sxs-lookup"><span data-stu-id="77afa-360">For more information about CORS, see [Cross-Origin Resource Sharing (CORS) Support for the Azure Storage Services](http://msdn.microsoft.com/library/azure/dn535601.aspx).</span></span>  

### <a name="caching"></a><span data-ttu-id="77afa-361">Almacenamiento en caché</span><span class="sxs-lookup"><span data-stu-id="77afa-361">Caching</span></span>
#### <span data-ttu-id="77afa-362"><a name="subheading7"></a>Obtención de datos</span><span class="sxs-lookup"><span data-stu-id="77afa-362"><a name="subheading7"></a>Getting Data</span></span>
<span data-ttu-id="77afa-363">En general, obtener datos de un servicio una vez es mejor que obtenerlos dos veces.</span><span class="sxs-lookup"><span data-stu-id="77afa-363">In general, getting data from a service once is better than getting it twice.</span></span> <span data-ttu-id="77afa-364">Considere el ejemplo de una aplicación web de MVC que se ejecuta en un rol web que ya haya recuperado un blob de 50 MB del servicio de almacenamiento para servir como contenido al usuario.</span><span class="sxs-lookup"><span data-stu-id="77afa-364">Consider the example of an MVC web application running in a web role that has already retrieved a 50MB blob from the storage service to serve as content to a user.</span></span> <span data-ttu-id="77afa-365">La aplicación podría recuperar después ese mismo blob cada vez que un usuario lo solicitara o podría almacenarlo en caché localmente en el disco y volver a usar la versión almacenada en caché para posteriores solicitudes del usuario.</span><span class="sxs-lookup"><span data-stu-id="77afa-365">The application could then retrieve that same blob every time a user requests it, or it could cache it locally to disk and reuse the cached version for subsequent user requests.</span></span> <span data-ttu-id="77afa-366">Además, cada vez que un usuario solicita los datos, la aplicación podría emitir un comando GET con un encabezado condicional con la hora de modificación, lo que evitaría tener que obtener todo el blob si no se ha modificado.</span><span class="sxs-lookup"><span data-stu-id="77afa-366">Furthermore, whenever a user requests the data, the application could issue GET with a conditional header for modification time, which would avoid getting the entire blob if it hasn't been modified.</span></span> <span data-ttu-id="77afa-367">Puede aplicar este mismo patrón para trabajar con entidades de tabla.</span><span class="sxs-lookup"><span data-stu-id="77afa-367">You can apply this same pattern to working with table entities.</span></span>  

<span data-ttu-id="77afa-368">En algunos casos, puede decidir que su aplicación pueda asumir que el blob sigue siendo válido durante un corto período después de recuperarlo y que durante dicho período la aplicación no necesite comprobar si el blob se modificó.</span><span class="sxs-lookup"><span data-stu-id="77afa-368">In some cases, you may decide that your application can assume that the blob remains valid for a short period after retrieving it, and that during this period the application does not need to check if the blob was modified.</span></span>

<span data-ttu-id="77afa-369">Los datos de configuración y búsqueda, así como otros datos que siempre usa la aplicación, son magníficos candidatos para el almacenamiento en caché.</span><span class="sxs-lookup"><span data-stu-id="77afa-369">Configuration, lookup, and other data that are always used by the application are great candidates for caching.</span></span>  

<span data-ttu-id="77afa-370">Para ver un ejemplo de cómo obtener las propiedades de un blob para detectar la fecha de la última modificación mediante .NET, consulte [Establecer y recuperar propiedades y metadatos](../blobs/storage-properties-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="77afa-370">For an example of how to get a blob's properties to discover the last modified date using .NET, see [Set and Retrieve Properties and Metadata](../blobs/storage-properties-metadata.md).</span></span> <span data-ttu-id="77afa-371">Para obtener más información sobre las descargas condicionales, consulte [Actualización condicional de una copia local de un blob](http://msdn.microsoft.com/library/azure/dd179371.aspx).</span><span class="sxs-lookup"><span data-stu-id="77afa-371">For more information about conditional downloads, see [Conditionally Refresh a Local Copy of a Blob](http://msdn.microsoft.com/library/azure/dd179371.aspx).</span></span>  

#### <span data-ttu-id="77afa-372"><a name="subheading8"></a>Carga de datos en lotes</span><span class="sxs-lookup"><span data-stu-id="77afa-372"><a name="subheading8"></a>Uploading Data in Batches</span></span>
<span data-ttu-id="77afa-373">En algunos escenarios de aplicación, puede agregar datos localmente y, a continuación, cargarlos periódicamente en un lote en lugar de cargar cada parte de datos inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="77afa-373">In some application scenarios, you can aggregate data locally, and then periodically upload it in a batch instead of uploading each piece of data immediately.</span></span> <span data-ttu-id="77afa-374">Por ejemplo, una aplicación web podría guardar un archivo de registro de actividades: la aplicación podría cargar detalles de cada actividad como sucede como entidad de tabla (lo que requiere muchas operaciones de almacenamiento), o bien podría guardar detalles de la actividad en un archivo de registro local y, a continuación, cargar todos los detalles de actividad periódicamente como un archivo delimitado en un blob.</span><span class="sxs-lookup"><span data-stu-id="77afa-374">For example, a web application might keep a log file of activities: the application could either upload details of every activity as it happens as a table entity (which requires many storage operations), or it could save activity details to a local log file, and then periodically upload all activity details as a delimited file to a blob.</span></span> <span data-ttu-id="77afa-375">Si cada entrada de registro tiene un tamaño de 1 KB, puede cargar miles en una sola transacción “Put Blob” (puede cargar un blob de hasta 64 MB en una sola transacción).</span><span class="sxs-lookup"><span data-stu-id="77afa-375">If each log entry is 1KB in size, you can upload thousands in a single "Put Blob" transaction (you can upload a blob of up to 64MB in size in a single transaction).</span></span> <span data-ttu-id="77afa-376">Por supuesto, si se bloquea el equipo local antes de la carga, podría perder algunos datos de registro: el diseño del desarrollador de aplicaciones debe tener en cuenta los errores de carga o dispositivo de cliente.</span><span class="sxs-lookup"><span data-stu-id="77afa-376">Of course, if the local machine crashes prior to the upload, you will potentially lose some log data: the application developer must design for the possibility of client device or upload failures.</span></span>  <span data-ttu-id="77afa-377">Si los datos de actividad necesitan descargarse para períodos de tiempo (no simplemente una actividad), se recomiendan los blobs sobre las tablas.</span><span class="sxs-lookup"><span data-stu-id="77afa-377">If the activity data needs to be downloaded for timespans (not just single activity), then blobs are recommended over tables.</span></span>

### <a name="net-configuration"></a><span data-ttu-id="77afa-378">Configuración .NET</span><span class="sxs-lookup"><span data-stu-id="77afa-378">.NET Configuration</span></span>
<span data-ttu-id="77afa-379">Si usa .NET Framework, esta sección enumera varias configuraciones rápidas que puede usar para realizar mejoras de rendimiento significativas.</span><span class="sxs-lookup"><span data-stu-id="77afa-379">If using the .NET Framework, this section lists several quick configuration settings that you can use to make significant performance improvements.</span></span>  <span data-ttu-id="77afa-380">Si usa otros lenguajes, compruebe si se aplican conceptos similares en el lenguaje elegido.</span><span class="sxs-lookup"><span data-stu-id="77afa-380">If using other languages, check to see if similar concepts apply in your chosen language.</span></span>  

#### <span data-ttu-id="77afa-381"><a name="subheading9"></a>Aumento del límite de conexiones predeterminado</span><span class="sxs-lookup"><span data-stu-id="77afa-381"><a name="subheading9"></a>Increase default connection limit</span></span>
<span data-ttu-id="77afa-382">En .NET, el siguiente código aumenta el límite de conexiones predeterminado (que normalmente es 2 en un entorno cliente o 10 en un entorno servidor) a 100.</span><span class="sxs-lookup"><span data-stu-id="77afa-382">In .NET, the following code increases the default connection limit (which is usually 2 in a client environment or 10 in a server environment) to 100.</span></span> <span data-ttu-id="77afa-383">Normalmente, debe establecer el valor en aproximadamente el número de subprocesos usados por su aplicación.</span><span class="sxs-lookup"><span data-stu-id="77afa-383">Typically, you should set the value to approximately the number of threads used by your application.</span></span>  

```csharp
ServicePointManager.DefaultConnectionLimit = 100; //(Or More)  
```

<span data-ttu-id="77afa-384">Debe establecer el límite de conexiones antes de abrir cualquier conexión.</span><span class="sxs-lookup"><span data-stu-id="77afa-384">You must set the connection limit before opening any connections.</span></span>  

<span data-ttu-id="77afa-385">En el caso de otros lenguajes de programación, consulte la documentación del lenguaje en cuestión para determinar cómo establecer el límite de conexiones.</span><span class="sxs-lookup"><span data-stu-id="77afa-385">For other programming languages, see that language's documentation to determine how to set the connection limit.</span></span>  

<span data-ttu-id="77afa-386">Para obtener más información, vea la entrada de blog [Servicios web: conexiones simultáneas](http://blogs.msdn.com/b/darrenj/archive/2005/03/07/386655.aspx).</span><span class="sxs-lookup"><span data-stu-id="77afa-386">For additional information, see the blog post [Web Services: Concurrent Connections](http://blogs.msdn.com/b/darrenj/archive/2005/03/07/386655.aspx).</span></span>  

#### <span data-ttu-id="77afa-387"><a name="subheading10"></a>Aumento de los subprocesos mínimos ThreadPool si se usa código sincrónico con tareas asincrónicas</span><span class="sxs-lookup"><span data-stu-id="77afa-387"><a name="subheading10"></a>Increase ThreadPool Min Threads if using synchronous code with Async Tasks</span></span>
<span data-ttu-id="77afa-388">Este código aumentará los subprocesos mínimos del grupo de subprocesos:</span><span class="sxs-lookup"><span data-stu-id="77afa-388">This code will increase the thread pool min threads:</span></span>  

```csharp
ThreadPool.SetMinThreads(100,100); //(Determine the right number for your application)  
```

<span data-ttu-id="77afa-389">Para obtener más información, consulte [Método ThreadPool.SetMinThreads](http://msdn.microsoft.com/library/system.threading.threadpool.setminthreads%28v=vs.110%29.aspx).</span><span class="sxs-lookup"><span data-stu-id="77afa-389">For more information, see [ThreadPool.SetMinThreads Method](http://msdn.microsoft.com/library/system.threading.threadpool.setminthreads%28v=vs.110%29.aspx).</span></span>  

#### <span data-ttu-id="77afa-390"><a name="subheading11"></a>Aprovechamiento de la recolección de elementos no usados de .NET 4.5</span><span class="sxs-lookup"><span data-stu-id="77afa-390"><a name="subheading11"></a>Take advantage of .NET 4.5 Garbage Collection</span></span>
<span data-ttu-id="77afa-391">Use .NET 4.5 o posterior para que la aplicación cliente aproveche las mejoras de rendimiento en la recolección de elementos no usados del servidor.</span><span class="sxs-lookup"><span data-stu-id="77afa-391">Use .NET 4.5 or later for the client application to take advantage of performance improvements in server garbage collection.</span></span>

<span data-ttu-id="77afa-392">Para obtener más información, consulte el artículo [Información general de las mejoras de rendimiento en .NET 4.5](http://msdn.microsoft.com/magazine/hh882452.aspx).</span><span class="sxs-lookup"><span data-stu-id="77afa-392">For more information, see the article [An Overview of Performance Improvements in .NET 4.5](http://msdn.microsoft.com/magazine/hh882452.aspx).</span></span>  

### <span data-ttu-id="77afa-393"><a name="subheading12"></a>Paralelismo no vinculado</span><span class="sxs-lookup"><span data-stu-id="77afa-393"><a name="subheading12"></a>Unbounded Parallelism</span></span>
<span data-ttu-id="77afa-394">Aunque el paralelismo puede ser magnífico para el rendimiento, tenga cuidado cuando use paralelismo no vinculado (sin límite en el número de subprocesos y/o solicitudes paralelas) para cargar o descargar datos y cuando use varios trabajadores para obtener acceso a varias particiones (contenedores, colas o particiones de tabla) en la misma cuenta de almacenamiento o para obtener acceso a varios elementos de la misma partición.</span><span class="sxs-lookup"><span data-stu-id="77afa-394">While parallelism can be great for performance, be careful about using unbounded parallelism (no limit on the number of threads and/or parallel requests) to upload or download data, using multiple workers to access multiple partitions (containers, queues, or table partitions) in the same storage account or to access multiple items in the same partition.</span></span> <span data-ttu-id="77afa-395">Si el paralelismo no está vinculado, la aplicación puede superar las funcionalidades del dispositivo cliente o los objetivos de escalabilidad de la cuenta de almacenamiento, lo que puede provocar a latencias más largas y limitaciones.</span><span class="sxs-lookup"><span data-stu-id="77afa-395">If the parallelism is unbounded, your application can exceed the client device's capabilities or the storage account's scalability targets resulting in longer latencies and throttling.</span></span>  

### <span data-ttu-id="77afa-396"><a name="subheading13"></a>Herramientas y bibliotecas de cliente de Storage</span><span class="sxs-lookup"><span data-stu-id="77afa-396"><a name="subheading13"></a>Storage Client Libraries and Tools</span></span>
<span data-ttu-id="77afa-397">Use siempre las herramientas y bibliotecas de cliente más recientes proporcionadas por Microsoft.</span><span class="sxs-lookup"><span data-stu-id="77afa-397">Always use the latest Microsoft provided client libraries and tools.</span></span> <span data-ttu-id="77afa-398">En el momento de escribir estas líneas, hay bibliotecas de cliente disponibles para .NET, Windows Phone, Windows Runtime, Java y C ++, así como bibliotecas de vista previa para otros lenguajes.</span><span class="sxs-lookup"><span data-stu-id="77afa-398">At the time of writing, there are client libraries available for .NET, Windows Phone, Windows Runtime, Java, and C++, as well as preview libraries for other languages.</span></span> <span data-ttu-id="77afa-399">Además, Microsoft ha lanzado cmdlets de PowerShell y comandos de la CLI de Azure para trabajar con Azure Storage.</span><span class="sxs-lookup"><span data-stu-id="77afa-399">In addition, Microsoft has released PowerShell cmdlets and Azure CLI commands for working with Azure Storage.</span></span> <span data-ttu-id="77afa-400">Microsoft desarrolla de forma activa estas herramientas pensando en el rendimiento, manteniéndolas actualizadas con las versiones de servicio más recientes, y garantiza que administran muchas de las prácticas de rendimiento probadas internamente.</span><span class="sxs-lookup"><span data-stu-id="77afa-400">Microsoft actively develops these tools with performance in mind, keeps them up to date with the latest service versions, and ensures they handle many of the proven performance practices internally.</span></span>  

### <a name="retries"></a><span data-ttu-id="77afa-401">Reintentos</span><span class="sxs-lookup"><span data-stu-id="77afa-401">Retries</span></span>
#### <span data-ttu-id="77afa-402"><a name="subheading14"></a>Limitación y servidor ocupado</span><span class="sxs-lookup"><span data-stu-id="77afa-402"><a name="subheading14"></a>Throttling/ServerBusy</span></span>
<span data-ttu-id="77afa-403">En algunos casos, el servicio de Storage puede limitar su aplicación o simplemente puede no ser capaz de atender la solicitud debido a alguna condición transitoria y devolver un mensaje “503 Servidor ocupado” o “500 Se agotó el tiempo de espera”.</span><span class="sxs-lookup"><span data-stu-id="77afa-403">In some cases, the storage service may throttle your application or may simply be unable to serve the request due to some transient condition and return a "503 Server busy" message or "500 Timeout".</span></span>  <span data-ttu-id="77afa-404">Esto puede ocurrir si la aplicación se está aproximando a cualquiera de los objetivos de escalabilidad o si el sistema está equilibrando los datos particionados para permitir un mayor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="77afa-404">This can happen if your application is approaching any of the scalability targets, or if the system is rebalancing your partitioned data to allow for higher throughput.</span></span>  <span data-ttu-id="77afa-405">Normalmente, la aplicación cliente debe volver a intentar la operación que provoca el error: al volver a enviar la solicitud, puede que se lleve a cabo correctamente.</span><span class="sxs-lookup"><span data-stu-id="77afa-405">The client application should typically retry the operation that causes such an error: attempting the same request later can succeed.</span></span> <span data-ttu-id="77afa-406">Sin embargo, si el servicio de almacenamiento está limitando la aplicación porque está superando los objetivos de escalabilidad, o incluso si el servicio no pudo atender a la solicitud por alguna otra razón, lo intentos agresivos normalmente empeorarán el problema.</span><span class="sxs-lookup"><span data-stu-id="77afa-406">However, if the storage service is throttling your application because it is exceeding scalability targets, or even if the service was unable to serve the request for some other reason, aggressive retries usually make the problem worse.</span></span> <span data-ttu-id="77afa-407">Por esta razón, debe usar un retroceso exponencial (las bibliotecas de cliente se comportan así de forma predeterminada).</span><span class="sxs-lookup"><span data-stu-id="77afa-407">For this reason, you should use an exponential back off (the client libraries default to this behavior).</span></span> <span data-ttu-id="77afa-408">Por ejemplo, su aplicación puede llevar a cabo los reintentos después de 2 segundos, luego 4 segundos, después 10 segundos, luego 30 segundos y, después, renunciar.</span><span class="sxs-lookup"><span data-stu-id="77afa-408">For example, your application may retry after 2 seconds, then 4 seconds, then 10 seconds, then 30 seconds, and then give up completely.</span></span> <span data-ttu-id="77afa-409">Este comportamiento da lugar a una reducción significativa de la carga de la aplicación en el servicio en lugar de agravar los problemas.</span><span class="sxs-lookup"><span data-stu-id="77afa-409">This behavior results in your application significantly reducing its load on the service rather than exacerbating any problems.</span></span>  

<span data-ttu-id="77afa-410">Tenga en cuenta que los errores de conectividad se pueden reintentar inmediatamente porque no se derivan de la limitación y se espera que sean transitorios.</span><span class="sxs-lookup"><span data-stu-id="77afa-410">Note that connectivity errors can be retried immediately, because they are not the result of throttling and are expected to be transient.</span></span>  

#### <span data-ttu-id="77afa-411"><a name="subheading15"></a>Errores que no se pueden reintentar</span><span class="sxs-lookup"><span data-stu-id="77afa-411"><a name="subheading15"></a>Non-Retryable Errors</span></span>
<span data-ttu-id="77afa-412">Las bibliotecas de cliente saben qué errores se pueden reintentar y cuáles no.</span><span class="sxs-lookup"><span data-stu-id="77afa-412">The client libraries are aware of which errors are retry-able and which are not.</span></span> <span data-ttu-id="77afa-413">Sin embargo, si está escribiendo su propio código en la API de REST de almacenamiento, recuerde que hay algunos errores que no se deben reintentar: por ejemplo, una respuesta 400 (solicitud incorrecta) indica que la aplicación cliente envió una solicitud que no se pudo procesar porque no tenía el formato esperado.</span><span class="sxs-lookup"><span data-stu-id="77afa-413">However, if you are writing your own code against the storage REST API, remember there are some errors that you should not retry: for example, a 400 (Bad Request) response indicates that the client application sent a request that could not be processed because it was not in an expected form.</span></span> <span data-ttu-id="77afa-414">El reenvío de esta solicitud dará lugar a la misma respuesta cada vez, por lo que no tiene sentido reintentarla.</span><span class="sxs-lookup"><span data-stu-id="77afa-414">Resending this request will result the same response every time, so there is no point in retrying it.</span></span> <span data-ttu-id="77afa-415">Si escribe su propio código contra la API REST de almacenamiento, sepa lo que significan los códigos de error y la forma adecuada de reintentar (o no) cada uno de ellos.</span><span class="sxs-lookup"><span data-stu-id="77afa-415">If you are writing your own code against the storage REST API, be aware of what the error codes mean and the proper way to retry (or not) for each of them.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="77afa-416">Recursos útiles</span><span class="sxs-lookup"><span data-stu-id="77afa-416">Useful Resources</span></span>
<span data-ttu-id="77afa-417">Para más información acerca de los códigos de error de almacenamiento, consulte [Códigos de estado y de error](http://msdn.microsoft.com/library/azure/dd179382.aspx) en el sitio web de Microsoft Azure.</span><span class="sxs-lookup"><span data-stu-id="77afa-417">For more information about storage error codes, see [Status and Error Codes](http://msdn.microsoft.com/library/azure/dd179382.aspx) on the Microsoft Azure web site.</span></span>  

## <a name="blobs"></a><span data-ttu-id="77afa-418">Blobs</span><span class="sxs-lookup"><span data-stu-id="77afa-418">Blobs</span></span>
<span data-ttu-id="77afa-419">Además de las prácticas probadas para [Todos los servicios](#allservices) descritas anteriormente, las siguientes prácticas probadas se aplican específicamente a Blob service.</span><span class="sxs-lookup"><span data-stu-id="77afa-419">In addition to the proven practices for [All Services](#allservices) described previously, the following proven practices apply specifically to the blob service.</span></span>  

### <a name="blob-specific-scalability-targets"></a><span data-ttu-id="77afa-420">Objetivos de escalabilidad específicos de blob</span><span class="sxs-lookup"><span data-stu-id="77afa-420">Blob-Specific Scalability Targets</span></span>
#### <span data-ttu-id="77afa-421"><a name="subheading46"></a>Acceso simultáneo a un único objeto por parte de varios clientes</span><span class="sxs-lookup"><span data-stu-id="77afa-421"><a name="subheading46"></a>Multiple clients accessing a single object concurrently</span></span>
<span data-ttu-id="77afa-422">Si tiene un gran número de clientes que acceden de forma simultánea a un único objeto, debe considerar los objetivos de escalabilidad por objeto y por cuenta de almacenamiento.</span><span class="sxs-lookup"><span data-stu-id="77afa-422">If you have a large number of clients accessing a single object concurrently you will need to consider per object and storage account scalability targets.</span></span> <span data-ttu-id="77afa-423">El número exacto de los clientes que pueden tener acceso a un único objeto variará en función de factores como el número de clientes que soliciten el objeto simultáneamente, el tamaño del objeto o las condiciones de la red, entre otros.</span><span class="sxs-lookup"><span data-stu-id="77afa-423">The exact number of clients that can access a single object will vary depending on factors such as the number of clients requesting the object simultaneously, the size of the object, network conditions etc.</span></span>

<span data-ttu-id="77afa-424">Si el objeto se puede distribuir a través de una red CDN, como imágenes o vídeos procedentes de un sitio web, deberá utilizar una CDN.</span><span class="sxs-lookup"><span data-stu-id="77afa-424">If the object can be distributed through a CDN such as images or videos served from a website then you should use a CDN.</span></span> <span data-ttu-id="77afa-425">Consulte [aquí](#subheading5).</span><span class="sxs-lookup"><span data-stu-id="77afa-425">See [here](#subheading5).</span></span>

<span data-ttu-id="77afa-426">En otros escenarios, como las simulaciones científicas, donde los datos son confidenciales, tiene dos opciones.</span><span class="sxs-lookup"><span data-stu-id="77afa-426">In other scenarios such as scientific simulations where the data is confidential you have two options.</span></span> <span data-ttu-id="77afa-427">La primera es escalonar el acceso de la carga de trabajo para que se acceda al objeto a lo largo de un período, en lugar de hacerlo simultáneamente.</span><span class="sxs-lookup"><span data-stu-id="77afa-427">The first is to stagger your workload's access such that the object is accessed over a period of time vs being accessed simultaneously.</span></span> <span data-ttu-id="77afa-428">Como alternativa, puede copiar el objeto temporalmente en varias cuentas de almacenamiento, lo que aumenta el número total de IOPS por objeto y entre cuentas de almacenamiento.</span><span class="sxs-lookup"><span data-stu-id="77afa-428">Alternatively, you can temporarily copy the object to multiple storage accounts thus increasing the total IOPS per object and across storage accounts.</span></span> <span data-ttu-id="77afa-429">En algunas pruebas descubrimos que unas 25 VM podrían descargar simultáneamente un blob de 100 GB en paralelo (cada VM ha puesto en paralelo la descarga mediante 32 subprocesos).</span><span class="sxs-lookup"><span data-stu-id="77afa-429">In limited testing we found that around 25 VMs could simultaneously download a 100GB blob in parallel (each VM was parallelizing the download using 32 threads).</span></span> <span data-ttu-id="77afa-430">Si tiene 100 clientes que necesitan tener acceso al objeto, primero cópielo en una segunda cuenta de almacenamiento y después permita que el primer grupo de 50 VM acceda al primer blob y que el segundo grupo de 50 VM acceda al segundo blob.</span><span class="sxs-lookup"><span data-stu-id="77afa-430">If you had 100 clients needing to access the object, first copy it to a second storage account and then have the first 50 VMs access the first blob and the second 50 VMs access the second blob.</span></span> <span data-ttu-id="77afa-431">Los resultados varían según el comportamiento de las aplicaciones, por lo que debe realizar las pruebas durante el diseño.</span><span class="sxs-lookup"><span data-stu-id="77afa-431">Results will vary depending on your applications behavior so you should test this during design.</span></span> 

#### <span data-ttu-id="77afa-432"><a name="subheading16"></a>Ancho de banda y operaciones por blob</span><span class="sxs-lookup"><span data-stu-id="77afa-432"><a name="subheading16"></a>Bandwidth and operations per Blob</span></span>
<span data-ttu-id="77afa-433">Puede realizar operaciones de lectura y escritura en un solo blob a una velocidad máxima de 60 MB/segundos (lo que equivale a 480 Mbps aproximadamente, lo cual supera las capacidades de muchas redes de cliente, incluida la tarjeta NIC física del dispositivo cliente).</span><span class="sxs-lookup"><span data-stu-id="77afa-433">You can read or write to a single blob at up to a maximum of 60 MB/second (this is approximately 480 Mbps which exceeds the capabilities of many client side networks (including the physical NIC on the client device).</span></span> <span data-ttu-id="77afa-434">Además, un solo blob admite hasta 500 solicitudes por segundo.</span><span class="sxs-lookup"><span data-stu-id="77afa-434">In addition, a single blob supports up to 500 requests per second.</span></span> <span data-ttu-id="77afa-435">Si tiene varios clientes que necesitan leer el mismo blob y podría superar estos límites, debe plantearse el uso de una red CDN para distribuir dicho blob.</span><span class="sxs-lookup"><span data-stu-id="77afa-435">If you have multiple clients that need to read the same blob and you might exceed these limits, you should consider using a CDN for distributing the blob.</span></span>  

<span data-ttu-id="77afa-436">Para obtener más información sobre el rendimiento objetivo para blobs, consulte [Objetivos de escalabilidad y rendimiento de Azure Storage](storage-scalability-targets.md).</span><span class="sxs-lookup"><span data-stu-id="77afa-436">For more information about target throughput for blobs, see [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span>  

### <a name="copying-and-moving-blobs"></a><span data-ttu-id="77afa-437">Copia y movimiento de blobs</span><span class="sxs-lookup"><span data-stu-id="77afa-437">Copying and Moving Blobs</span></span>
#### <span data-ttu-id="77afa-438"><a name="subheading17"></a>Copia de blobs</span><span class="sxs-lookup"><span data-stu-id="77afa-438"><a name="subheading17"></a>Copy Blob</span></span>
<span data-ttu-id="77afa-439">La versión del 12/02/2012 de la API de REST de almacenamiento introdujo la capacidad útil de copiar blobs entre cuentas: una aplicación cliente puede indicar al servicio de almacenamiento que copie un blob desde otro origen (posiblemente, en una cuenta de almacenamiento diferente) y, a continuación, dejar que el servicio realice la copia asincrónicamente.</span><span class="sxs-lookup"><span data-stu-id="77afa-439">The storage REST API version 2012-02-12 introduced the useful ability to copy blobs across accounts: a client application can instruct the storage service to copy a blob from another source (possibly in a different storage account), and then let the service perform the copy asynchronously.</span></span> <span data-ttu-id="77afa-440">Esto puede reducir significativamente el ancho de banda necesario para la aplicación cuando migra datos desde otras cuentas de almacenamiento porque no necesita descargar y cargar los datos.</span><span class="sxs-lookup"><span data-stu-id="77afa-440">This can significantly reduce the bandwidth needed for the application when you are migrating data from other storage accounts because you do not need to download and upload the data.</span></span>  

<span data-ttu-id="77afa-441">Una consideración, sin embargo, es que, cuando realiza copias entre cuentas de almacenamiento, no hay una garantía de tiempo sobre cuándo se completará la copia.</span><span class="sxs-lookup"><span data-stu-id="77afa-441">One consideration, however, is that, when copying between storage accounts, there is no time guarantee on when the copy will complete.</span></span> <span data-ttu-id="77afa-442">Si la aplicación necesita completar una copia de blobs rápidamente bajo su control, puede ser mejor copiar dicho blob descargándolo a la máquina virtual y, a continuación, cargándolo en el destino.</span><span class="sxs-lookup"><span data-stu-id="77afa-442">If your application needs to complete a blob copy quickly under your control, it may be better to copy the blob by downloading it to a VM and then uploading it to the destination.</span></span>  <span data-ttu-id="77afa-443">Para conseguir previsibilidad completa en esa situación, asegúrese de que la copia se realiza por una máquina virtual que se ejecuta en la misma región de Azure ya que, de lo contrario, las condiciones de la red pueden (y probablemente lo harán) afectar al rendimiento de la copia.</span><span class="sxs-lookup"><span data-stu-id="77afa-443">For full predictability in that situation, ensure that the copy is performed by a VM running in the same Azure region, or else network conditions may (and probably will) affect your copy performance.</span></span>  <span data-ttu-id="77afa-444">Además, puede supervisar el progreso de una copia asincrónica mediante programación.</span><span class="sxs-lookup"><span data-stu-id="77afa-444">In addition, you can monitor the progress of an asynchronous copy programmatically.</span></span>  

<span data-ttu-id="77afa-445">Tenga en cuenta que las copias dentro de la misma cuenta de almacenamiento, por lo general, se completan rápidamente.</span><span class="sxs-lookup"><span data-stu-id="77afa-445">Note that copies within the same storage account itself are generally completed quickly.</span></span>  

<span data-ttu-id="77afa-446">Para obtener más información, consulte [Copia de blobs](http://msdn.microsoft.com/library/azure/dd894037.aspx).</span><span class="sxs-lookup"><span data-stu-id="77afa-446">For more information, see [Copy Blob](http://msdn.microsoft.com/library/azure/dd894037.aspx).</span></span>  

#### <span data-ttu-id="77afa-447"><a name="subheading18"></a>Uso de AzCopy</span><span class="sxs-lookup"><span data-stu-id="77afa-447"><a name="subheading18"></a>Use AzCopy</span></span>
<span data-ttu-id="77afa-448">El equipo de Azure Storage ha lanzado "AzCopy", una herramienta de línea de comandos diseñada para facilitar la transferencia masiva de muchos blobs a, desde y entre cuentas de almacenamiento.</span><span class="sxs-lookup"><span data-stu-id="77afa-448">The Azure Storage team has released a command-line tool "AzCopy" that is meant to help with bulk transferring many blobs to, from, and across storage accounts.</span></span>  <span data-ttu-id="77afa-449">Esta herramienta está optimizada para este escenario y puede lograr altas tasas de transferencia.</span><span class="sxs-lookup"><span data-stu-id="77afa-449">This tool is optimized for this scenario, and can achieve high transfer rates.</span></span>  <span data-ttu-id="77afa-450">Su uso es muy recomendable para escenarios de carga, descarga y copia en masa.</span><span class="sxs-lookup"><span data-stu-id="77afa-450">Its use is encouraged for bulk upload, download, and copy scenarios.</span></span> <span data-ttu-id="77afa-451">Para obtener más información, consulte [Transferencia de datos con la utilidad en línea de comandos AzCopy](storage-use-azcopy.md).</span><span class="sxs-lookup"><span data-stu-id="77afa-451">To learn more about it and download it, see [Transfer data with the AzCopy Command-Line Utility](storage-use-azcopy.md).</span></span>  

#### <span data-ttu-id="77afa-452"><a name="subheading19"></a>Servicio Azure Import/Export</span><span class="sxs-lookup"><span data-stu-id="77afa-452"><a name="subheading19"></a>Azure Import/Export Service</span></span>
<span data-ttu-id="77afa-453">Para volúmenes muy grandes de datos (más de 1 TB), Azure Storage ofrece el servicio Import/Export, que permite realizar operaciones de carga y descarga desde Blob Storage enviando unidades de disco duro.</span><span class="sxs-lookup"><span data-stu-id="77afa-453">For very large volumes of data (more than 1TB), the Azure Storage offers the Import/Export service, which allows for uploading and downloading from blob storage by shipping hard drives.</span></span>  <span data-ttu-id="77afa-454">Puede poner sus datos en una unidad de disco duro y enviarla a Microsoft para cargarlos o enviar una unidad de disco duro vacía a Microsoft para descargar datos.</span><span class="sxs-lookup"><span data-stu-id="77afa-454">You can put your data on a hard drive and send it to Microsoft for upload, or send a blank hard drive to Microsoft to download data.</span></span>  <span data-ttu-id="77afa-455">Para más información, consulte [Uso del servicio Microsoft Azure Import/Export para transferir datos a Blob Storage](../storage-import-export-service.md).</span><span class="sxs-lookup"><span data-stu-id="77afa-455">For more information, see [Use the Microsoft Azure Import/Export Service to Transfer Data to Blob Storage](../storage-import-export-service.md).</span></span>  <span data-ttu-id="77afa-456">Esto puede ser mucho más eficiente que cargar y descargar este volumen de datos a través de la red.</span><span class="sxs-lookup"><span data-stu-id="77afa-456">This can be much more efficient than uploading/downloading this volume of data over the network.</span></span>  

### <span data-ttu-id="77afa-457"><a name="subheading20"></a>Uso de metadatos</span><span class="sxs-lookup"><span data-stu-id="77afa-457"><a name="subheading20"></a>Use metadata</span></span>
<span data-ttu-id="77afa-458">El Blob service admite solicitudes de encabezado, que pueden incluir metadatos acerca del blob.</span><span class="sxs-lookup"><span data-stu-id="77afa-458">The blob service supports head requests, which can include metadata about the blob.</span></span> <span data-ttu-id="77afa-459">Por ejemplo, si su aplicación necesita los datos EXIF fuera de una foto, podría recuperar la foto y extraerlos.</span><span class="sxs-lookup"><span data-stu-id="77afa-459">For example, if your application needed the EXIF data out of a photo, it could retrieve the photo and extract it.</span></span> <span data-ttu-id="77afa-460">Para ahorrar ancho de banda y mejorar el rendimiento, la aplicación puede almacenar los datos de EXIF en los metadatos del blob cuando la aplicación haya cargado la foto: posteriormente, puede recuperar los datos de EXIF de los metadatos mediante una única solicitud HEAD, lo que permite ahorrar mucho ancho de banda y el tiempo de procesamiento necesario para extraer los datos de EXIF cada vez que se lee el blob.</span><span class="sxs-lookup"><span data-stu-id="77afa-460">To save bandwidth and improve performance, your application could store the EXIF data in the blob's metadata when the application uploaded the photo: you can then retrieve the EXIF data in metadata using only a HEAD request, saving significant bandwidth and the processing time needed to extract the EXIF data each time the blob is read.</span></span> <span data-ttu-id="77afa-461">Esto sería útil en escenarios donde solamente necesita los metadatos y no el contenido completo de un blob.</span><span class="sxs-lookup"><span data-stu-id="77afa-461">This would be useful in scenarios where you only need the metadata, and not the full content of a blob.</span></span>  <span data-ttu-id="77afa-462">Tenga en cuenta que solamente se pueden almacenar 8 KB de metadatos por blob (el servicio no aceptará una solicitud para almacenar más que eso), por lo que si los datos no caben en ese tamaño, no podrá usar este enfoque.</span><span class="sxs-lookup"><span data-stu-id="77afa-462">Note that only 8 KB of metadata can be stored per blob (the service will not accept a request to store more than that), so if the data does not fit in that size, you may not be able to use this approach.</span></span>  

<span data-ttu-id="77afa-463">Para ver un ejemplo de cómo obtener los metadatos de un blob mediante .NET, consulte [Establecer y recuperar propiedades y metadatos](../blobs/storage-properties-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="77afa-463">For an example of how to get a blob's metadata using .NET, see [Set and Retrieve Properties and Metadata](../blobs/storage-properties-metadata.md).</span></span>  

### <a name="uploading-fast"></a><span data-ttu-id="77afa-464">Carga rápida</span><span class="sxs-lookup"><span data-stu-id="77afa-464">Uploading Fast</span></span>
<span data-ttu-id="77afa-465">Para cargar blobs rápidamente, la primera pregunta es: ¿carga un blob o muchos?</span><span class="sxs-lookup"><span data-stu-id="77afa-465">To upload blobs fast, the first question to answer is: are you uploading one blob or many?</span></span>  <span data-ttu-id="77afa-466">Utilice las instrucciones siguientes para determinar el método correcto que va a utilizar dependiendo del escenario.</span><span class="sxs-lookup"><span data-stu-id="77afa-466">Use the below guidance to determine the correct method to use depending on your scenario.</span></span>  

#### <span data-ttu-id="77afa-467"><a name="subheading21"></a>Carga de un blob grande rápidamente</span><span class="sxs-lookup"><span data-stu-id="77afa-467"><a name="subheading21"></a>Uploading one large blob quickly</span></span>
<span data-ttu-id="77afa-468">Para cargar un solo blob grande rápidamente, la aplicación cliente debe cargar sus bloques o páginas en paralelo (teniendo en cuenta los objetivos de escalabilidad para blobs individuales y la cuenta de almacenamiento como un todo).</span><span class="sxs-lookup"><span data-stu-id="77afa-468">To upload a single large blob quickly, your client application should upload its blocks or pages in parallel (being mindful of the scalability targets for individual blobs and the storage account as a whole).</span></span>  <span data-ttu-id="77afa-469">Tenga en cuenta que las bibliotecas del cliente de Storage RTM proporcionadas por Microsoft (.NET y Java) tienen la capacidad de hacer esto.</span><span class="sxs-lookup"><span data-stu-id="77afa-469">Note that the official Microsoft-provided RTM Storage Client libraries (.NET, Java) have the ability to do this.</span></span>  <span data-ttu-id="77afa-470">Para cada una de las bibliotecas, use el objeto o propiedad que se especifica a continuación para establecer el nivel de simultaneidad:</span><span class="sxs-lookup"><span data-stu-id="77afa-470">For each of the libraries, use the below specified object/property to set the level of concurrency:</span></span>  

* <span data-ttu-id="77afa-471">.NET: establezca ParallelOperationThreadCount en un objeto BlobRequestOptions para usar.</span><span class="sxs-lookup"><span data-stu-id="77afa-471">.NET: Set ParallelOperationThreadCount on a BlobRequestOptions object to be used.</span></span>
* <span data-ttu-id="77afa-472">Java/Android: use BlobRequestOptions.setConcurrentRequestCount()</span><span class="sxs-lookup"><span data-stu-id="77afa-472">Java/Android: Use BlobRequestOptions.setConcurrentRequestCount()</span></span>
* <span data-ttu-id="77afa-473">Node.js: use parallelOperationThreadCount en las opciones de solicitud o Blob service.</span><span class="sxs-lookup"><span data-stu-id="77afa-473">Node.js: Use parallelOperationThreadCount on either the request options or on the blob service.</span></span>
* <span data-ttu-id="77afa-474">C++: use el método blob_request_options::set_parallelism_factor.</span><span class="sxs-lookup"><span data-stu-id="77afa-474">C++: Use the blob_request_options::set_parallelism_factor method.</span></span>

#### <span data-ttu-id="77afa-475"><a name="subheading22"></a>Carga de muchos blobs rápidamente</span><span class="sxs-lookup"><span data-stu-id="77afa-475"><a name="subheading22"></a>Uploading many blobs quickly</span></span>
<span data-ttu-id="77afa-476">Para cargar muchos blobs rápidamente, cárguelos en paralelo.</span><span class="sxs-lookup"><span data-stu-id="77afa-476">To upload many blobs quickly, upload blobs in parallel.</span></span> <span data-ttu-id="77afa-477">Este método es más rápido que cargar blobs de uno en uno con cargas de bloque paralelas porque distribuye la carga entre varias particiones del servicio Storage.</span><span class="sxs-lookup"><span data-stu-id="77afa-477">This is faster than uploading single blobs at a time with parallel block uploads because it spreads the upload across multiple partitions of the storage service.</span></span> <span data-ttu-id="77afa-478">Un solo blob únicamente admite un rendimiento de 60 MB/segundo (aproximadamente 480 Mbps).</span><span class="sxs-lookup"><span data-stu-id="77afa-478">A single blob only supports a throughput of 60 MB/second (approximately 480 Mbps).</span></span> <span data-ttu-id="77afa-479">En el momento de escribir estas líneas, una cuenta LRS con sede en Estados Unidos admite entradas de hasta 20 Gbps, que es mucho más que la capacidad de proceso admitida por un blob individual.</span><span class="sxs-lookup"><span data-stu-id="77afa-479">At the time of writing, a US-based LRS account supports up to 20 Gbps ingress which is far more than the throughput supported by an individual blob.</span></span>  <span data-ttu-id="77afa-480">[AzCopy](#subheading18) realiza cargas en paralelo de forma predeterminada y se recomienda para este escenario.</span><span class="sxs-lookup"><span data-stu-id="77afa-480">[AzCopy](#subheading18) performs uploads in parallel by default, and is recommended for this scenario.</span></span>  

### <span data-ttu-id="77afa-481"><a name="subheading23"></a>Elección del tipo correcto de blob</span><span class="sxs-lookup"><span data-stu-id="77afa-481"><a name="subheading23"></a>Choosing the correct type of blob</span></span>
<span data-ttu-id="77afa-482">Azure Storage admite dos tipos de blobs: *de página* y *de bloque*.</span><span class="sxs-lookup"><span data-stu-id="77afa-482">Azure Storage supports two types of blob: *page* blobs and *block* blobs.</span></span> <span data-ttu-id="77afa-483">Para un escenario de uso dado, el tipo de blob que elija afectará al rendimiento y escalabilidad de la solución.</span><span class="sxs-lookup"><span data-stu-id="77afa-483">For a given usage scenario, your choice of blob type will affect the performance and scalability of your solution.</span></span> <span data-ttu-id="77afa-484">Los blobs en bloques son apropiados si desea cargar eficazmente grandes cantidades de datos: por ejemplo, una aplicación cliente puede necesitar cargar fotos o vídeos a Blob Storage.</span><span class="sxs-lookup"><span data-stu-id="77afa-484">Block blobs are appropriate when you want to upload large amounts of data efficiently: for example, a client application may need to upload photos or video to blob storage.</span></span> <span data-ttu-id="77afa-485">Los blobs de página son apropiados si la aplicación necesita realizar operaciones de escritura aleatorias en los datos: por ejemplo, los discos duros virtuales de Azure se almacenan como blobs de página.</span><span class="sxs-lookup"><span data-stu-id="77afa-485">Page blobs are appropriate if the application needs to perform random writes on the data: for example, Azure VHDs are stored as page blobs.</span></span>  

<span data-ttu-id="77afa-486">Para más información, consulte [Descripción de los blobs en bloques, en anexos y en páginas](http://msdn.microsoft.com/library/azure/ee691964.aspx).</span><span class="sxs-lookup"><span data-stu-id="77afa-486">For more information, see [Understanding Block Blobs, Append Blobs, and Page Blobs](http://msdn.microsoft.com/library/azure/ee691964.aspx).</span></span>  

## <a name="tables"></a><span data-ttu-id="77afa-487">Tablas</span><span class="sxs-lookup"><span data-stu-id="77afa-487">Tables</span></span>
<span data-ttu-id="77afa-488">Además de las prácticas probadas para [Todos los servicios](#allservices) descritas anteriormente, las siguientes prácticas probadas se aplican específicamente a Table service.</span><span class="sxs-lookup"><span data-stu-id="77afa-488">In addition to the proven practices for [All Services](#allservices) described previously, the following proven practices apply specifically to the table service.</span></span>  

### <span data-ttu-id="77afa-489"><a name="subheading24"></a>Objetivos de escalabilidad específicos de tabla</span><span class="sxs-lookup"><span data-stu-id="77afa-489"><a name="subheading24"></a>Table-Specific Scalability Targets</span></span>
<span data-ttu-id="77afa-490">Además de las limitaciones de ancho de banda de una cuenta de almacenamiento completa, las tablas tienen el siguiente límite de escalabilidad específico.</span><span class="sxs-lookup"><span data-stu-id="77afa-490">In addition to the bandwidth limitations of an entire storage account, tables have the following specific scalability limit.</span></span>  <span data-ttu-id="77afa-491">Tenga en cuenta que el sistema equilibrará la carga a medida que el tráfico aumente, pero si este tráfico tiene ráfagas repentinas, no podrá obtener este volumen de rendimiento inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="77afa-491">Note that the system will load balance as your traffic increases, but if your traffic has sudden bursts, you may not be able to get this volume of throughput immediately.</span></span>  <span data-ttu-id="77afa-492">Si su patrón tiene ráfagas, es de esperar que se produzcan limitaciones y/o tiempos de espera durante dichas ráfagas, ya que el servicio Storage equilibrará la carga automáticamente fuera de la tabla.</span><span class="sxs-lookup"><span data-stu-id="77afa-492">If your pattern has bursts, you should expect to see throttling and/or timeouts during the burst as the storage service automatically load balances out your table.</span></span>  <span data-ttu-id="77afa-493">El aumento lento generalmente tiene mejores resultados ya que proporciona al sistema tiempo para equilibrar la carga apropiadamente.</span><span class="sxs-lookup"><span data-stu-id="77afa-493">Ramping up slowly generally has better results as it gives the system time to load balance appropriately.</span></span>  

#### <a name="entities-per-second-account"></a><span data-ttu-id="77afa-494">Entidades por segundo (cuenta)</span><span class="sxs-lookup"><span data-stu-id="77afa-494">Entities per Second (Account)</span></span>
<span data-ttu-id="77afa-495">El límite de escalabilidad para el acceso a tablas es de hasta 20.000 unidades (1 KB cada una) por segundo para una cuenta.</span><span class="sxs-lookup"><span data-stu-id="77afa-495">The scalability limit for accessing tables is up to 20,000 entities (1KB each) per second for an account.</span></span>  <span data-ttu-id="77afa-496">En general, cada entidad que se inserta, actualiza, elimina o examina, cuenta para este objetivo.</span><span class="sxs-lookup"><span data-stu-id="77afa-496">In general, each entity that is inserted, updated, deleted, or scanned counts toward this target.</span></span>  <span data-ttu-id="77afa-497">Por tanto, una inserción por lotes que contiene 100 entidades contaría como 100 entidades.</span><span class="sxs-lookup"><span data-stu-id="77afa-497">So a batch insert that contains 100 entities would count as 100 entities.</span></span>  <span data-ttu-id="77afa-498">Una consulta que examina 1.000 y devuelve 5, contaría como 1.000 entidades.</span><span class="sxs-lookup"><span data-stu-id="77afa-498">A query that scans 1000 entities and returns 5 would count as 1000 entities.</span></span>  

#### <a name="entities-per-second-partition"></a><span data-ttu-id="77afa-499">Entidades por segundo (partición)</span><span class="sxs-lookup"><span data-stu-id="77afa-499">Entities per Second (Partition)</span></span>
<span data-ttu-id="77afa-500">Dentro de una sola partición, el objetivo de escalabilidad para obtener acceso a las tablas es de 2.000 entidades (1 KB cada una) por segundo, usando el mismo recuento descrito en la sección anterior.</span><span class="sxs-lookup"><span data-stu-id="77afa-500">Within a single partition, the scalability target for accessing tables is 2,000 entities (1KB each) per second, using the same counting as described in the previous section.</span></span>  

### <a name="configuration"></a><span data-ttu-id="77afa-501">Configuración</span><span class="sxs-lookup"><span data-stu-id="77afa-501">Configuration</span></span>
<span data-ttu-id="77afa-502">En esta sección se enumeran varias configuraciones rápidas que puede usar para realizar mejoras de rendimiento significativas en Table service:</span><span class="sxs-lookup"><span data-stu-id="77afa-502">This section lists several quick configuration settings that you can use to make significant performance improvements in the table service:</span></span>  

#### <span data-ttu-id="77afa-503"><a name="subheading25"></a>Uso de JSON</span><span class="sxs-lookup"><span data-stu-id="77afa-503"><a name="subheading25"></a>Use JSON</span></span>
<span data-ttu-id="77afa-504">A partir de la versión del 15 de agosto de 2013 del servicio Storage, Table service admite el uso de JSON en lugar del formato AtomPub basado en XML para transferir datos de tabla.</span><span class="sxs-lookup"><span data-stu-id="77afa-504">Beginning with storage service version 2013-08-15, the table service supports using JSON instead of the XML-based AtomPub format for transferring table data.</span></span> <span data-ttu-id="77afa-505">Esto puede reducir los tamaños de carga hasta en un 75 % y puede mejorar significativamente el rendimiento de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="77afa-505">This can reduce payload sizes by as much as 75% and can significantly improve the performance of your application.</span></span>

<span data-ttu-id="77afa-506">Para más información, consulte la publicación [Tablas de Microsoft Azure: introducción a JSON](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/05/windows-azure-tables-introducing-json.aspx) y [Payload Format for Table Service Operations](http://msdn.microsoft.com/library/azure/dn535600.aspx) (Formato de carga para las operaciones de Table service).</span><span class="sxs-lookup"><span data-stu-id="77afa-506">For more information, see the post [Microsoft Azure Tables: Introducing JSON](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/05/windows-azure-tables-introducing-json.aspx) and [Payload Format for Table Service Operations](http://msdn.microsoft.com/library/azure/dn535600.aspx).</span></span>

#### <span data-ttu-id="77afa-507"><a name="subheading26"></a>Desactivación de Nagle</span><span class="sxs-lookup"><span data-stu-id="77afa-507"><a name="subheading26"></a>Nagle Off</span></span>
<span data-ttu-id="77afa-508">El algoritmo de Nagle está ampliamente implementado en redes TCP/IP como medio de mejorar el rendimiento de la red.</span><span class="sxs-lookup"><span data-stu-id="77afa-508">Nagle's algorithm is widely implemented across TCP/IP networks as a means to improve network performance.</span></span> <span data-ttu-id="77afa-509">Sin embargo, no es óptimo en todas las situaciones (como por ejemplo en entornos altamente interactivos).</span><span class="sxs-lookup"><span data-stu-id="77afa-509">However, it is not optimal in all circumstances (such as highly interactive environments).</span></span> <span data-ttu-id="77afa-510">En el caso de Azure Storage, el algoritmo de Nagle tiene un impacto negativo en el rendimiento de solicitudes que se realizan a los servicios Table y Queue; si es posible, debe deshabilitarlo.</span><span class="sxs-lookup"><span data-stu-id="77afa-510">For Azure Storage, Nagle's algorithm has a negative impact on the performance of requests to the table and queue services, and you should disable it if possible.</span></span>  

<span data-ttu-id="77afa-511">Para más información, consulte la entrada del blog para ver la entrada del blog [Nagle's Algorithm is Not Friendly towards Small Requests](http://blogs.msdn.com/b/windowsazurestorage/archive/2010/06/25/nagle-s-algorithm-is-not-friendly-towards-small-requests.aspx) (El algoritmo de Nagle no es idóneo para pequeñas solicitudes), donde se explican los motivos por los que el algoritmo de Nagle no interactúa bien con solicitudes de tabla y cola, y cómo deshabilitarlo en una aplicación cliente.</span><span class="sxs-lookup"><span data-stu-id="77afa-511">For more information, see our blog post [Nagle's Algorithm is Not Friendly towards Small Requests](http://blogs.msdn.com/b/windowsazurestorage/archive/2010/06/25/nagle-s-algorithm-is-not-friendly-towards-small-requests.aspx), which explains why Nagle's algorithm interacts poorly with table and queue requests, and shows how to disable it in your client application.</span></span>  

### <a name="schema"></a><span data-ttu-id="77afa-512">SCHEMA (ESQUEMA)</span><span class="sxs-lookup"><span data-stu-id="77afa-512">Schema</span></span>
<span data-ttu-id="77afa-513">La forma de representar los datos y realizar consultas en los mismos es el factor más importante por sí mismo que afecta al rendimiento de Table service.</span><span class="sxs-lookup"><span data-stu-id="77afa-513">How you represent and query your data is the biggest single factor that affects the performance of the table service.</span></span> <span data-ttu-id="77afa-514">Aunque cada aplicación es diferente, en esta sección se describen algunas prácticas probadas generales relacionadas con:</span><span class="sxs-lookup"><span data-stu-id="77afa-514">While every application is different, this section outlines some general proven practices that relate to:</span></span>  

* <span data-ttu-id="77afa-515">Diseño de tablas</span><span class="sxs-lookup"><span data-stu-id="77afa-515">Table design</span></span>
* <span data-ttu-id="77afa-516">Consultas eficientes</span><span class="sxs-lookup"><span data-stu-id="77afa-516">Efficient queries</span></span>
* <span data-ttu-id="77afa-517">Actualizaciones de datos eficientes</span><span class="sxs-lookup"><span data-stu-id="77afa-517">Efficient data updates</span></span>  

#### <span data-ttu-id="77afa-518"><a name="subheading27"></a>Tablas y particiones</span><span class="sxs-lookup"><span data-stu-id="77afa-518"><a name="subheading27"></a>Tables and partitions</span></span>
<span data-ttu-id="77afa-519">Las tablas se dividen en dos particiones.</span><span class="sxs-lookup"><span data-stu-id="77afa-519">Tables are divided into partitions.</span></span> <span data-ttu-id="77afa-520">Cada entidad almacenada en una partición comparte la misma clave de partición y tiene una clave de fila única para identificarla dentro de esa partición.</span><span class="sxs-lookup"><span data-stu-id="77afa-520">Every entity stored in a partition shares the same partition key and has a unique row key to identify it within that partition.</span></span> <span data-ttu-id="77afa-521">Las particiones proporcionan ventajas pero también presentan limitaciones de escalabilidad.</span><span class="sxs-lookup"><span data-stu-id="77afa-521">Partitions provide benefits but also introduce scalability limits.</span></span>  

* <span data-ttu-id="77afa-522">Ventajas: puede actualizar entidades de la misma partición en una sola transacción por lotes atómica que contenga hasta 100 operaciones de almacenamiento independientes (límite de tamaño total de 4 MB).</span><span class="sxs-lookup"><span data-stu-id="77afa-522">Benefits: You can update entities in the same partition in a single, atomic, batch transaction that contains up to 100 separate storage operations (limit of 4MB total size).</span></span> <span data-ttu-id="77afa-523">Suponiendo que se recupera el mismo número de entidades, también puede consultar datos dentro de una sola partición más eficientemente que los datos que se extienden por particiones (siga leyendo para conocer más recomendaciones sobre la consulta de datos de tabla).</span><span class="sxs-lookup"><span data-stu-id="77afa-523">Assuming the same number of entities to be retrieved, you can also query data within a single partition more efficiently than data that spans partitions (though read on for further recommendations on querying table data).</span></span>
* <span data-ttu-id="77afa-524">Limite de escalabilidad: no se puede realizar el equilibrio de carga en el acceso a entidades almacenadas en una sola partición porque las particiones admiten transacciones por lotes atómicas.</span><span class="sxs-lookup"><span data-stu-id="77afa-524">Scalability limit: Access to entities stored in a single partition cannot be load-balanced because partitions support atomic batch transactions.</span></span> <span data-ttu-id="77afa-525">Por esta razón, el objetivo de escalabilidad para una partición de tabla individual es inferior al de Table service como un todo.</span><span class="sxs-lookup"><span data-stu-id="77afa-525">For this reason, the scalability target for an individual table partition is lower than for the table service as a whole.</span></span>  

<span data-ttu-id="77afa-526">Debido a estas características de tablas y particiones, debe adoptar los siguientes principios de diseño:</span><span class="sxs-lookup"><span data-stu-id="77afa-526">Because of these characteristics of tables and partitions, you should adopt the following design principles:</span></span>  

* <span data-ttu-id="77afa-527">Los datos que su aplicación cliente actualiza o consulta frecuentemente en la misma unidad lógica de trabajo se deben ubicar en la misma partición.</span><span class="sxs-lookup"><span data-stu-id="77afa-527">Data that your client application frequently updated or queried in the same logical unit of work should be located in the same partition.</span></span>  <span data-ttu-id="77afa-528">Esto puede ser porque la aplicación agrega escrituras o porque desea aprovechar las operaciones por lotes atómicas.</span><span class="sxs-lookup"><span data-stu-id="77afa-528">This may be because your application is aggregating writes, or because you want to take advantage of atomic batch operations.</span></span>  <span data-ttu-id="77afa-529">Asimismo, los datos de una sola partición pueden ser consultados de forma más eficiente en una sola consulta que los datos que se encuentran repartidos por particiones.</span><span class="sxs-lookup"><span data-stu-id="77afa-529">Also, data in a single partition can be more efficiently queried in a single query than data across partitions.</span></span>
* <span data-ttu-id="77afa-530">Los datos que la aplicación cliente no inserta, actualiza o consulta en la misma unidad lógica de trabajo (una consulta o actualización por lotes) se deben encontrar en particiones independientes.</span><span class="sxs-lookup"><span data-stu-id="77afa-530">Data that your client application does not insert/update or query in the same logical unit of work (single query or batch update) should be located in separate partitions.</span></span>  <span data-ttu-id="77afa-531">Una nota importante es que no hay límite en el número de claves de partición en una sola tabla, por lo que tener millones de claves de partición no es un problema y no afectará al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="77afa-531">One important note is that there is no limit to the number of partition keys in a single table, so having millions of partition keys is not a problem and will not impact performance.</span></span>  <span data-ttu-id="77afa-532">Por ejemplo, si la aplicación es un sitio web conocido con inicio de sesión de usuario, el uso del identificador de usuario como clave de partición podría ser una buena elección.</span><span class="sxs-lookup"><span data-stu-id="77afa-532">For example, if your application is a popular website with user login, using the User Id as the partition key could be a good choice.</span></span>  

#### <a name="hot-partitions"></a><span data-ttu-id="77afa-533">Particiones calientes</span><span class="sxs-lookup"><span data-stu-id="77afa-533">Hot Partitions</span></span>
<span data-ttu-id="77afa-534">Una partición caliente es aquella que recibe un porcentaje desproporcionado de tráfico en una cuenta y no se puede realizar un equilibrio de carga en ella porque es una sola partición.</span><span class="sxs-lookup"><span data-stu-id="77afa-534">A hot partition is one that is receiving a disproportionate percentage of the traffic to an account, and cannot be load balanced because it is a single partition.</span></span>  <span data-ttu-id="77afa-535">En general, las particiones calientes se crean de una de dos formas:</span><span class="sxs-lookup"><span data-stu-id="77afa-535">In general, hot partitions are created one of two ways:</span></span>  

##### <span data-ttu-id="77afa-536"><a name="subheading28"></a>Patrones Solo anexar y Solo anteponer</span><span class="sxs-lookup"><span data-stu-id="77afa-536"><a name="subheading28"></a>Append Only and Prepend Only patterns</span></span>
<span data-ttu-id="77afa-537">El patrón "Solo anexar" es aquel en el que todo (o prácticamente todo) el tráfico que llega a una PK dada aumenta y disminuye en función de la hora.</span><span class="sxs-lookup"><span data-stu-id="77afa-537">The "Append Only" pattern is one where all (or nearly all) of the traffic to a given PK increases and decreases according to the current time.</span></span>  <span data-ttu-id="77afa-538">Un ejemplo es si la aplicación usó la fecha actual como clave de partición para datos de registro.</span><span class="sxs-lookup"><span data-stu-id="77afa-538">An example is if your application used the current date as a partition key for log data.</span></span>  <span data-ttu-id="77afa-539">El resultado de esto es que todas las inserciones van a la última partición de la tabla y el sistema no puede equilibrar la carga porque todas las escrituras van al final de la tabla.</span><span class="sxs-lookup"><span data-stu-id="77afa-539">This results in all of the inserts going to the last partition in your table, and the system cannot load balance because all of the writes are going to the end of your table.</span></span>  <span data-ttu-id="77afa-540">Si el volumen del tráfico en esa partición supera el objetivo de escalabilidad de nivel de partición, dará lugar a una limitación.</span><span class="sxs-lookup"><span data-stu-id="77afa-540">If the volume of traffic to that partition exceeds the partition-level scalability target, then it will result in throttling.</span></span>  <span data-ttu-id="77afa-541">Es mejor garantizar que el tráfico se envía a varias particiones para habilitar el equilibrio de carga de las solicitudes en la tabla.</span><span class="sxs-lookup"><span data-stu-id="77afa-541">It's better to ensure that traffic is sent to multiple partitions, to enable load balance the requests across your table.</span></span>  

##### <span data-ttu-id="77afa-542"><a name="subheading29"></a>Datos con mucho tráfico</span><span class="sxs-lookup"><span data-stu-id="77afa-542"><a name="subheading29"></a>High-Traffic Data</span></span>
<span data-ttu-id="77afa-543">Si el esquema de participaciones da lugar a una sola partición que solamente tiene datos y que se utiliza mucho más que otras particiones, también puede ver limitaciones cuando esa partición se aproxime al objetivo de escalabilidad para una sola partición.</span><span class="sxs-lookup"><span data-stu-id="77afa-543">If your partitioning scheme results in a single partition that just has data that is far more used than other partitions, you may also see throttling as that partition approaches the scalability target for a single partition.</span></span>  <span data-ttu-id="77afa-544">Conviene asegurarse de que el esquema de partición no provoca que las particiones individuales se aproximen a los objetivos de escalabilidad.</span><span class="sxs-lookup"><span data-stu-id="77afa-544">It's better to make sure that your partition scheme results in no single partition approaching the scalability targets.</span></span>  

#### <a name="querying"></a><span data-ttu-id="77afa-545">Consultas</span><span class="sxs-lookup"><span data-stu-id="77afa-545">Querying</span></span>
<span data-ttu-id="77afa-546">En esta sección se describen prácticas probadas para realizar consultas en Table service.</span><span class="sxs-lookup"><span data-stu-id="77afa-546">This section describes proven practices for querying the table service.</span></span>  

##### <span data-ttu-id="77afa-547"><a name="subheading30"></a>Ámbito de la consulta</span><span class="sxs-lookup"><span data-stu-id="77afa-547"><a name="subheading30"></a>Query Scope</span></span>
<span data-ttu-id="77afa-548">Hay varias formas de especificar el intervalo de entidades para consultar.</span><span class="sxs-lookup"><span data-stu-id="77afa-548">There are several ways to specify the range of entities to query.</span></span>  <span data-ttu-id="77afa-549">A continuación se muestra un análisis de los usos de cada una de ellas.</span><span class="sxs-lookup"><span data-stu-id="77afa-549">The following is a discussion of the uses of each.</span></span>  

<span data-ttu-id="77afa-550">En general, evite las exploraciones (consultas mayores que una sola entidad), pero si debe realizarlas, intente organizar los datos de forma que dichas exploraciones recuperen los datos necesarios sin explorar o devolver grandes cantidades de entidades innecesarias.</span><span class="sxs-lookup"><span data-stu-id="77afa-550">In general, avoid scans (queries larger than a single entity), but if you must scan, try to organize your data so that your scans retrieve the data you need without scanning or returning significant amounts of entities you don't need.</span></span>  

###### <a name="point-queries"></a><span data-ttu-id="77afa-551">Consultas puntuales</span><span class="sxs-lookup"><span data-stu-id="77afa-551">Point Queries</span></span>
<span data-ttu-id="77afa-552">Una consulta puntual recupera exactamente una entidad.</span><span class="sxs-lookup"><span data-stu-id="77afa-552">A point query retrieves exactly one entity.</span></span> <span data-ttu-id="77afa-553">Lo hace especificando tanto la clave de partición como la clave de fila de la entidad que se va a recuperar.</span><span class="sxs-lookup"><span data-stu-id="77afa-553">It does this by specifying both the partition key and row key of the entity to retrieve.</span></span> <span data-ttu-id="77afa-554">Estas consultas son muy diferentes y debe usarlas siempre que sea posible.</span><span class="sxs-lookup"><span data-stu-id="77afa-554">These queries are very efficient, and you should use them wherever possible.</span></span>  

###### <a name="partition-queries"></a><span data-ttu-id="77afa-555">Consultas de partición</span><span class="sxs-lookup"><span data-stu-id="77afa-555">Partition Queries</span></span>
<span data-ttu-id="77afa-556">Una consulta de partición es una consulta que recupera un conjunto de datos que comparte una clave de partición común.</span><span class="sxs-lookup"><span data-stu-id="77afa-556">A partition query is a query that retrieves a set of data that shares a common partition key.</span></span> <span data-ttu-id="77afa-557">Normalmente, la consulta especifica un intervalo de valores de clave de fila o un intervalo de valores para alguna propiedad de entidad además de una clave de partición.</span><span class="sxs-lookup"><span data-stu-id="77afa-557">Typically, the query specifies a range of row key values or a range of values for some entity property in addition to a partition key.</span></span> <span data-ttu-id="77afa-558">Son menos eficientes que las consultas puntuales y se deben usar con moderación.</span><span class="sxs-lookup"><span data-stu-id="77afa-558">These are less efficient than point queries, and should be used sparingly.</span></span>  

###### <a name="table-queries"></a><span data-ttu-id="77afa-559">Consultas de tabla</span><span class="sxs-lookup"><span data-stu-id="77afa-559">Table Queries</span></span>
<span data-ttu-id="77afa-560">Una consulta de tabla es una consulta que recupera un conjunto de entidades que no comparte una clave de partición común.</span><span class="sxs-lookup"><span data-stu-id="77afa-560">A table query is a query that retrieves a set of entities that does not share a common partition key.</span></span> <span data-ttu-id="77afa-561">Estas consultas no son diferentes y debe evitarlas siempre que sea posible.</span><span class="sxs-lookup"><span data-stu-id="77afa-561">These queries are not efficient and you should avoid them if possible.</span></span>  

##### <span data-ttu-id="77afa-562"><a name="subheading31"></a>Densidad de consulta</span><span class="sxs-lookup"><span data-stu-id="77afa-562"><a name="subheading31"></a>Query Density</span></span>
<span data-ttu-id="77afa-563">Otro factor clave en la eficiencia de las consultas es el número de entidades devueltas comparado con el número de entidades examinadas para encontrar el conjunto devuelto.</span><span class="sxs-lookup"><span data-stu-id="77afa-563">Another key factor in query efficiency is the number of entities returned as compared to the number of entities scanned to find the returned set.</span></span> <span data-ttu-id="77afa-564">Si la aplicación realiza una consulta de tabla con un filtro para un valor de propiedad que solamente comparte el 1 % de los datos, la consulta examinará 100 entidades por cada entidad que devuelva.</span><span class="sxs-lookup"><span data-stu-id="77afa-564">If your application performs a table query with a filter for a property value that only 1% of the data shares, the query will scan 100 entities for every one entity it returns.</span></span> <span data-ttu-id="77afa-565">Los objetivos de escalabilidad de tabla tratados anteriormente están relacionados con el número de entidades que se analizan y no con el número de entidades que se devuelven: una densidad de consulta baja fácilmente puede provocar que Table service limite la aplicación porque debe analizar muchas entidades para recuperar la entidad que está buscando.</span><span class="sxs-lookup"><span data-stu-id="77afa-565">The table scalability targets discussed previously all relate to the number of entities scanned, and not the number of entities returned: a low query density can easily cause the table service to throttle your application because it must scan so many entities to retrieve the entity you are looking for.</span></span>  <span data-ttu-id="77afa-566">Consulte la sección siguiente sobre [desnormalización](#subheading34) para obtener más información sobre cómo evitar esto.</span><span class="sxs-lookup"><span data-stu-id="77afa-566">See the section below on [denormalization](#subheading34) for more information on how to avoid this.</span></span>  

##### <a name="limiting-the-amount-of-data-returned"></a><span data-ttu-id="77afa-567">Limitación de la cantidad de datos devueltos</span><span class="sxs-lookup"><span data-stu-id="77afa-567">Limiting the Amount of Data Returned</span></span>
###### <span data-ttu-id="77afa-568"><a name="subheading32"></a>Filtros</span><span class="sxs-lookup"><span data-stu-id="77afa-568"><a name="subheading32"></a>Filtering</span></span>
<span data-ttu-id="77afa-569">Donde sepa que una consulta va a devolver entidades que no necesita en la aplicación cliente, plantéese el uso de un filtro para reducir el tamaño del conjunto devuelto.</span><span class="sxs-lookup"><span data-stu-id="77afa-569">Where you know that a query will return entities that you don't need in the client application, consider using a filter to reduce the size of the returned set.</span></span> <span data-ttu-id="77afa-570">Aunque las entidades no devueltas al cliente siguen contando para los límites de escalabilidad, el rendimiento de la aplicación mejorará debido a la reducción del tamaño de la carga de red y a la reducción del número de entidades que la aplicación cliente debe procesar.</span><span class="sxs-lookup"><span data-stu-id="77afa-570">While the entities not returned to the client still count toward the scalability limits, your application performance will improve because of the reduced network payload size and the reduced number of entities that your client application must process.</span></span>  <span data-ttu-id="77afa-571">No obstante, tenga en cuenta la nota anterior del apartado [Densidad de las consultas](#subheading31): los objetivos de escalabilidad están relacionados con el número de entidades examinadas, de forma que una consulta que filtre muchas entidades, puede seguir dando lugar a limitaciones aunque se devuelvan pocas entidades.</span><span class="sxs-lookup"><span data-stu-id="77afa-571">See above note on [Query Density](#subheading31), however – the scalability targets relate to the number of entities scanned, so a query that filters out many entities may still result in throttling, even if few entities are returned.</span></span>  

###### <span data-ttu-id="77afa-572"><a name="subheading33"></a>Proyección</span><span class="sxs-lookup"><span data-stu-id="77afa-572"><a name="subheading33"></a>Projection</span></span>
<span data-ttu-id="77afa-573">Si la aplicación cliente solamente necesita un conjunto limitado de propiedades de las entidades de la tabla, puede usar proyección para limitar el tamaño del conjunto de datos devuelto.</span><span class="sxs-lookup"><span data-stu-id="77afa-573">If your client application needs only a limited set of properties from the entities in your table, you can use projection to limit the size of the returned data set.</span></span> <span data-ttu-id="77afa-574">Como en el caso de los filtros, esto ayuda a reducir la carga de red y el procesamiento del cliente.</span><span class="sxs-lookup"><span data-stu-id="77afa-574">As with filtering, this helps to reduce network load and client processing.</span></span>  

##### <span data-ttu-id="77afa-575"><a name="subheading34"></a>Desnormalización</span><span class="sxs-lookup"><span data-stu-id="77afa-575"><a name="subheading34"></a>Denormalization</span></span>
<span data-ttu-id="77afa-576">A diferencia del trabajo con bases de datos relacionales, las prácticas probadas para consultar datos de tabla de forma eficiente conducen a la desnormalización de los datos.</span><span class="sxs-lookup"><span data-stu-id="77afa-576">Unlike working with relational databases, the proven practices for efficiently querying table data lead to denormalizing your data.</span></span> <span data-ttu-id="77afa-577">Es decir, duplicar los mismos datos en varias entidades (una por cada clave que puede usar para encontrar los datos) para minimizar el número de entidades que una consulta debe examinar para encontrar los datos que el cliente necesita, en lugar de tener que examinar grandes números de entidades para encontrar los datos que la aplicación necesita.</span><span class="sxs-lookup"><span data-stu-id="77afa-577">That is, duplicating the same data in multiple entities (one for each key you may use to find the data) to minimize the number of entities that a query must scan to find the data the client needs, rather than having to scan large numbers of entities to find the data your application needs.</span></span>  <span data-ttu-id="77afa-578">Por ejemplo, en un sitio web de comercio electrónico, puede que le interese encontrar un pedido tanto por el identificador del cliente (ver los pedidos de este cliente) como por la fecha (ver los pedidos con esa fecha).</span><span class="sxs-lookup"><span data-stu-id="77afa-578">For example, in an e-commerce website, you may want to find an order both by the customer ID (give me this customer's orders) and by the date (give me orders on a date).</span></span>  <span data-ttu-id="77afa-579">En Table Storage es mejor almacenar la entidad (o una referencia a ella) dos veces, una vez con el nombre de tabla, la clave de partición y la clave de fila para facilitar la búsqueda por identificador de cliente y una vez para facilitar su búsqueda por la fecha.</span><span class="sxs-lookup"><span data-stu-id="77afa-579">In Table Storage, it is best to store the entity (or a reference to it) twice – once with Table Name, PK, and RK to facilitate finding by customer ID, once to facilitate finding it by the date.</span></span>  

#### <a name="insertupdatedelete"></a><span data-ttu-id="77afa-580">Inserción, actualización y eliminación</span><span class="sxs-lookup"><span data-stu-id="77afa-580">Insert/Update/Delete</span></span>
<span data-ttu-id="77afa-581">En esta sección se describen prácticas probadas para modificar entidades almacenadas en Table service.</span><span class="sxs-lookup"><span data-stu-id="77afa-581">This section describes proven practices for modifying entities stored in the table service.</span></span>  

##### <span data-ttu-id="77afa-582"><a name="subheading35"></a>Lotes</span><span class="sxs-lookup"><span data-stu-id="77afa-582"><a name="subheading35"></a>Batching</span></span>
<span data-ttu-id="77afa-583">En Azure Storage, las transacciones por lotes son conocidas como transacciones con grupos de entidades (ETG); todas las operaciones dentro de una ETG deben estar en una sola partición y, a su vez, en una única tabla.</span><span class="sxs-lookup"><span data-stu-id="77afa-583">Batch transactions are known as Entity Group Transactions (ETG) in Azure Storage; all the operations within an ETG must be on a single partition in a single table.</span></span> <span data-ttu-id="77afa-584">Cuando sea posible, use ETG para realizar inspecciones, actualizaciones y eliminaciones por lotes.</span><span class="sxs-lookup"><span data-stu-id="77afa-584">Where possible, use ETGs to perform inserts, updates, and deletes in batches.</span></span> <span data-ttu-id="77afa-585">Esto reduce el número de recorridos de ida y vuelta de la aplicación cliente al servidor, disminuye el número de transacciones facturables (una ETG cuenta como una sola transacción desde el punto de vista de facturación y puede contener hasta 100 operaciones de almacenamiento) y permite actualizaciones atómicas (todas las operaciones se realizan correctamente o ninguna de ellas se realiza correctamente dentro de una ETG).</span><span class="sxs-lookup"><span data-stu-id="77afa-585">This reduces the number of round trips from your client application to the server, reduces the number of billable transactions (an ETG counts as a single transaction for billing purposes and can contain up to 100 storage operations), and enables atomic updates (all operations succeed or all fail within an ETG).</span></span> <span data-ttu-id="77afa-586">Los entornos con altas latencias, como por ejemplo dispositivos móviles, sacarán un enorme provecho al uso de ETG.</span><span class="sxs-lookup"><span data-stu-id="77afa-586">Environments with high latencies such as mobile devices will benefit greatly from using ETGs.</span></span>  

##### <span data-ttu-id="77afa-587"><a name="subheading36"></a>Upsert</span><span class="sxs-lookup"><span data-stu-id="77afa-587"><a name="subheading36"></a>Upsert</span></span>
<span data-ttu-id="77afa-588">Use operaciones **Upsert** de tabla siempre que sea posible.</span><span class="sxs-lookup"><span data-stu-id="77afa-588">Use table **Upsert** operations wherever possible.</span></span> <span data-ttu-id="77afa-589">Hay dos tipos de operaciones **Upsert**; ambos pueden ser más eficientes que las operaciones **Insert** y **Update** tradicionales:</span><span class="sxs-lookup"><span data-stu-id="77afa-589">There are two types of **Upsert**, both of which can be more efficient than a traditional **Insert** and **Update** operations:</span></span>  

* <span data-ttu-id="77afa-590">**InsertOrMerge**: se usa cuando se desea cargar un subconjunto de propiedades de la entidad sin tener la certeza de que la entidad existe.</span><span class="sxs-lookup"><span data-stu-id="77afa-590">**InsertOrMerge**: Use this when you want to upload a subset of the entity's properties, but aren't sure whether the entity already exists.</span></span> <span data-ttu-id="77afa-591">Si la entidad ya existe, esta llamada actualiza las propiedades incluidas en la operación **Upsert** y deja todas las propiedades existentes tal y como están; si la entidad no existe, inserta la nueva entidad.</span><span class="sxs-lookup"><span data-stu-id="77afa-591">If the entity exists, this call updates the properties included in the **Upsert** operation, and leaves all existing properties as they are, if the entity does not exist, it inserts the new entity.</span></span> <span data-ttu-id="77afa-592">Esto es similar a usar proyección en una consulta, donde solamente necesita actualizar las propiedades que cambian.</span><span class="sxs-lookup"><span data-stu-id="77afa-592">This is similar to using projection in a query, in that you only need to upload the properties that are changing.</span></span>
* <span data-ttu-id="77afa-593">**InsertOrReplace**: se usa cuando se desea cargar una entidad completamente nueva sin tener la certeza de que existe.</span><span class="sxs-lookup"><span data-stu-id="77afa-593">**InsertOrReplace**: Use this when you want to upload an entirely new entity, but you aren't sure whether it already exists.</span></span> <span data-ttu-id="77afa-594">Solamente debe usar este tipo cuando sabe que la entidad recién cargada es totalmente correcta porque sobrescribe la entidad antigua completamente.</span><span class="sxs-lookup"><span data-stu-id="77afa-594">You should only use this when you know that the newly uploaded entity is entirely correct because it completely overwrites the old entity.</span></span> <span data-ttu-id="77afa-595">Por ejemplo, desea actualizar la entidad que almacena la ubicación actual de un usuario independientemente de si la aplicación ha almacenado los datos de ubicación del usuario anteriormente; la entidad de la nueva ubicación está completa y no necesita información de ninguna otra entidad anterior.</span><span class="sxs-lookup"><span data-stu-id="77afa-595">For example, you want to update the entity that stores a user's current location regardless of whether or not the application has previously stored location data for the user; the new location entity is complete, and you do not need any information from any previous entity.</span></span>

##### <span data-ttu-id="77afa-596"><a name="subheading37"></a>Almacenamiento de series de datos en una sola entidad</span><span class="sxs-lookup"><span data-stu-id="77afa-596"><a name="subheading37"></a>Storing Data Series in a Single Entity</span></span>
<span data-ttu-id="77afa-597">A veces, una aplicación almacena una serie de datos que necesita recuperar de una sola vez con frecuencia: por ejemplo, un aplicación podría hacer un seguimiento del uso de CPU a lo largo del tiempo para representar un gráfico dinámico de los datos de las últimas 24 horas.</span><span class="sxs-lookup"><span data-stu-id="77afa-597">Sometimes, an application stores a series of data that it frequently needs to retrieve all at once: for example, an application might track CPU usage over time in order to plot a rolling chart of the data from the last 24 hours.</span></span> <span data-ttu-id="77afa-598">Un enfoque es tener una entidad de tabla por hora, de forma que cada entidad represente una hora específica y almacene el uso de CPU para esa hora.</span><span class="sxs-lookup"><span data-stu-id="77afa-598">One approach is to have one table entity per hour, with each entity representing a specific hour and storing the CPU usage for that hour.</span></span> <span data-ttu-id="77afa-599">Para representar estos datos, la aplicación necesita recuperar las entidades que contienen los datos de las 24 horas más recientes.</span><span class="sxs-lookup"><span data-stu-id="77afa-599">To plot this data, the application needs to retrieve the entities holding the data from the 24 most recent hours.</span></span>  

<span data-ttu-id="77afa-600">Como alternativa, la aplicación podría almacenar el uso de CPU por cada hora como propiedad independiente de una sola entidad: para actualizar cada hora, la aplicación puede usar una sola llamada **InsertOrMerge Upsert** para actualizar el valor de la hora más reciente.</span><span class="sxs-lookup"><span data-stu-id="77afa-600">Alternatively, your application could store the CPU usage for each hour as a separate property of a single entity: to update each hour, your application can use a single **InsertOrMerge Upsert** call to update the value for the most recent hour.</span></span> <span data-ttu-id="77afa-601">Para representar los datos, la aplicación solamente necesita recuperar una sola entidad en lugar de 24, creando una consulta realmente eficiente (consulte el análisis anterior acerca del [ámbito de las consultas](#subheading30)).</span><span class="sxs-lookup"><span data-stu-id="77afa-601">To plot the data, the application only needs to retrieve a single entity instead of 24, making for a very efficient query (see above discussion on [query scope](#subheading30)).</span></span>

##### <span data-ttu-id="77afa-602"><a name="subheading38"></a>Almacenamiento de datos estructurados en blobs</span><span class="sxs-lookup"><span data-stu-id="77afa-602"><a name="subheading38"></a>Storing structured data in blobs</span></span>
<span data-ttu-id="77afa-603">Algunas veces, da la sensación de que los datos estructurados deben ir en tablas, pero los intervalos de entidades siempre se recuperan conjuntamente y se pueden insertar por lotes.</span><span class="sxs-lookup"><span data-stu-id="77afa-603">Sometimes structured data feels like it should go in tables, but ranges of entities are always retrieved together and can be batch inserted.</span></span>  <span data-ttu-id="77afa-604">Un buen ejemplo de esto es un archivo de registro.</span><span class="sxs-lookup"><span data-stu-id="77afa-604">A good example of this is a log file.</span></span>  <span data-ttu-id="77afa-605">En este caso, puede procesar por lotes varios minutos de registros, insertarlos y, después, siempre estará recuperando varios minutos de registros simultáneamente.</span><span class="sxs-lookup"><span data-stu-id="77afa-605">In this case, you can batch several minutes of logs, insert them, and then you are always retrieving several minutes of logs at a time as well.</span></span>  <span data-ttu-id="77afa-606">En este caso, para mejorar el rendimiento, conviene usar blobs, en lugar de tablas, ya que puede reducir considerablemente el número de objetos escritos y devueltos, así como, por lo general, el número de solicitudes que necesita realizar.</span><span class="sxs-lookup"><span data-stu-id="77afa-606">In this case, for performance, it's better to use blobs instead of tables, since you can significantly reduce the number of objects written/returned, as well as usually the number of requests that need made.</span></span>  

## <a name="queues"></a><span data-ttu-id="77afa-607">Colas</span><span class="sxs-lookup"><span data-stu-id="77afa-607">Queues</span></span>
<span data-ttu-id="77afa-608">Además de las prácticas probadas para [Todos los servicios](#allservices) descritas anteriormente, las siguientes prácticas probadas se aplican específicamente al Queue service.</span><span class="sxs-lookup"><span data-stu-id="77afa-608">In addition to the proven practices for [All Services](#allservices) described previously, the following proven practices apply specifically to the queue service.</span></span>  

### <span data-ttu-id="77afa-609"><a name="subheading39"></a>Límites de escalabilidad</span><span class="sxs-lookup"><span data-stu-id="77afa-609"><a name="subheading39"></a>Scalability Limits</span></span>
<span data-ttu-id="77afa-610">Una sola cola puede procesar aproximadamente 2.000 mensajes (1 KB cada uno) por segundo (AddMessage GetMessage y DeleteMessage se cuentan como mensajes aquí).</span><span class="sxs-lookup"><span data-stu-id="77afa-610">A single queue can process approximately 2,000 messages (1KB each) per second (each AddMessage, GetMessage, and DeleteMessage count as a message here).</span></span> <span data-ttu-id="77afa-611">Si no es suficiente para la aplicación, debe usar varias colas y propagar los mensajes entre ellas.</span><span class="sxs-lookup"><span data-stu-id="77afa-611">If this is insufficient for your application, you should use multiple queues and spread the messages across them.</span></span>  

<span data-ttu-id="77afa-612">Vea los objetivos de escalabilidad actuales en [Objetivos de escalabilidad y rendimiento de Azure Storage](storage-scalability-targets.md).</span><span class="sxs-lookup"><span data-stu-id="77afa-612">View current scalability targets at [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span>  

### <span data-ttu-id="77afa-613"><a name="subheading40"></a>Desactivación de Nagle</span><span class="sxs-lookup"><span data-stu-id="77afa-613"><a name="subheading40"></a>Nagle Off</span></span>
<span data-ttu-id="77afa-614">Consulte la sección sobre la configuración de tablas que analiza el algoritmo de Nagle (el algoritmo de Nagle suele ser malo para el rendimiento de solicitudes de cola y debe deshabilitarlo).</span><span class="sxs-lookup"><span data-stu-id="77afa-614">See the section on table configuration that discusses the Nagle algorithm — the Nagle algorithm is generally bad for the performance of queue requests, and you should disable it.</span></span>  

### <span data-ttu-id="77afa-615"><a name="subheading41"></a>Tamaño de los mensajes</span><span class="sxs-lookup"><span data-stu-id="77afa-615"><a name="subheading41"></a>Message Size</span></span>
<span data-ttu-id="77afa-616">El rendimiento y la escalabilidad de la cola se reducen a medida que aumenta el tamaño de los mensajes.</span><span class="sxs-lookup"><span data-stu-id="77afa-616">Queue performance and scalability decreases as message size increases.</span></span> <span data-ttu-id="77afa-617">Debe colocar únicamente la información que necesita el receptor de un mensaje.</span><span class="sxs-lookup"><span data-stu-id="77afa-617">You should place only the information the receiver needs in a message.</span></span>  

### <span data-ttu-id="77afa-618"><a name="subheading42"></a>Recuperación por lotes</span><span class="sxs-lookup"><span data-stu-id="77afa-618"><a name="subheading42"></a>Batch Retrieval</span></span>
<span data-ttu-id="77afa-619">Puede recuperar hasta 32 mensajes de una cola en una sola operación.</span><span class="sxs-lookup"><span data-stu-id="77afa-619">You can retrieve up to 32 messages from a queue in a single operation.</span></span> <span data-ttu-id="77afa-620">Esto puede reducir el número de recorridos de ida y vuelta de la aplicación cliente, lo cual es especialmente útil para entornos, como por ejemplo dispositivos móviles, con alta latencia.</span><span class="sxs-lookup"><span data-stu-id="77afa-620">This can reduce the number of roundtrips from the client application, which is especially useful for environments, such as mobile devices, with high latency.</span></span>  

### <span data-ttu-id="77afa-621"><a name="subheading43"></a>Intervalo de sondeo de la cola</span><span class="sxs-lookup"><span data-stu-id="77afa-621"><a name="subheading43"></a>Queue Polling Interval</span></span>
<span data-ttu-id="77afa-622">La mayoría de aplicaciones sondean los mensajes de una cola, que puede ser uno de los principales orígenes de las transacciones de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="77afa-622">Most applications poll for messages from a queue, which can be one of the largest sources of transactions for that application.</span></span> <span data-ttu-id="77afa-623">Seleccione el intervalo de sondeo con cuidado: un sondeo demasiado frecuente puede provocar que la aplicación alcance los objetivos de escalabilidad para la cola.</span><span class="sxs-lookup"><span data-stu-id="77afa-623">Select your polling interval wisely: polling too frequently could cause your application to approach the scalability targets for the queue.</span></span> <span data-ttu-id="77afa-624">Sin embargo, a 200.000 transacciones por 0,01 USD (en el momento de redactar), un solo procesador que sondeara una vez cada pocos segundos durante un mes costaría menos de 15 centavos, así que el coste de sondeo no suele ser un factor que afecte a la elección del intervalo de sondeo.</span><span class="sxs-lookup"><span data-stu-id="77afa-624">However, at 200,000 transactions for $0.01 (at the time of writing), a single processor polling once every second for a month would cost less than 15 cents so cost is not typically a factor that affects your choice of polling interval.</span></span>  

<span data-ttu-id="77afa-625">Para obtener información de costo actualizada, consulte [Precios de Azure Storage](https://azure.microsoft.com/pricing/details/storage/).</span><span class="sxs-lookup"><span data-stu-id="77afa-625">For up-to-date cost information, see [Azure Storage Pricing](https://azure.microsoft.com/pricing/details/storage/).</span></span>  

### <span data-ttu-id="77afa-626"><a name="subheading44"></a>UpdateMessage</span><span class="sxs-lookup"><span data-stu-id="77afa-626"><a name="subheading44"></a>UpdateMessage</span></span>
<span data-ttu-id="77afa-627">Puede usar **UpdateMessage para** aumentar el tiempo de espera de invisibilidad o para actualizar la información de estado de un mensaje.</span><span class="sxs-lookup"><span data-stu-id="77afa-627">You can use **UpdateMessage** to increase the invisibility timeout or to update state information of a message.</span></span> <span data-ttu-id="77afa-628">Aunque esto es muy eficiente, recuerde que cada operación **UpdateMessage** cuenta para el objetivo de escalabilidad.</span><span class="sxs-lookup"><span data-stu-id="77afa-628">While this is powerful, remember that each **UpdateMessage** operation counts towards the scalability target.</span></span> <span data-ttu-id="77afa-629">Sin embargo, esto puede ser un enfoque mucho más eficiente que tener un flujo de trabajo que pasa un trabajo de una cola a la siguiente, cuando cada paso del trabajo se completa.</span><span class="sxs-lookup"><span data-stu-id="77afa-629">However, this can be a much more efficient approach than having a workflow that passes a job from one queue to the next, as each step of the job is completed.</span></span> <span data-ttu-id="77afa-630">El uso de la operación **UpdateMessage** permite que la aplicación guarde el estado del trabajo en el mensaje y, a continuación, continúe trabajando, en lugar de volver a poner en cola el mensaje para el próximo paso del trabajo cada vez que se completa un paso.</span><span class="sxs-lookup"><span data-stu-id="77afa-630">Using the **UpdateMessage** operation allows your application to save the job state to the message and then continue working, instead of re-queuing the message for the next step of the job every time a step completes.</span></span>  

<span data-ttu-id="77afa-631">Para obtener más información, consulte [Cambio del contenido de un mensaje en cola](../queues/storage-dotnet-how-to-use-queues.md#change-the-contents-of-a-queued-message).</span><span class="sxs-lookup"><span data-stu-id="77afa-631">For more information, see the article [How to: Change the contents of a queued message](../queues/storage-dotnet-how-to-use-queues.md#change-the-contents-of-a-queued-message).</span></span>  

### <span data-ttu-id="77afa-632"><a name="subheading45"></a>Arquitectura de la aplicación</span><span class="sxs-lookup"><span data-stu-id="77afa-632"><a name="subheading45"></a>Application architecture</span></span>
<span data-ttu-id="77afa-633">Debe usar colas para que la arquitectura de la aplicación sea escalable.</span><span class="sxs-lookup"><span data-stu-id="77afa-633">You should use queues to make your application architecture scalable.</span></span> <span data-ttu-id="77afa-634">A continuación se enumeran algunas formas de usar colas para que la aplicación sea más escalable:</span><span class="sxs-lookup"><span data-stu-id="77afa-634">The following lists some ways you can use queues to make your application more scalable:</span></span>  

* <span data-ttu-id="77afa-635">Puede usar colas para crear trabajos pendientes para el procesamiento y aliviar las cargas de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="77afa-635">You can use queues to create backlogs of work for processing and smooth out workloads in your application.</span></span> <span data-ttu-id="77afa-636">Por ejemplo, podría poner en cola solicitudes de usuarios para realizar un trabajo que requiere muchos recursos de procesador, como, por ejemplo, cambiar el tamaño de las imágenes cargadas.</span><span class="sxs-lookup"><span data-stu-id="77afa-636">For example, you could queue up requests from users to perform processor intensive work such as resizing uploaded images.</span></span>
* <span data-ttu-id="77afa-637">Puede usar colas para desacoplar partes de la aplicación para poder escalarlas por separado.</span><span class="sxs-lookup"><span data-stu-id="77afa-637">You can use queues to decouple parts of your application so that you can scale them independently.</span></span> <span data-ttu-id="77afa-638">Por ejemplo, un front-end web podría poner resultados de encuesta de usuarios en una cola para analizarlos y almacenarlos posteriormente.</span><span class="sxs-lookup"><span data-stu-id="77afa-638">For example, a web front-end could place survey results from users into a queue for later analysis and storage.</span></span> <span data-ttu-id="77afa-639">Podría agregar más instancias de rol de trabajo para procesar los datos de cola según sea necesario.</span><span class="sxs-lookup"><span data-stu-id="77afa-639">You could add more worker role instances to process the queue data as required.</span></span>  

## <a name="conclusion"></a><span data-ttu-id="77afa-640">Conclusión</span><span class="sxs-lookup"><span data-stu-id="77afa-640">Conclusion</span></span>
<span data-ttu-id="77afa-641">En este artículo se analizaron algunas de las prácticas probadas más comunes para optimizar el rendimiento cuando se usa Azure Storage.</span><span class="sxs-lookup"><span data-stu-id="77afa-641">This article discussed some of the most common, proven practices for optimizing performance when using Azure Storage.</span></span> <span data-ttu-id="77afa-642">Animamos a todos los desarrolladores de aplicaciones a que evalúen sus aplicaciones tomando como referencia todas las prácticas anteriores y que se planteen seguir las recomendaciones para obtener un magnífico rendimiento para aquellas aplicaciones que usan Azure Storage.</span><span class="sxs-lookup"><span data-stu-id="77afa-642">We encourage every application developer to assess their application against each of the above practices and consider acting on the recommendations to get great performance for their applications that use Azure Storage.</span></span>