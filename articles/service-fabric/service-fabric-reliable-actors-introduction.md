---
title: "Información general de Reliable Actors de Service Fabric | Microsoft Docs"
description: "Introducción al modelo de programación de Service Fabric Reliable Actors."
services: service-fabric
documentationcenter: .net
author: vturecek
manager: timlt
editor: 
ms.assetid: 7fdad07f-f2d6-4c74-804d-e0d56131f060
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/29/2017
ms.author: vturecek
ms.openlocfilehash: e89be04a0d6fe90a89e293e67d42f0204eb7000a
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 07/11/2017
---
# <a name="introduction-to-service-fabric-reliable-actors"></a><span data-ttu-id="a545a-103">Introducción a Service Fabric Reliable Actors.</span><span class="sxs-lookup"><span data-stu-id="a545a-103">Introduction to Service Fabric Reliable Actors</span></span>
<span data-ttu-id="a545a-104">Reliable Actors es un marco de trabajo de la aplicación de Service Fabric que se basa en el modelo [Virtual Actor](http://research.microsoft.com/en-us/projects/orleans/) .</span><span class="sxs-lookup"><span data-stu-id="a545a-104">Reliable Actors is a Service Fabric application framework based on the [Virtual Actor](http://research.microsoft.com/en-us/projects/orleans/) pattern.</span></span> <span data-ttu-id="a545a-105">La API de Reliable Actors proporciona un modelo de programación uniproceso basado en las garantías de escalabilidad y confiabilidad que ofrece Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="a545a-105">The Reliable Actors API provides a single-threaded programming model built on the scalability and reliability guarantees provided by Service Fabric.</span></span>

## <a name="what-are-actors"></a><span data-ttu-id="a545a-106">¿Qué son los actores?</span><span class="sxs-lookup"><span data-stu-id="a545a-106">What are Actors?</span></span>
<span data-ttu-id="a545a-107">Un actor es una unidad aislada e independiente de proceso y estado con ejecución uniproceso.</span><span class="sxs-lookup"><span data-stu-id="a545a-107">An actor is an isolated, independent unit of compute and state with single-threaded execution.</span></span> <span data-ttu-id="a545a-108">El [patrón de actor](https://en.wikipedia.org/wiki/Actor_model) es un modelo informático para sistemas simultáneos o distribuidos en que un gran número de estos actores puede ejecutarse simultánea e independientemente unos de otros.</span><span class="sxs-lookup"><span data-stu-id="a545a-108">The [actor pattern](https://en.wikipedia.org/wiki/Actor_model) is a computational model for concurrent or distributed systems in which a large number of these actors can execute simultaneously and independently of each other.</span></span> <span data-ttu-id="a545a-109">Los actores pueden comunicarse entre sí y pueden crear más actores.</span><span class="sxs-lookup"><span data-stu-id="a545a-109">Actors can communicate with each other and they can create more actors.</span></span>

### <a name="when-to-use-reliable-actors"></a><span data-ttu-id="a545a-110">Cuándo usar Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="a545a-110">When to use Reliable Actors</span></span>
<span data-ttu-id="a545a-111">Service Fabric Reliable Actors es una implementación del modelo de diseño del actor.</span><span class="sxs-lookup"><span data-stu-id="a545a-111">Service Fabric Reliable Actors is an implementation of the actor design pattern.</span></span> <span data-ttu-id="a545a-112">Al igual que sucede con cualquier modelo de diseño de software, la decisión sobre si usar un modelo específico se toma en función de si un problema de diseño de software se adapta al modelo o no.</span><span class="sxs-lookup"><span data-stu-id="a545a-112">As with any software design pattern, the decision whether to use a specific pattern is made based on whether or not a software design problem fits the pattern.</span></span>

<span data-ttu-id="a545a-113">Aunque el modelo de diseño del actor puede resultar adecuado para un número de problemas y escenarios de sistemas distribuidos, se requiere una consideración cuidadosa de las restricciones del modelo y el marco de trabajo que lo implementa.</span><span class="sxs-lookup"><span data-stu-id="a545a-113">Although the actor design pattern can be a good fit to a number of distributed systems problems and scenarios, careful consideration of the constraints of the pattern and the framework implementing it must be made.</span></span> <span data-ttu-id="a545a-114">Como regla general, tenga en cuenta el patrón de actor para modelar su problema o escenario si:</span><span class="sxs-lookup"><span data-stu-id="a545a-114">As general guidance, consider the actor pattern to model your problem or scenario if:</span></span>

* <span data-ttu-id="a545a-115">El espacio del problema implica un gran número (miles o más) de unidades pequeñas, independientes y aisladas de estado y lógica.</span><span class="sxs-lookup"><span data-stu-id="a545a-115">Your problem space involves a large number (thousands or more) of small, independent, and isolated units of state and logic.</span></span>
* <span data-ttu-id="a545a-116">Desea trabajar con objetos uniproceso que no requieren una interacción importante de los componentes externos, incluida la consulta del estado en un conjunto de actores.</span><span class="sxs-lookup"><span data-stu-id="a545a-116">You want to work with single-threaded objects that do not require significant interaction from external components, including querying state across a set of actors.</span></span>
* <span data-ttu-id="a545a-117">Las instancias de actor no bloquearán a los autores de llamadas con retrasos imprevisibles emitiendo operaciones de E/S.</span><span class="sxs-lookup"><span data-stu-id="a545a-117">Your actor instances won't block callers with unpredictable delays by issuing I/O operations.</span></span>

## <a name="actors-in-service-fabric"></a><span data-ttu-id="a545a-118">Actores en Service Fabric</span><span class="sxs-lookup"><span data-stu-id="a545a-118">Actors in Service Fabric</span></span>
<span data-ttu-id="a545a-119">En Service Fabric, los actores se implementan en el marco de trabajo de Reliable Actors: un marco de trabajo de la aplicación basado en el patrón de actor y en [Reliable Services de Service Fabric](service-fabric-reliable-services-introduction.md).</span><span class="sxs-lookup"><span data-stu-id="a545a-119">In Service Fabric, actors are implemented in the Reliable Actors framework: An actor-pattern-based application framework built on top of [Service Fabric Reliable Services](service-fabric-reliable-services-introduction.md).</span></span> <span data-ttu-id="a545a-120">Cada servicio de Reliable Actors que escribe es en realidad un servicio de confianza con estado particionado.</span><span class="sxs-lookup"><span data-stu-id="a545a-120">Each Reliable Actor service you write is actually a partitioned, stateful Reliable Service.</span></span>

<span data-ttu-id="a545a-121">Cada actor se define como una instancia de un tipo de actor, similar a la forma en que un objeto de .NET es una instancia de un tipo de .NET.</span><span class="sxs-lookup"><span data-stu-id="a545a-121">Every actor is defined as an instance of an actor type, identical to the way a .NET object is an instance of a .NET type.</span></span> <span data-ttu-id="a545a-122">Por ejemplo, puede haber un tipo de actor que implemente la funcionalidad de una calculadora y podría haber muchos actores de ese tipo que se distribuyesen en varios nodos en un clúster.</span><span class="sxs-lookup"><span data-stu-id="a545a-122">For example, there may be an actor type that implements the functionality of a calculator and there could be many actors of that type that are distributed on various nodes across a cluster.</span></span> <span data-ttu-id="a545a-123">Cada uno de esos actores se identifica de forma única mediante un identificador de actor.</span><span class="sxs-lookup"><span data-stu-id="a545a-123">Each such actor is uniquely identified by an actor ID.</span></span>

### <a name="actor-lifetime"></a><span data-ttu-id="a545a-124">Duración del actor</span><span class="sxs-lookup"><span data-stu-id="a545a-124">Actor Lifetime</span></span>
<span data-ttu-id="a545a-125">Los actores de Service Fabric son virtuales, lo que significa que su duración no está vinculada a su representación en memoria.</span><span class="sxs-lookup"><span data-stu-id="a545a-125">Service Fabric actors are virtual, meaning that their lifetime is not tied to their in-memory representation.</span></span> <span data-ttu-id="a545a-126">Como resultado, no es necesario crearlas ni destruirlas explícitamente.</span><span class="sxs-lookup"><span data-stu-id="a545a-126">As a result, they do not need to be explicitly created or destroyed.</span></span> <span data-ttu-id="a545a-127">El tiempo de ejecución de Reliable Actors activa automáticamente un actor la primera vez que recibe una solicitud para ese identificador de actor.</span><span class="sxs-lookup"><span data-stu-id="a545a-127">The Reliable Actors runtime automatically activates an actor the first time it receives a request for that actor ID.</span></span> <span data-ttu-id="a545a-128">Si no se usa un actor durante un período de tiempo, el tiempo de ejecución de Reliable Actors recopila el objeto en memoria como elemento no utilizado.</span><span class="sxs-lookup"><span data-stu-id="a545a-128">If an actor is not used for a period of time, the Reliable Actors runtime garbage-collects the in-memory object.</span></span> <span data-ttu-id="a545a-129">También mantendrá conocimientos de la existencia del actor por si es necesario reactivarlo más adelante.</span><span class="sxs-lookup"><span data-stu-id="a545a-129">It will also maintain knowledge of the actor's existence should it need to be reactivated later.</span></span> <span data-ttu-id="a545a-130">Para más información, consulte [Ciclo de vida de un actor y recolección de elementos no utilizados](service-fabric-reliable-actors-lifecycle.md).</span><span class="sxs-lookup"><span data-stu-id="a545a-130">For more details, see [Actor lifecycle and garbage collection](service-fabric-reliable-actors-lifecycle.md).</span></span>

<span data-ttu-id="a545a-131">Esta abstracción de la duración del actor virtual incluye algunas advertencias como resultado del modelo Virtual Actor y, de hecho, la implementación de Reliable Actors se desvía en ocasiones de este modelo.</span><span class="sxs-lookup"><span data-stu-id="a545a-131">This virtual actor lifetime abstraction carries some caveats as a result of the virtual actor model, and in fact the Reliable Actors implementation deviates at times from this model.</span></span>

* <span data-ttu-id="a545a-132">Un actor se activa automáticamente (provocando la creación de un objeto de actor) la primera vez que se envía un mensaje a su identificador de actor.</span><span class="sxs-lookup"><span data-stu-id="a545a-132">An actor is automatically activated (causing an actor object to be constructed) the first time a message is sent to its actor ID.</span></span> <span data-ttu-id="a545a-133">Transcurrido un período de tiempo, el objeto de actor se recolecta como elemento no utilizado.</span><span class="sxs-lookup"><span data-stu-id="a545a-133">After some period of time, the actor object is garbage collected.</span></span> <span data-ttu-id="a545a-134">En el futuro, usar de nuevo el identificador de actor provoca la creación de un nuevo objeto de actor.</span><span class="sxs-lookup"><span data-stu-id="a545a-134">In the future, using the actor ID again, causes a new actor object to be constructed.</span></span> <span data-ttu-id="a545a-135">La duración del estado del actor equivale a la vida útil del objeto al almacenarse en el administrador de estado.</span><span class="sxs-lookup"><span data-stu-id="a545a-135">An actor's state outlives the object's lifetime when stored in the state manager.</span></span>
* <span data-ttu-id="a545a-136">Al llamar a cualquier método de actor para un identificador de actor se activa dicho actor.</span><span class="sxs-lookup"><span data-stu-id="a545a-136">Calling any actor method for an actor ID activates that actor.</span></span> <span data-ttu-id="a545a-137">Por este motivo, se llama de forma implícita al constructor de los tipos de actor mediante el tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="a545a-137">For this reason, actor types have their constructor called implicitly by the runtime.</span></span> <span data-ttu-id="a545a-138">Por lo tanto, el código de cliente no puede pasar parámetros al constructor del tipo de actor, aunque se pueden pasar parámetros al constructor del actor mediante el propio servicio.</span><span class="sxs-lookup"><span data-stu-id="a545a-138">Therefore, client code cannot pass parameters to the actor type's constructor, although parameters may be passed to the actor's constructor by the service itself.</span></span> <span data-ttu-id="a545a-139">El resultado es que los actores se pueden crear en un estado inicializado de forma parcial en el momento en que se llama a otros métodos en él, en caso de que el actor requiera parámetros de inicialización del cliente.</span><span class="sxs-lookup"><span data-stu-id="a545a-139">The result is that actors may be constructed in a partially-initialized state by the time other methods are called on it, if the actor requires initialization parameters from the client.</span></span> <span data-ttu-id="a545a-140">No hay ningún punto de entrada único para la activación de un actor desde el cliente.</span><span class="sxs-lookup"><span data-stu-id="a545a-140">There is no single entry point for the activation of an actor from the client.</span></span>
* <span data-ttu-id="a545a-141">Aunque Reliable Actors crea de forma implícita objetos de actor, tiene la posibilidad de eliminar explícitamente un actor y su estado.</span><span class="sxs-lookup"><span data-stu-id="a545a-141">Although Reliable Actors implicitly create actor objects; you do have the ability to explicitly delete an actor and its state.</span></span>

### <a name="distribution-and-failover"></a><span data-ttu-id="a545a-142">Distribución y conmutación por error</span><span class="sxs-lookup"><span data-stu-id="a545a-142">Distribution and failover</span></span>
<span data-ttu-id="a545a-143">Para proporcionar escalabilidad y confiabilidad, Service Fabric distribuye actores en el clúster y los migra automáticamente desde los nodos con errores hasta los correctos según sea necesario.</span><span class="sxs-lookup"><span data-stu-id="a545a-143">To provide scalability and reliability, Service Fabric distributes actors throughout the cluster and automatically migrates them from failed nodes to healthy ones as required.</span></span> <span data-ttu-id="a545a-144">Se trata de una abstracción sobre un [servicio de confianza con estado particionado](service-fabric-concepts-partitioning.md).</span><span class="sxs-lookup"><span data-stu-id="a545a-144">This is an abstraction over a [partitioned, stateful Reliable Service](service-fabric-concepts-partitioning.md).</span></span> <span data-ttu-id="a545a-145">Distribución, escalabilidad, confiabilidad y conmutación por error automática se proporcionan en virtud del hecho de que los actores se ejecuten en un servicio de confianza con estado denominado *Servicio de actor*.</span><span class="sxs-lookup"><span data-stu-id="a545a-145">Distribution, scalability, reliability, and automatic failover are all provided by virtue of the fact that actors are running inside a stateful Reliable Service called the *Actor Service*.</span></span>

<span data-ttu-id="a545a-146">Los actores se distribuyen entre las particiones del Servicio de actor y dichas particiones se distribuyen entre los nodos en un clúster de Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="a545a-146">Actors are distributed across the partitions of the Actor Service, and those partitions are distributed across the nodes in a Service Fabric cluster.</span></span> <span data-ttu-id="a545a-147">Cada partición del servicio contiene un conjunto de actores.</span><span class="sxs-lookup"><span data-stu-id="a545a-147">Each service partition contains a set of actors.</span></span> <span data-ttu-id="a545a-148">Service Fabric administra la distribución y conmutación por error de las particiones del servicio.</span><span class="sxs-lookup"><span data-stu-id="a545a-148">Service Fabric manages distribution and failover of the service partitions.</span></span>

<span data-ttu-id="a545a-149">Por ejemplo, un Servicio de actor con nueve particiones implementadas en tres nodos mediante la ubicación predeterminada de la partición del actor se distribuiría del siguiente modo:</span><span class="sxs-lookup"><span data-stu-id="a545a-149">For example, an actor service with nine partitions deployed to three nodes using the default actor partition placement would be distributed thusly:</span></span>

![Distribución de Reliable Actors][2]

<span data-ttu-id="a545a-151">El marco de trabajo de actores administra la configuración del intervalo de claves y el esquema de partición por usted.</span><span class="sxs-lookup"><span data-stu-id="a545a-151">The Actor Framework manages partition scheme and key range settings for you.</span></span> <span data-ttu-id="a545a-152">Esto simplifica algunas opciones, pero también implica cierta consideración:</span><span class="sxs-lookup"><span data-stu-id="a545a-152">This simplifies some choices but also carries some consideration:</span></span>

* <span data-ttu-id="a545a-153">Reliable Services le permite elegir un esquema de creación de particiones, el intervalo de claves (al usar un esquema de creación de particiones por rangos) y el recuento de particiones.</span><span class="sxs-lookup"><span data-stu-id="a545a-153">Reliable Services allows you to choose a partitioning scheme, key range (when using a range partitioning scheme), and partition count.</span></span> <span data-ttu-id="a545a-154">Reliable Actors se restringe al esquema de creación de particiones por rangos (el esquema Int64 uniforme) y requiere que use el intervalo de claves Int64 completo.</span><span class="sxs-lookup"><span data-stu-id="a545a-154">Reliable Actors is restricted to the range partitioning scheme (the uniform Int64 scheme) and requires you use the full Int64 key range.</span></span>
* <span data-ttu-id="a545a-155">De forma predeterminada, los actores se colocan aleatoriamente en particiones, dando como resultado una distribución uniforme.</span><span class="sxs-lookup"><span data-stu-id="a545a-155">By default, actors are randomly placed into partitions resulting in uniform distribution.</span></span>
* <span data-ttu-id="a545a-156">Como los actores se colocan aleatoriamente, debe esperarse que las operaciones del actor requieran siempre la comunicación de red, incluidas la serialización y deserialización de datos de la llamada al método, incurriendo en latencia y sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="a545a-156">Because actors are randomly placed, it should be expected that actor operations will always require network communication, including serialization and deserialization of method call data, incurring latency and overhead.</span></span>
* <span data-ttu-id="a545a-157">En escenarios avanzados, es posible controlar la ubicación de la partición del actor mediante los identificadores de actor Int64 que se asignan a particiones específicas.</span><span class="sxs-lookup"><span data-stu-id="a545a-157">In advanced scenarios, it is possible to control actor partition placement by using Int64 actor IDs that map to specific partitions.</span></span> <span data-ttu-id="a545a-158">Sin embargo, esto puede dar lugar a una distribución desequilibrada de los actores entre particiones.</span><span class="sxs-lookup"><span data-stu-id="a545a-158">However, doing so can result in an unbalanced distribution of actors across partitions.</span></span>

<span data-ttu-id="a545a-159">Para más información sobre cómo se particionan los servicios de actor, consulte [Partitioning concepts for actors](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors)(Conceptos de creación de particiones para actores).</span><span class="sxs-lookup"><span data-stu-id="a545a-159">For more information on how actor services are partitioned, refer to [partitioning concepts for actors](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span></span>

### <a name="actor-communication"></a><span data-ttu-id="a545a-160">Comunicación con actores</span><span class="sxs-lookup"><span data-stu-id="a545a-160">Actor communication</span></span>
<span data-ttu-id="a545a-161">Las interacciones entre actores se definen en una interfaz compartida por el actor que implementa la interfaz y el cliente que consigue un proxy a un actor a través de la misma interfaz.</span><span class="sxs-lookup"><span data-stu-id="a545a-161">Actor interactions are defined in an interface that is shared by the actor that implements the interface, and the client that gets a proxy to an actor via the same interface.</span></span> <span data-ttu-id="a545a-162">Como esta interfaz se usa para invocar métodos de actor de forma asincrónica, cada método de la interfaz debe devolver tareas.</span><span class="sxs-lookup"><span data-stu-id="a545a-162">Because this interface is used to invoke actor methods asynchronously, every method on the interface must be Task-returning.</span></span>

<span data-ttu-id="a545a-163">Las invocaciones de método y sus respuestas tienen como resultado final solicitudes de red en el clúster, de modo que los argumentos y los tipos de resultado de las tareas que devuelven deben ser serializables por parte de la plataforma.</span><span class="sxs-lookup"><span data-stu-id="a545a-163">Method invocations and their responses ultimately result in network requests across the cluster, so the arguments and the result types of the tasks that they return must be serializable by the platform.</span></span> <span data-ttu-id="a545a-164">En particular, deben ser [serializables mediante contrato de datos](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="a545a-164">In particular, they must be [data contract serializable](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span></span>

#### <a name="the-actor-proxy"></a><span data-ttu-id="a545a-165">El proxy de actor</span><span class="sxs-lookup"><span data-stu-id="a545a-165">The actor proxy</span></span>
<span data-ttu-id="a545a-166">La API de cliente de Reliable Actors ofrece comunicación entre una instancia de actor y un cliente de actor.</span><span class="sxs-lookup"><span data-stu-id="a545a-166">The Reliable Actors client API provides communication between an actor instance and an actor client.</span></span> <span data-ttu-id="a545a-167">Para comunicarse con un actor, un cliente crea un objeto proxy de actor que implementa la interfaz del actor.</span><span class="sxs-lookup"><span data-stu-id="a545a-167">To communicate with an actor, a client creates an actor proxy object that implements the actor interface.</span></span> <span data-ttu-id="a545a-168">El cliente interactúa con el actor mediante la invocación de métodos en el objeto proxy.</span><span class="sxs-lookup"><span data-stu-id="a545a-168">The client interacts with the actor by invoking methods on the proxy object.</span></span> <span data-ttu-id="a545a-169">El proxy de actor puede usarse para la comunicación de cliente a actor y de actor a actor.</span><span class="sxs-lookup"><span data-stu-id="a545a-169">The actor proxy can be used for client-to-actor and actor-to-actor communication.</span></span>

```csharp
// Create a randomly distributed actor ID
ActorId actorId = ActorId.CreateRandom();

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
IMyActor myActor = ActorProxy.Create<IMyActor>(actorId, new Uri("fabric:/MyApp/MyActorService"));

// This will invoke a method on the actor. If an actor with the given ID does not exist, it will be activated by this method call.
await myActor.DoWorkAsync();
```

```java
// Create actor ID with some name
ActorId actorId = new ActorId("Actor1");

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
MyActor myActor = ActorProxyBase.create(actorId, new URI("fabric:/MyApp/MyActorService"), MyActor.class);

// This will invoke a method on the actor. If an actor with the given ID does not exist, it will be activated by this method call.
myActor.DoWorkAsync().get();
```


<span data-ttu-id="a545a-170">Tenga en cuenta que los dos tipos de datos que se usan para crear el objeto de proxy de actor son el identificador del actor y el nombre de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="a545a-170">Note that the two pieces of information used to create the actor proxy object are the actor ID and the application name.</span></span> <span data-ttu-id="a545a-171">El identificador de actor identifica de forma única al actor, mientras que el nombre de la aplicación identifica la [Aplicación de Service Fabric](service-fabric-reliable-actors-platform.md#application-model) en la que se implementa el actor.</span><span class="sxs-lookup"><span data-stu-id="a545a-171">The actor ID uniquely identifies the actor, while the application name identifies the [Service Fabric application](service-fabric-reliable-actors-platform.md#application-model) where the actor is deployed.</span></span>

<span data-ttu-id="a545a-172">La clase `ActorProxy`(C#) / `ActorProxyBase`(Java) del cliente realiza la resolución necesaria para localizar el actor mediante el identificador y abre un canal de comunicación con él.</span><span class="sxs-lookup"><span data-stu-id="a545a-172">The `ActorProxy`(C#) / `ActorProxyBase`(Java) class on the client side performs the necessary resolution to locate the actor by ID and open a communication channel with it.</span></span> <span data-ttu-id="a545a-173">También vuelve a intentar localizar el actor en caso de que se produzcan errores de comunicación y conmutaciones por error.</span><span class="sxs-lookup"><span data-stu-id="a545a-173">It also retries to locate the actor in the cases of communication failures and failovers.</span></span> <span data-ttu-id="a545a-174">Como resultado, la entrega de mensajes tiene las siguientes características:</span><span class="sxs-lookup"><span data-stu-id="a545a-174">As a result, message delivery has the following characteristics:</span></span>

* <span data-ttu-id="a545a-175">La entrega de mensajes es la mejor opción.</span><span class="sxs-lookup"><span data-stu-id="a545a-175">Message delivery is best effort.</span></span>
* <span data-ttu-id="a545a-176">Los actores pueden recibir mensajes duplicados del mismo cliente.</span><span class="sxs-lookup"><span data-stu-id="a545a-176">Actors may receive duplicate messages from the same client.</span></span>

### <a name="concurrency"></a><span data-ttu-id="a545a-177">Simultaneidad</span><span class="sxs-lookup"><span data-stu-id="a545a-177">Concurrency</span></span>
<span data-ttu-id="a545a-178">El tiempo de ejecución de Reliable Actors ofrece un modelo de acceso simple basado en turnos para obtener acceso a los métodos de actor.</span><span class="sxs-lookup"><span data-stu-id="a545a-178">The Reliable Actors runtime provides a simple turn-based access model for accessing actor methods.</span></span> <span data-ttu-id="a545a-179">Esto significa que no puede haber más de un subproceso activo dentro del código del objeto de actor en ningún momento.</span><span class="sxs-lookup"><span data-stu-id="a545a-179">This means that no more than one thread can be active inside an actor object's code at any time.</span></span> <span data-ttu-id="a545a-180">El acceso basado en turnos simplifica considerablemente sistemas simultáneos, pues no es necesario que los mecanismos de sincronización tengan acceso a datos.</span><span class="sxs-lookup"><span data-stu-id="a545a-180">Turn-based access greatly simplifies concurrent systems as there is no need for synchronization mechanisms for data access.</span></span> <span data-ttu-id="a545a-181">También significa que los sistemas deben diseñarse con consideraciones especiales para la naturaleza de acceso uniproceso de cada instancia de actor.</span><span class="sxs-lookup"><span data-stu-id="a545a-181">It also means systems must be designed with special considerations for the single-threaded access nature of each actor instance.</span></span>

* <span data-ttu-id="a545a-182">Una sola instancia de actor no puede procesar más de una solicitud cada vez.</span><span class="sxs-lookup"><span data-stu-id="a545a-182">A single actor instance cannot process more than one request at a time.</span></span> <span data-ttu-id="a545a-183">Una instancia de actor puede provocar un cuello de botella de procesamiento si se espera que controle solicitudes simultáneas.</span><span class="sxs-lookup"><span data-stu-id="a545a-183">An actor instance can cause a throughput bottleneck if it is expected to handle concurrent requests.</span></span>
* <span data-ttu-id="a545a-184">Los actores pueden interbloquearse si hay una solicitud circular entre dos actores mientras se realiza una solicitud externa destinada a uno de los actores simultáneamente.</span><span class="sxs-lookup"><span data-stu-id="a545a-184">Actors can deadlock on each other if there is a circular request between two actors while an external request is made to one of the actors simultaneously.</span></span> <span data-ttu-id="a545a-185">El tiempo de ejecución del actor agotará el tiempo de expiración en llamadas de actor automáticamente y generará una excepción al autor de llamada para interrumpir posibles situaciones de interbloqueo.</span><span class="sxs-lookup"><span data-stu-id="a545a-185">The actor runtime will automatically time out on actor calls and throw an exception to the caller to interrupt possible deadlock situations.</span></span>

![Comunicación de Reliable Actors][3]

#### <a name="turn-based-access"></a><span data-ttu-id="a545a-187">Acceso basada en turnos</span><span class="sxs-lookup"><span data-stu-id="a545a-187">Turn-based access</span></span>
<span data-ttu-id="a545a-188">Un turno es la ejecución completa de un método de actor en respuesta a la solicitud de otros actores o clientes, o la ejecución completa de la devolución de llamada de un [temporizador o recordatorio](service-fabric-reliable-actors-timers-reminders.md) .</span><span class="sxs-lookup"><span data-stu-id="a545a-188">A turn consists of the complete execution of an actor method in response to a request from other actors or clients, or the complete execution of a [timer/reminder](service-fabric-reliable-actors-timers-reminders.md) callback.</span></span> <span data-ttu-id="a545a-189">Aunque estos métodos y devoluciones de llamada son asincrónicos, el tiempo de ejecución de los actores no los intercala.</span><span class="sxs-lookup"><span data-stu-id="a545a-189">Even though these methods and callbacks are asynchronous, the Actors runtime does not interleave them.</span></span> <span data-ttu-id="a545a-190">Un turno debe completarse por completo antes de que se permita uno nuevo.</span><span class="sxs-lookup"><span data-stu-id="a545a-190">A turn must be fully finished before a new turn is allowed.</span></span> <span data-ttu-id="a545a-191">En otras palabras, la devolución de llamada de un método de actor, un temporizador o recordatorio que se esté ejecutando se debe completar totalmente antes de que se permita una llamada a un método o una devolución de llamada nuevas.</span><span class="sxs-lookup"><span data-stu-id="a545a-191">In other words, an actor method or timer/reminder callback that is currently executing must be fully finished before a new call to a method or callback is allowed.</span></span> <span data-ttu-id="a545a-192">Un método o una devolución de llamada se consideran finalizadas si la ejecución ha devuelto desde el método o la devolución de llamada y la tarea devuelta por el método o la devolución de llamada ha terminado.</span><span class="sxs-lookup"><span data-stu-id="a545a-192">A method or callback is considered to have finished if the execution has returned from the method or callback and the task returned by the method or callback has finished.</span></span> <span data-ttu-id="a545a-193">Merece la pena resaltar que la simultaneidad basada en turnos se respeta incluso entre devoluciones de llamada, temporizadores y métodos diferentes.</span><span class="sxs-lookup"><span data-stu-id="a545a-193">It is worth emphasizing that turn-based concurrency is respected even across different methods, timers, and callbacks.</span></span>

<span data-ttu-id="a545a-194">El tiempo de ejecución de los actores impone la simultaneidad basada en turnos mediante la adquisición de un bloqueo por actor al principio de un turno y su liberación al final del turno.</span><span class="sxs-lookup"><span data-stu-id="a545a-194">The Actors runtime enforces turn-based concurrency by acquiring a per-actor lock at the beginning of a turn and releasing the lock at the end of the turn.</span></span> <span data-ttu-id="a545a-195">Por lo tanto, la simultaneidad basada en turnos se aplica por actor y no para todos los actores.</span><span class="sxs-lookup"><span data-stu-id="a545a-195">Thus, turn-based concurrency is enforced on a per-actor basis and not across actors.</span></span> <span data-ttu-id="a545a-196">Las devoluciones de llamada de los métodos de actor, los temporizadores y los recordatorios se pueden ejecutar simultáneamente en nombre de los diferentes actores.</span><span class="sxs-lookup"><span data-stu-id="a545a-196">Actor methods and timer/reminder callbacks can execute simultaneously on behalf of different actors.</span></span>

<span data-ttu-id="a545a-197">En el ejemplo siguiente se muestran los conceptos anteriores.</span><span class="sxs-lookup"><span data-stu-id="a545a-197">The following example illustrates the above concepts.</span></span> <span data-ttu-id="a545a-198">Supongamos un tipo de actor que implementa dos métodos asincrónicos (digamos *Method1* y *Method2*), un temporizador y un recordatorio.</span><span class="sxs-lookup"><span data-stu-id="a545a-198">Consider an actor type that implements two asynchronous methods (say, *Method1* and *Method2*), a timer, and a reminder.</span></span> <span data-ttu-id="a545a-199">En el diagrama siguiente se muestra un ejemplo de una escala de tiempo de la ejecución de estos métodos y las devoluciones de llamada en nombre de los dos actores (*ActorId1* y *ActorId2*) que pertenecen a este tipo de actor.</span><span class="sxs-lookup"><span data-stu-id="a545a-199">The diagram below shows an example of a timeline for the execution of these methods and callbacks on behalf of two actors (*ActorId1* and *ActorId2*) that belong to this actor type.</span></span>

![Acceso y simultaneidad basada en turnos de tiempo de ejecución de Reliable Actors][1]

<span data-ttu-id="a545a-201">Este diagrama sigue estas convenciones:</span><span class="sxs-lookup"><span data-stu-id="a545a-201">This diagram follows these conventions:</span></span>

* <span data-ttu-id="a545a-202">Cada línea vertical muestra el flujo lógico de ejecución de un método o una devolución de llamada en nombre de un actor determinado.</span><span class="sxs-lookup"><span data-stu-id="a545a-202">Each vertical line shows the logical flow of execution of a method or a callback on behalf of a particular actor.</span></span>
* <span data-ttu-id="a545a-203">Los eventos marcados en cada línea vertical se producen en orden cronológico, con los eventos más recientes por debajo de los más antiguos.</span><span class="sxs-lookup"><span data-stu-id="a545a-203">The events marked on each vertical line occur in chronological order, with newer events occurring below older ones.</span></span>
* <span data-ttu-id="a545a-204">Se usan colores diferentes para las escalas de tiempo correspondientes a actores distintos.</span><span class="sxs-lookup"><span data-stu-id="a545a-204">Different colors are used for timelines corresponding to different actors.</span></span>
* <span data-ttu-id="a545a-205">Se usa el resaltado para indicar la duración durante la cual se mantiene el bloqueo por actor en nombre de un método o una devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="a545a-205">Highlighting is used to indicate the duration for which the per-actor lock is held on behalf of a method or callback.</span></span>

<span data-ttu-id="a545a-206">Algunos puntos importantes a tener en cuenta:</span><span class="sxs-lookup"><span data-stu-id="a545a-206">Some important points to consider:</span></span>

* <span data-ttu-id="a545a-207">Cuando *Method1* se ejecuta en nombre de *ActorId2* en respuesta a la solicitud de cliente *xyz789*, llega otra solicitud de cliente (*abc123*) que también requiere que *Method1* lo ejecute *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="a545a-207">While *Method1* is executing on behalf of *ActorId2* in response to client request *xyz789*, another client request (*abc123*) arrives that also requires *Method1* to be executed by *ActorId2*.</span></span> <span data-ttu-id="a545a-208">Sin embargo, la segunda ejecución de *Method1* no comienza hasta que se haya completado la ejecución anterior.</span><span class="sxs-lookup"><span data-stu-id="a545a-208">However, the second execution of *Method1* does not begin until the prior execution has finished.</span></span> <span data-ttu-id="a545a-209">De forma similar, un recordatorio que haya registrado *ActorId2* se activa cuando *Method1* se ejecuta en respuesta a la solicitud de cliente *xyz789*.</span><span class="sxs-lookup"><span data-stu-id="a545a-209">Similarly, a reminder registered by *ActorId2* fires while *Method1* is being executed in response to client request *xyz789*.</span></span> <span data-ttu-id="a545a-210">La devolución de llamada del recordatorio se ejecuta solo después de que las dos ejecuciones de *Method1* se hayan completado.</span><span class="sxs-lookup"><span data-stu-id="a545a-210">The reminder callback is executed only after both executions of *Method1* are complete.</span></span> <span data-ttu-id="a545a-211">Todo esto se debe a la simultaneidad basada en turnos que se exige para *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="a545a-211">All of this is due to turn-based concurrency being enforced for *ActorId2*.</span></span>
* <span data-ttu-id="a545a-212">De forma similar, también se aplica la simultaneidad basada en turnos para *ActorId1*, como se muestra en la ejecución de *Method1*, la ejecución de *Method2* y la devolución de llamada del temporizador en nombre de *ActorId1*, que suceden en serie.</span><span class="sxs-lookup"><span data-stu-id="a545a-212">Similarly, turn-based concurrency is also enforced for *ActorId1*, as demonstrated by the execution of *Method1*, *Method2*, and the timer callback on behalf of *ActorId1* happening in a serial fashion.</span></span>
* <span data-ttu-id="a545a-213">La ejecución de *Method1* en nombre de *ActorId1* se superpone con su ejecución en nombre de *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="a545a-213">Execution of *Method1* on behalf of *ActorId1* overlaps with its execution on behalf of *ActorId2*.</span></span> <span data-ttu-id="a545a-214">Esto es así porque solo se exige la simultaneidad basada en turnos dentro de un actor y no para todos los actores.</span><span class="sxs-lookup"><span data-stu-id="a545a-214">This is because turn-based concurrency is enforced only within an actor and not across actors.</span></span>
* <span data-ttu-id="a545a-215">En algunas ejecuciones de métodos y devoluciones de llamada, el elemento `Task`(C#) / `CompletableFuture`(Java) que devuelve el método o la devolución de llamada se completa después de la devolución del método.</span><span class="sxs-lookup"><span data-stu-id="a545a-215">In some of the method/callback executions, the `Task`(C#) / `CompletableFuture`(Java) returned by the method/callback finishes after the method returns.</span></span> <span data-ttu-id="a545a-216">En otras, la operación asincrónica ya se completó antes de la devolución del método o la devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="a545a-216">In some others, the asynchronous operation has already finished by the time the method/callback returns.</span></span> <span data-ttu-id="a545a-217">En ambos casos, el bloqueo por actor se libera solo después de la devolución del método o la devolución de llamada, y de la finalización de la operación asincrónica.</span><span class="sxs-lookup"><span data-stu-id="a545a-217">In both cases, the per-actor lock is released only after both the method/callback returns and the asynchronous operation finishes.</span></span>

#### <a name="reentrancy"></a><span data-ttu-id="a545a-218">Reentrada</span><span class="sxs-lookup"><span data-stu-id="a545a-218">Reentrancy</span></span>
<span data-ttu-id="a545a-219">El tiempo de ejecución de los actores permite la reentrada de forma predeterminada.</span><span class="sxs-lookup"><span data-stu-id="a545a-219">The Actors runtime allows reentrancy by default.</span></span> <span data-ttu-id="a545a-220">Esto significa que si un método de actor del *actor A* llama a un método del *actor B*, que a su vez llama a otro método del *actor A*, se permite que ese método se ejecute.</span><span class="sxs-lookup"><span data-stu-id="a545a-220">This means that if an actor method of *Actor A* calls a method on *Actor B*, which in turn calls another method on *Actor A*, that method is allowed to run.</span></span> <span data-ttu-id="a545a-221">Esto es porque forma parte del mismo contexto lógico de la cadena de llamada.</span><span class="sxs-lookup"><span data-stu-id="a545a-221">This is because it is part of the same logical call-chain context.</span></span> <span data-ttu-id="a545a-222">Todas las llamadas del temporizador y el recordatorio comienzan con el nuevo contexto de llamada lógico.</span><span class="sxs-lookup"><span data-stu-id="a545a-222">All timer and reminder calls start with the new logical call context.</span></span> <span data-ttu-id="a545a-223">Consulte [Reentrada en Reliable Actors](service-fabric-reliable-actors-reentrancy.md) para más detalles.</span><span class="sxs-lookup"><span data-stu-id="a545a-223">See the [Reliable Actors reentrancy](service-fabric-reliable-actors-reentrancy.md) for more details.</span></span>

#### <a name="scope-of-concurrency-guarantees"></a><span data-ttu-id="a545a-224">Ámbito de garantías de simultaneidad</span><span class="sxs-lookup"><span data-stu-id="a545a-224">Scope of concurrency guarantees</span></span>
<span data-ttu-id="a545a-225">El tiempo de ejecución de los actores ofrece estas garantías de simultaneidad en situaciones donde controla la invocación de estos métodos.</span><span class="sxs-lookup"><span data-stu-id="a545a-225">The Actors runtime provides these concurrency guarantees in situations where it controls the invocation of these methods.</span></span> <span data-ttu-id="a545a-226">Por ejemplo, ofrece estas garantías para las invocaciones de método que se realizan en respuesta a una solicitud de cliente y para las devoluciones de llamada de temporizadores y recordatorios.</span><span class="sxs-lookup"><span data-stu-id="a545a-226">For example, it provides these guarantees for the method invocations that are done in response to a client request, as well as for timer and reminder callbacks.</span></span> <span data-ttu-id="a545a-227">Sin embargo, si el código del actor invoca directamente a estos métodos fuera de los mecanismos que ofrece el tiempo de ejecución de los actores, el tiempo de ejecución no puede ofrecer ninguna garantía de simultaneidad.</span><span class="sxs-lookup"><span data-stu-id="a545a-227">However, if the actor code directly invokes these methods outside of the mechanisms provided by the Actors runtime, then the runtime cannot provide any concurrency guarantees.</span></span> <span data-ttu-id="a545a-228">Por ejemplo, si el método se invoca en el contexto de una tarea que no está asociada con la tarea que han devuelto los métodos de actor, el tiempo de ejecución no puede ofrecer garantías de simultaneidad.</span><span class="sxs-lookup"><span data-stu-id="a545a-228">For example, if the method is invoked in the context of some task that is not associated with the task returned by the actor methods, then the runtime cannot provide concurrency guarantees.</span></span> <span data-ttu-id="a545a-229">Si el método se invoca desde un subproceso que el actor crea por sí mismo, entonces el tiempo de ejecución tampoco puede proporcionar garantías de simultaneidad.</span><span class="sxs-lookup"><span data-stu-id="a545a-229">If the method is invoked from a thread that the actor creates on its own, then the runtime also cannot provide concurrency guarantees.</span></span> <span data-ttu-id="a545a-230">Por lo tanto, para realizar operaciones en segundo plano, los actores deben usar [temporizadores de actor o recordatorios de actor](service-fabric-reliable-actors-timers-reminders.md) que respeten la simultaneidad basada en turnos.</span><span class="sxs-lookup"><span data-stu-id="a545a-230">Therefore, to perform background operations, actors should use [actor timers and actor reminders](service-fabric-reliable-actors-timers-reminders.md) that respect turn-based concurrency.</span></span>

## <a name="next-steps"></a><span data-ttu-id="a545a-231">Pasos siguientes</span><span class="sxs-lookup"><span data-stu-id="a545a-231">Next steps</span></span>
* <span data-ttu-id="a545a-232">Para empezar, cree su primer servicio de Reliable Actors:</span><span class="sxs-lookup"><span data-stu-id="a545a-232">Get started by building your first Reliable Actors service:</span></span>
   * [<span data-ttu-id="a545a-233">Introducción a Reliable Actors en .NET</span><span class="sxs-lookup"><span data-stu-id="a545a-233">Getting started with Reliable Actors on .NET</span></span>](service-fabric-reliable-actors-get-started.md)
   * [<span data-ttu-id="a545a-234">Introducción a Reliable Actors en Java</span><span class="sxs-lookup"><span data-stu-id="a545a-234">Getting started with Reliable Actors on Java</span></span>](service-fabric-reliable-actors-get-started-java.md)

<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-introduction/concurrency.png
[2]: ./media/service-fabric-reliable-actors-introduction/distribution.png
[3]: ./media/service-fabric-reliable-actors-introduction/actor-communication.png
