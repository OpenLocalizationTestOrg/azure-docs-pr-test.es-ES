---
title: "aaaService tejido confiable actores Introducción | Documentos de Microsoft"
description: "Modelo de programación de introducción toohello Reliable Actors de tejido de servicio."
services: service-fabric
documentationcenter: .net
author: vturecek
manager: timlt
editor: 
ms.assetid: 7fdad07f-f2d6-4c74-804d-e0d56131f060
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/29/2017
ms.author: vturecek
ms.openlocfilehash: ab010cbf936c6cf723b3d453ef95a9bf51f76c95
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 10/06/2017
---
# <a name="introduction-tooservice-fabric-reliable-actors"></a><span data-ttu-id="734ef-103">Introducción tooService tejido Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="734ef-103">Introduction tooService Fabric Reliable Actors</span></span>
<span data-ttu-id="734ef-104">Actores confiables es un marco de aplicación de Service Fabric en función de hello [Actor Virtual](http://research.microsoft.com/en-us/projects/orleans/) patrón.</span><span class="sxs-lookup"><span data-stu-id="734ef-104">Reliable Actors is a Service Fabric application framework based on hello [Virtual Actor](http://research.microsoft.com/en-us/projects/orleans/) pattern.</span></span> <span data-ttu-id="734ef-105">Hola API de actores confiable proporciona un modelo de programación uniproceso basado en garantías de confiabilidad y escalabilidad de hello proporcionadas por Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="734ef-105">hello Reliable Actors API provides a single-threaded programming model built on hello scalability and reliability guarantees provided by Service Fabric.</span></span>

## <a name="what-are-actors"></a><span data-ttu-id="734ef-106">¿Qué son los actores?</span><span class="sxs-lookup"><span data-stu-id="734ef-106">What are Actors?</span></span>
<span data-ttu-id="734ef-107">Un actor es una unidad aislada e independiente de proceso y estado con ejecución uniproceso.</span><span class="sxs-lookup"><span data-stu-id="734ef-107">An actor is an isolated, independent unit of compute and state with single-threaded execution.</span></span> <span data-ttu-id="734ef-108">Hola [patrón actor](https://en.wikipedia.org/wiki/Actor_model) es un modelo de cálculo para los sistemas simultáneos o distribuidos en que un gran número de estos actores puede ejecutar simultáneamente e independientemente entre sí.</span><span class="sxs-lookup"><span data-stu-id="734ef-108">hello [actor pattern](https://en.wikipedia.org/wiki/Actor_model) is a computational model for concurrent or distributed systems in which a large number of these actors can execute simultaneously and independently of each other.</span></span> <span data-ttu-id="734ef-109">Los actores pueden comunicarse entre sí y pueden crear más actores.</span><span class="sxs-lookup"><span data-stu-id="734ef-109">Actors can communicate with each other and they can create more actors.</span></span>

### <a name="when-toouse-reliable-actors"></a><span data-ttu-id="734ef-110">Cuando toouse Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="734ef-110">When toouse Reliable Actors</span></span>
<span data-ttu-id="734ef-111">Servicio Fabric Reliable Actors es una implementación del patrón de diseño de hello actor.</span><span class="sxs-lookup"><span data-stu-id="734ef-111">Service Fabric Reliable Actors is an implementation of hello actor design pattern.</span></span> <span data-ttu-id="734ef-112">Al igual que con cualquier modelo de diseño de software, decisión Hola si toouse un patrón específico estará en función de si un software diseñe problema encaja patrón Hola.</span><span class="sxs-lookup"><span data-stu-id="734ef-112">As with any software design pattern, hello decision whether toouse a specific pattern is made based on whether or not a software design problem fits hello pattern.</span></span>

<span data-ttu-id="734ef-113">Aunque el modelo de diseño de hello actor puede ser un número de buena tooa ajuste de problemas de sistemas distribuidos y escenarios, debe valorarse cuidadosamente las restricciones de Hola de patrón de Hola y Hola framework implementar deben realizarse.</span><span class="sxs-lookup"><span data-stu-id="734ef-113">Although hello actor design pattern can be a good fit tooa number of distributed systems problems and scenarios, careful consideration of hello constraints of hello pattern and hello framework implementing it must be made.</span></span> <span data-ttu-id="734ef-114">Como guía general, considere la posibilidad de hello actor patrón toomodel su problema o escenario si:</span><span class="sxs-lookup"><span data-stu-id="734ef-114">As general guidance, consider hello actor pattern toomodel your problem or scenario if:</span></span>

* <span data-ttu-id="734ef-115">El espacio del problema implica un gran número (miles o más) de unidades pequeñas, independientes y aisladas de estado y lógica.</span><span class="sxs-lookup"><span data-stu-id="734ef-115">Your problem space involves a large number (thousands or more) of small, independent, and isolated units of state and logic.</span></span>
* <span data-ttu-id="734ef-116">Desea toowork con objetos de un único subproceso que no requieren interacción importante de los componentes externos, incluidas las consultas de estado a través de un conjunto de actores.</span><span class="sxs-lookup"><span data-stu-id="734ef-116">You want toowork with single-threaded objects that do not require significant interaction from external components, including querying state across a set of actors.</span></span>
* <span data-ttu-id="734ef-117">Las instancias de actor no bloquearán a los autores de llamadas con retrasos imprevisibles emitiendo operaciones de E/S.</span><span class="sxs-lookup"><span data-stu-id="734ef-117">Your actor instances won't block callers with unpredictable delays by issuing I/O operations.</span></span>

## <a name="actors-in-service-fabric"></a><span data-ttu-id="734ef-118">Actores en Service Fabric</span><span class="sxs-lookup"><span data-stu-id="734ef-118">Actors in Service Fabric</span></span>
<span data-ttu-id="734ef-119">En Service Fabric, actores se implementan en el marco de trabajo de hello Reliable Actors: un marco de trabajo de aplicaciones basados en el patrón de actor construido sobre [servicios confiables de tejido de servicio](service-fabric-reliable-services-introduction.md).</span><span class="sxs-lookup"><span data-stu-id="734ef-119">In Service Fabric, actors are implemented in hello Reliable Actors framework: An actor-pattern-based application framework built on top of [Service Fabric Reliable Services](service-fabric-reliable-services-introduction.md).</span></span> <span data-ttu-id="734ef-120">Cada servicio de Reliable Actors que escribe es en realidad un servicio de confianza con estado particionado.</span><span class="sxs-lookup"><span data-stu-id="734ef-120">Each Reliable Actor service you write is actually a partitioned, stateful Reliable Service.</span></span>

<span data-ttu-id="734ef-121">Cada actor se define como una instancia de un tipo de actor, toohello idéntica forma un objeto .NET es una instancia de un tipo. NET.</span><span class="sxs-lookup"><span data-stu-id="734ef-121">Every actor is defined as an instance of an actor type, identical toohello way a .NET object is an instance of a .NET type.</span></span> <span data-ttu-id="734ef-122">Por ejemplo, puede haber un tipo de actor que implementa la funcionalidad de Hola de una calculadora y podría haber muchos actores de ese tipo que se distribuyen en varios nodos en un clúster.</span><span class="sxs-lookup"><span data-stu-id="734ef-122">For example, there may be an actor type that implements hello functionality of a calculator and there could be many actors of that type that are distributed on various nodes across a cluster.</span></span> <span data-ttu-id="734ef-123">Cada uno de esos actores se identifica de forma única mediante un identificador de actor.</span><span class="sxs-lookup"><span data-stu-id="734ef-123">Each such actor is uniquely identified by an actor ID.</span></span>

### <a name="actor-lifetime"></a><span data-ttu-id="734ef-124">Duración del actor</span><span class="sxs-lookup"><span data-stu-id="734ef-124">Actor Lifetime</span></span>
<span data-ttu-id="734ef-125">Actores de Service Fabric son virtuales, lo que significa que su duración no es de representación en memoria de tootheir relacionados.</span><span class="sxs-lookup"><span data-stu-id="734ef-125">Service Fabric actors are virtual, meaning that their lifetime is not tied tootheir in-memory representation.</span></span> <span data-ttu-id="734ef-126">Como resultado, no es necesario toobe cree explícitamente o se destruya.</span><span class="sxs-lookup"><span data-stu-id="734ef-126">As a result, they do not need toobe explicitly created or destroyed.</span></span> <span data-ttu-id="734ef-127">en tiempo de ejecución de Hello Reliable Actors activa automáticamente una Hola actor primera vez que se recibe una solicitud para dicho Id. de actor</span><span class="sxs-lookup"><span data-stu-id="734ef-127">hello Reliable Actors runtime automatically activates an actor hello first time it receives a request for that actor ID.</span></span> <span data-ttu-id="734ef-128">Si no se usa un actor durante un período de tiempo, en tiempo de ejecución de hello Reliable Actors elementos no utilizados-recopila objeto de hello en memoria.</span><span class="sxs-lookup"><span data-stu-id="734ef-128">If an actor is not used for a period of time, hello Reliable Actors runtime garbage-collects hello in-memory object.</span></span> <span data-ttu-id="734ef-129">También mantendrá conocimiento de la existencia del actor Hola necesario toobe reactivar más adelante.</span><span class="sxs-lookup"><span data-stu-id="734ef-129">It will also maintain knowledge of hello actor's existence should it need toobe reactivated later.</span></span> <span data-ttu-id="734ef-130">Para más información, consulte [Ciclo de vida de un actor y recolección de elementos no utilizados](service-fabric-reliable-actors-lifecycle.md).</span><span class="sxs-lookup"><span data-stu-id="734ef-130">For more details, see [Actor lifecycle and garbage collection](service-fabric-reliable-actors-lifecycle.md).</span></span>

<span data-ttu-id="734ef-131">Esta abstracción de duración de actor virtual lleva a cabo algunas advertencias como resultado de modelo de actor virtual Hola y de hecho la implementación Reliable Actors Hola se desvía a veces de este modelo.</span><span class="sxs-lookup"><span data-stu-id="734ef-131">This virtual actor lifetime abstraction carries some caveats as a result of hello virtual actor model, and in fact hello Reliable Actors implementation deviates at times from this model.</span></span>

* <span data-ttu-id="734ef-132">Un actor se activa automáticamente (lo que provoca un actor toobe objeto construido) Hola la primera vez que se envía un mensaje tooits Id. de actor.</span><span class="sxs-lookup"><span data-stu-id="734ef-132">An actor is automatically activated (causing an actor object toobe constructed) hello first time a message is sent tooits actor ID.</span></span> <span data-ttu-id="734ef-133">Después de un período de tiempo, objeto de actor hello es recolectado.</span><span class="sxs-lookup"><span data-stu-id="734ef-133">After some period of time, hello actor object is garbage collected.</span></span> <span data-ttu-id="734ef-134">Hola futuro, vuelva a usar el Id. de actor Hola hace que un actor nueva toobe objeto construido.</span><span class="sxs-lookup"><span data-stu-id="734ef-134">In hello future, using hello actor ID again, causes a new actor object toobe constructed.</span></span> <span data-ttu-id="734ef-135">Estado de un actor es mayor duración del objeto de hello cuando se almacenan en el Administrador de estado de Hola.</span><span class="sxs-lookup"><span data-stu-id="734ef-135">An actor's state outlives hello object's lifetime when stored in hello state manager.</span></span>
* <span data-ttu-id="734ef-136">Al llamar a cualquier método de actor para un identificador de actor se activa dicho actor.</span><span class="sxs-lookup"><span data-stu-id="734ef-136">Calling any actor method for an actor ID activates that actor.</span></span> <span data-ttu-id="734ef-137">Por este motivo, los tipos de actor tienen su constructor llama implícitamente a hello en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="734ef-137">For this reason, actor types have their constructor called implicitly by hello runtime.</span></span> <span data-ttu-id="734ef-138">Por lo tanto, el código de cliente no puede pasar al constructor del tipo de parámetros toohello actor, aunque pueden pasarse a parámetros de constructor de actor toohello por el propio servicio Hola.</span><span class="sxs-lookup"><span data-stu-id="734ef-138">Therefore, client code cannot pass parameters toohello actor type's constructor, although parameters may be passed toohello actor's constructor by hello service itself.</span></span> <span data-ttu-id="734ef-139">resultado de Hello es que actores se pueden construir en un estado parcialmente inicializada por otros métodos se invocan en él, el tiempo de hello si actor Hola requiere parámetros de inicialización de cliente de Hola.</span><span class="sxs-lookup"><span data-stu-id="734ef-139">hello result is that actors may be constructed in a partially-initialized state by hello time other methods are called on it, if hello actor requires initialization parameters from hello client.</span></span> <span data-ttu-id="734ef-140">No hay ningún punto de entrada único para la activación de Hola de un actor desde el cliente de Hola.</span><span class="sxs-lookup"><span data-stu-id="734ef-140">There is no single entry point for hello activation of an actor from hello client.</span></span>
* <span data-ttu-id="734ef-141">Aunque Reliable Actors implícitamente crear objetos de actor; es necesario Hola capacidad tooexplicitly eliminar un actor y su estado.</span><span class="sxs-lookup"><span data-stu-id="734ef-141">Although Reliable Actors implicitly create actor objects; you do have hello ability tooexplicitly delete an actor and its state.</span></span>

### <a name="distribution-and-failover"></a><span data-ttu-id="734ef-142">Distribución y conmutación por error</span><span class="sxs-lookup"><span data-stu-id="734ef-142">Distribution and failover</span></span>
<span data-ttu-id="734ef-143">tooprovide escalabilidad y confiabilidad, Service Fabric distribuye actores en todo el clúster de Hola y automáticamente migra desde nodos erróneos toohealthy los según sea necesario.</span><span class="sxs-lookup"><span data-stu-id="734ef-143">tooprovide scalability and reliability, Service Fabric distributes actors throughout hello cluster and automatically migrates them from failed nodes toohealthy ones as required.</span></span> <span data-ttu-id="734ef-144">Se trata de una abstracción sobre un [servicio de confianza con estado particionado](service-fabric-concepts-partitioning.md).</span><span class="sxs-lookup"><span data-stu-id="734ef-144">This is an abstraction over a [partitioned, stateful Reliable Service](service-fabric-concepts-partitioning.md).</span></span> <span data-ttu-id="734ef-145">Distribución, escalabilidad, confiabilidad y conmutación automática por error se proporcionan en virtud de los hechos de Hola que actores se ejecutan dentro de un servicio confiable con estado llamado hello *servicio de Actor*.</span><span class="sxs-lookup"><span data-stu-id="734ef-145">Distribution, scalability, reliability, and automatic failover are all provided by virtue of hello fact that actors are running inside a stateful Reliable Service called hello *Actor Service*.</span></span>

<span data-ttu-id="734ef-146">Actores se distribuyen entre particiones de Hola de hello servicio de Actor y estas particiones se distribuyen en nodos de hello en un clúster de Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="734ef-146">Actors are distributed across hello partitions of hello Actor Service, and those partitions are distributed across hello nodes in a Service Fabric cluster.</span></span> <span data-ttu-id="734ef-147">Cada partición del servicio contiene un conjunto de actores.</span><span class="sxs-lookup"><span data-stu-id="734ef-147">Each service partition contains a set of actors.</span></span> <span data-ttu-id="734ef-148">Service Fabric administra la distribución y la conmutación por error de las particiones del servicio Hola.</span><span class="sxs-lookup"><span data-stu-id="734ef-148">Service Fabric manages distribution and failover of hello service partitions.</span></span>

<span data-ttu-id="734ef-149">Por ejemplo, un servicio de actor con nueve particiones implementa toothree se distribuyen nodos mediante la colocación de partición de actor de hello predeterminada consiste en lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="734ef-149">For example, an actor service with nine partitions deployed toothree nodes using hello default actor partition placement would be distributed thusly:</span></span>

![Distribución de Reliable Actors][2]

<span data-ttu-id="734ef-151">Hola Actor Framework administra la configuración de los intervalos de esquema y la clave de partición para el.</span><span class="sxs-lookup"><span data-stu-id="734ef-151">hello Actor Framework manages partition scheme and key range settings for you.</span></span> <span data-ttu-id="734ef-152">Esto simplifica algunas opciones, pero también implica cierta consideración:</span><span class="sxs-lookup"><span data-stu-id="734ef-152">This simplifies some choices but also carries some consideration:</span></span>

* <span data-ttu-id="734ef-153">Servicios de confianza permite toochoose un esquema de partición, intervalo de claves (cuando se usa un intervalo de esquema de partición) y el número de partición.</span><span class="sxs-lookup"><span data-stu-id="734ef-153">Reliable Services allows you toochoose a partitioning scheme, key range (when using a range partitioning scheme), and partition count.</span></span> <span data-ttu-id="734ef-154">Actores confiables es el esquema de partición de intervalo restringido toohello (esquema de Int64 uniforme Hola) y requiere que use Hola completa Int64 rango con clave.</span><span class="sxs-lookup"><span data-stu-id="734ef-154">Reliable Actors is restricted toohello range partitioning scheme (hello uniform Int64 scheme) and requires you use hello full Int64 key range.</span></span>
* <span data-ttu-id="734ef-155">De forma predeterminada, los actores se colocan aleatoriamente en particiones, dando como resultado una distribución uniforme.</span><span class="sxs-lookup"><span data-stu-id="734ef-155">By default, actors are randomly placed into partitions resulting in uniform distribution.</span></span>
* <span data-ttu-id="734ef-156">Como los actores se colocan aleatoriamente, debe esperarse que las operaciones del actor requieran siempre la comunicación de red, incluidas la serialización y deserialización de datos de la llamada al método, incurriendo en latencia y sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="734ef-156">Because actors are randomly placed, it should be expected that actor operations will always require network communication, including serialization and deserialization of method call data, incurring latency and overhead.</span></span>
* <span data-ttu-id="734ef-157">En escenarios avanzados, es selección de ubicación de toocontrol posible actor partición mediante el uso de actor Int64 identificadores que se asignan toospecific particiones.</span><span class="sxs-lookup"><span data-stu-id="734ef-157">In advanced scenarios, it is possible toocontrol actor partition placement by using Int64 actor IDs that map toospecific partitions.</span></span> <span data-ttu-id="734ef-158">Sin embargo, esto puede dar lugar a una distribución desequilibrada de los actores entre particiones.</span><span class="sxs-lookup"><span data-stu-id="734ef-158">However, doing so can result in an unbalanced distribution of actors across partitions.</span></span>

<span data-ttu-id="734ef-159">Para obtener más información sobre cómo se dividen los servicios de actor, consulte demasiado[particiones conceptos para actores](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span><span class="sxs-lookup"><span data-stu-id="734ef-159">For more information on how actor services are partitioned, refer too[partitioning concepts for actors](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span></span>

### <a name="actor-communication"></a><span data-ttu-id="734ef-160">Comunicación con actores</span><span class="sxs-lookup"><span data-stu-id="734ef-160">Actor communication</span></span>
<span data-ttu-id="734ef-161">Interacciones de actor se definen en una interfaz que se comparte por actor Hola que implementa la interfaz de Hola y el cliente de Hola que obtiene un proxy actor tooan a través de hello misma interfaz.</span><span class="sxs-lookup"><span data-stu-id="734ef-161">Actor interactions are defined in an interface that is shared by hello actor that implements hello interface, and hello client that gets a proxy tooan actor via hello same interface.</span></span> <span data-ttu-id="734ef-162">Dado que esta interfaz es tooinvoke usado actor métodos de forma asincrónica, cada método de interfaz de hello debe ser de devolución de tarea.</span><span class="sxs-lookup"><span data-stu-id="734ef-162">Because this interface is used tooinvoke actor methods asynchronously, every method on hello interface must be Task-returning.</span></span>

<span data-ttu-id="734ef-163">Las invocaciones de método y sus respuestas en última instancia como resultado las solicitudes de red en clúster de hello, por lo que argumentos de Hola y tipos de resultado de hello de tareas de Hola que deben ser serializables por plataforma de Hola.</span><span class="sxs-lookup"><span data-stu-id="734ef-163">Method invocations and their responses ultimately result in network requests across hello cluster, so hello arguments and hello result types of hello tasks that they return must be serializable by hello platform.</span></span> <span data-ttu-id="734ef-164">En particular, deben ser [serializables mediante contrato de datos](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="734ef-164">In particular, they must be [data contract serializable](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span></span>

#### <a name="hello-actor-proxy"></a><span data-ttu-id="734ef-165">proxy de actor Hola</span><span class="sxs-lookup"><span data-stu-id="734ef-165">hello actor proxy</span></span>
<span data-ttu-id="734ef-166">API de cliente de Reliable Actors Hola permite la comunicación entre una instancia de actor y un cliente de actor.</span><span class="sxs-lookup"><span data-stu-id="734ef-166">hello Reliable Actors client API provides communication between an actor instance and an actor client.</span></span> <span data-ttu-id="734ef-167">toocommunicate con un actor, un cliente crea un objeto de proxy de actor que implementa la interfaz de actor Hola.</span><span class="sxs-lookup"><span data-stu-id="734ef-167">toocommunicate with an actor, a client creates an actor proxy object that implements hello actor interface.</span></span> <span data-ttu-id="734ef-168">cliente de Hello interactúa con actor Hola invocar métodos en el objeto de proxy de Hola.</span><span class="sxs-lookup"><span data-stu-id="734ef-168">hello client interacts with hello actor by invoking methods on hello proxy object.</span></span> <span data-ttu-id="734ef-169">proxy de actor Hola se puede utilizar para la comunicación de cliente al actor y el actor al actor.</span><span class="sxs-lookup"><span data-stu-id="734ef-169">hello actor proxy can be used for client-to-actor and actor-to-actor communication.</span></span>

```csharp
// Create a randomly distributed actor ID
ActorId actorId = ActorId.CreateRandom();

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
IMyActor myActor = ActorProxy.Create<IMyActor>(actorId, new Uri("fabric:/MyApp/MyActorService"));

// This will invoke a method on hello actor. If an actor with hello given ID does not exist, it will be activated by this method call.
await myActor.DoWorkAsync();
```

```java
// Create actor ID with some name
ActorId actorId = new ActorId("Actor1");

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
MyActor myActor = ActorProxyBase.create(actorId, new URI("fabric:/MyApp/MyActorService"), MyActor.class);

// This will invoke a method on hello actor. If an actor with hello given ID does not exist, it will be activated by this method call.
myActor.DoWorkAsync().get();
```


<span data-ttu-id="734ef-170">Tenga en cuenta que partes de hello dos de información usan objeto proxy de toocreate Hola actor son Id. de actor de Hola y nombre de la aplicación hello.</span><span class="sxs-lookup"><span data-stu-id="734ef-170">Note that hello two pieces of information used toocreate hello actor proxy object are hello actor ID and hello application name.</span></span> <span data-ttu-id="734ef-171">Id. de actor Hola identifica de forma única actor hello, mientras que identifica a nombre de la aplicación Hola Hola [aplicación de Service Fabric](service-fabric-reliable-actors-platform.md#application-model) donde se implementa el actor Hola.</span><span class="sxs-lookup"><span data-stu-id="734ef-171">hello actor ID uniquely identifies hello actor, while hello application name identifies hello [Service Fabric application](service-fabric-reliable-actors-platform.md#application-model) where hello actor is deployed.</span></span>

<span data-ttu-id="734ef-172">Hola `ActorProxy`(C#) / `ActorProxyBase`clase (Java) en el lado del cliente de hello realiza actor de hello resolución necesarios toolocate Hola por Id. y abrir un canal de comunicación con él.</span><span class="sxs-lookup"><span data-stu-id="734ef-172">hello `ActorProxy`(C#) / `ActorProxyBase`(Java) class on hello client side performs hello necessary resolution toolocate hello actor by ID and open a communication channel with it.</span></span> <span data-ttu-id="734ef-173">También realiza varios intentos toolocate actor de hello en los casos de Hola de errores de comunicación y las conmutaciones por error.</span><span class="sxs-lookup"><span data-stu-id="734ef-173">It also retries toolocate hello actor in hello cases of communication failures and failovers.</span></span> <span data-ttu-id="734ef-174">Como resultado, la entrega de mensajes tiene Hola siguientes características:</span><span class="sxs-lookup"><span data-stu-id="734ef-174">As a result, message delivery has hello following characteristics:</span></span>

* <span data-ttu-id="734ef-175">La entrega de mensajes es la mejor opción.</span><span class="sxs-lookup"><span data-stu-id="734ef-175">Message delivery is best effort.</span></span>
* <span data-ttu-id="734ef-176">Actores pueden recibir mensajes duplicados de hello mismo cliente.</span><span class="sxs-lookup"><span data-stu-id="734ef-176">Actors may receive duplicate messages from hello same client.</span></span>

### <a name="concurrency"></a><span data-ttu-id="734ef-177">Simultaneidad</span><span class="sxs-lookup"><span data-stu-id="734ef-177">Concurrency</span></span>
<span data-ttu-id="734ef-178">Hola Reliable Actors runtime proporciona un modelo de acceso a su vez simple para tener acceso a los métodos de actor.</span><span class="sxs-lookup"><span data-stu-id="734ef-178">hello Reliable Actors runtime provides a simple turn-based access model for accessing actor methods.</span></span> <span data-ttu-id="734ef-179">Esto significa que no puede haber más de un subproceso activo dentro del código del objeto de actor en ningún momento.</span><span class="sxs-lookup"><span data-stu-id="734ef-179">This means that no more than one thread can be active inside an actor object's code at any time.</span></span> <span data-ttu-id="734ef-180">El acceso basado en turnos simplifica considerablemente sistemas simultáneos, pues no es necesario que los mecanismos de sincronización tengan acceso a datos.</span><span class="sxs-lookup"><span data-stu-id="734ef-180">Turn-based access greatly simplifies concurrent systems as there is no need for synchronization mechanisms for data access.</span></span> <span data-ttu-id="734ef-181">También significa que los sistemas deben diseñarse con consideraciones especiales para la naturaleza de acceso de un único subproceso de Hola de cada instancia de actor.</span><span class="sxs-lookup"><span data-stu-id="734ef-181">It also means systems must be designed with special considerations for hello single-threaded access nature of each actor instance.</span></span>

* <span data-ttu-id="734ef-182">Una sola instancia de actor no puede procesar más de una solicitud cada vez.</span><span class="sxs-lookup"><span data-stu-id="734ef-182">A single actor instance cannot process more than one request at a time.</span></span> <span data-ttu-id="734ef-183">Una instancia de actor puede producir un cuello de botella de rendimiento si se toohandle esperado de solicitudes simultáneas.</span><span class="sxs-lookup"><span data-stu-id="734ef-183">An actor instance can cause a throughput bottleneck if it is expected toohandle concurrent requests.</span></span>
* <span data-ttu-id="734ef-184">Actores pueden bloquearse entre sí si hay una solicitud circular entre las dos partes implicadas mientras externa se realiza una solicitud tooone de actores Hola simultáneamente.</span><span class="sxs-lookup"><span data-stu-id="734ef-184">Actors can deadlock on each other if there is a circular request between two actors while an external request is made tooone of hello actors simultaneously.</span></span> <span data-ttu-id="734ef-185">Hola actor en tiempo de ejecución tendrán automáticamente una vez en actor llama y producir un toointerrupt de autor de llamada de excepción toohello posibles situaciones de interbloqueo.</span><span class="sxs-lookup"><span data-stu-id="734ef-185">hello actor runtime will automatically time out on actor calls and throw an exception toohello caller toointerrupt possible deadlock situations.</span></span>

![Comunicación de Reliable Actors][3]

#### <a name="turn-based-access"></a><span data-ttu-id="734ef-187">Acceso basada en turnos</span><span class="sxs-lookup"><span data-stu-id="734ef-187">Turn-based access</span></span>
<span data-ttu-id="734ef-188">Un turno consta de hello completar la ejecución de un método de actor en solicitud de respuesta tooa procedentes de otros clientes o actores o completar la ejecución de hello un [temporizador/aviso](service-fabric-reliable-actors-timers-reminders.md) devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="734ef-188">A turn consists of hello complete execution of an actor method in response tooa request from other actors or clients, or hello complete execution of a [timer/reminder](service-fabric-reliable-actors-timers-reminders.md) callback.</span></span> <span data-ttu-id="734ef-189">Aunque estos métodos y las devoluciones de llamada son asincrónicas, en tiempo de ejecución de hello actores no intercalar ellos.</span><span class="sxs-lookup"><span data-stu-id="734ef-189">Even though these methods and callbacks are asynchronous, hello Actors runtime does not interleave them.</span></span> <span data-ttu-id="734ef-190">Un turno debe completarse por completo antes de que se permita uno nuevo.</span><span class="sxs-lookup"><span data-stu-id="734ef-190">A turn must be fully finished before a new turn is allowed.</span></span> <span data-ttu-id="734ef-191">En otras palabras, un actor método o un temporizador/aviso devolución de llamada que se está ejecutando actualmente debe ser totalmente finalice antes que un nuevo método tooa de llamada o devolución de llamada es permitida.</span><span class="sxs-lookup"><span data-stu-id="734ef-191">In other words, an actor method or timer/reminder callback that is currently executing must be fully finished before a new call tooa method or callback is allowed.</span></span> <span data-ttu-id="734ef-192">Un método o una devolución de llamada se considera toohave terminado si ejecución Hola ha devuelto del método hello o tarea hello y devolución de llamada devuelta por el método hello o devolución de llamada ha terminado.</span><span class="sxs-lookup"><span data-stu-id="734ef-192">A method or callback is considered toohave finished if hello execution has returned from hello method or callback and hello task returned by hello method or callback has finished.</span></span> <span data-ttu-id="734ef-193">Merece la pena resaltar que la simultaneidad basada en turnos se respeta incluso entre devoluciones de llamada, temporizadores y métodos diferentes.</span><span class="sxs-lookup"><span data-stu-id="734ef-193">It is worth emphasizing that turn-based concurrency is respected even across different methods, timers, and callbacks.</span></span>

<span data-ttu-id="734ef-194">en tiempo de ejecución de Hello actores aplica la simultaneidad basada en Active al adquirir un bloqueo por actor al principio de hello vuelta y liberación de bloqueo de hello final Hola de hello activar.</span><span class="sxs-lookup"><span data-stu-id="734ef-194">hello Actors runtime enforces turn-based concurrency by acquiring a per-actor lock at hello beginning of a turn and releasing hello lock at hello end of hello turn.</span></span> <span data-ttu-id="734ef-195">Por lo tanto, la simultaneidad basada en turnos se aplica por actor y no para todos los actores.</span><span class="sxs-lookup"><span data-stu-id="734ef-195">Thus, turn-based concurrency is enforced on a per-actor basis and not across actors.</span></span> <span data-ttu-id="734ef-196">Las devoluciones de llamada de los métodos de actor, los temporizadores y los recordatorios se pueden ejecutar simultáneamente en nombre de los diferentes actores.</span><span class="sxs-lookup"><span data-stu-id="734ef-196">Actor methods and timer/reminder callbacks can execute simultaneously on behalf of different actors.</span></span>

<span data-ttu-id="734ef-197">Hola siguiente ejemplo muestra hello por encima de los conceptos.</span><span class="sxs-lookup"><span data-stu-id="734ef-197">hello following example illustrates hello above concepts.</span></span> <span data-ttu-id="734ef-198">Supongamos un tipo de actor que implementa dos métodos asincrónicos (digamos *Method1* y *Method2*), un temporizador y un recordatorio.</span><span class="sxs-lookup"><span data-stu-id="734ef-198">Consider an actor type that implements two asynchronous methods (say, *Method1* and *Method2*), a timer, and a reminder.</span></span> <span data-ttu-id="734ef-199">Hola diagrama siguiente muestra un ejemplo de una escala de tiempo para la ejecución de Hola de estos métodos y las devoluciones de llamada en nombre de dos actores (*ActorId1* y *ActorId2*) que pertenecen toothis actor tipo.</span><span class="sxs-lookup"><span data-stu-id="734ef-199">hello diagram below shows an example of a timeline for hello execution of these methods and callbacks on behalf of two actors (*ActorId1* and *ActorId2*) that belong toothis actor type.</span></span>

![Acceso y simultaneidad basada en turnos de tiempo de ejecución de Reliable Actors][1]

<span data-ttu-id="734ef-201">Este diagrama sigue estas convenciones:</span><span class="sxs-lookup"><span data-stu-id="734ef-201">This diagram follows these conventions:</span></span>

* <span data-ttu-id="734ef-202">Cada línea vertical muestra el flujo lógico de Hola de ejecución de un método o una devolución de llamada en nombre de un actor determinado.</span><span class="sxs-lookup"><span data-stu-id="734ef-202">Each vertical line shows hello logical flow of execution of a method or a callback on behalf of a particular actor.</span></span>
* <span data-ttu-id="734ef-203">se producen eventos de Hello marcados en cada línea vertical en orden cronológico, con los eventos más recientes que se producen por debajo de los antiguos.</span><span class="sxs-lookup"><span data-stu-id="734ef-203">hello events marked on each vertical line occur in chronological order, with newer events occurring below older ones.</span></span>
* <span data-ttu-id="734ef-204">Se usan colores diferentes para las escalas de tiempo correspondiente toodifferent actores.</span><span class="sxs-lookup"><span data-stu-id="734ef-204">Different colors are used for timelines corresponding toodifferent actors.</span></span>
* <span data-ttu-id="734ef-205">Resaltado es duración de hello tooindicate usado para qué Hola se mantiene el bloqueo por actor en nombre de un método o una devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="734ef-205">Highlighting is used tooindicate hello duration for which hello per-actor lock is held on behalf of a method or callback.</span></span>

<span data-ttu-id="734ef-206">Algunos tooconsider puntos importantes:</span><span class="sxs-lookup"><span data-stu-id="734ef-206">Some important points tooconsider:</span></span>

* <span data-ttu-id="734ef-207">Mientras *Method1* se está ejecutando en nombre de *ActorId2* en la solicitud de respuesta tooclient *xyz789*, otra solicitud de cliente (*abc123*) llega que también requiere *Method1* toobe ejecutado por *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="734ef-207">While *Method1* is executing on behalf of *ActorId2* in response tooclient request *xyz789*, another client request (*abc123*) arrives that also requires *Method1* toobe executed by *ActorId2*.</span></span> <span data-ttu-id="734ef-208">Sin embargo, Hola segunda ejecución de *Method1* no comienza hasta que haya finalizado la ejecución anterior de Hola.</span><span class="sxs-lookup"><span data-stu-id="734ef-208">However, hello second execution of *Method1* does not begin until hello prior execution has finished.</span></span> <span data-ttu-id="734ef-209">Del mismo modo, se registra un aviso por *ActorId2* se activa al *Method1* se está ejecutando en la solicitud de respuesta tooclient *xyz789*.</span><span class="sxs-lookup"><span data-stu-id="734ef-209">Similarly, a reminder registered by *ActorId2* fires while *Method1* is being executed in response tooclient request *xyz789*.</span></span> <span data-ttu-id="734ef-210">devolución de llamada de recordatorio Hello se ejecuta una solo después de las ejecuciones de *Method1* están completos.</span><span class="sxs-lookup"><span data-stu-id="734ef-210">hello reminder callback is executed only after both executions of *Method1* are complete.</span></span> <span data-ttu-id="734ef-211">Todo esto es debido a simultaneidad basada en tooturn que se exige para *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="734ef-211">All of this is due tooturn-based concurrency being enforced for *ActorId2*.</span></span>
* <span data-ttu-id="734ef-212">Del mismo modo, también se aplica la simultaneidad basada en Activar para *ActorId1*, como se muestra mediante la ejecución de Hola de *Method1*, *Method2*, y Hola de devolución de llamada de temporizador en nombre de *ActorId1* ocurre en un modo serie.</span><span class="sxs-lookup"><span data-stu-id="734ef-212">Similarly, turn-based concurrency is also enforced for *ActorId1*, as demonstrated by hello execution of *Method1*, *Method2*, and hello timer callback on behalf of *ActorId1* happening in a serial fashion.</span></span>
* <span data-ttu-id="734ef-213">La ejecución de *Method1* en nombre de *ActorId1* se superpone con su ejecución en nombre de *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="734ef-213">Execution of *Method1* on behalf of *ActorId1* overlaps with its execution on behalf of *ActorId2*.</span></span> <span data-ttu-id="734ef-214">Esto es así porque solo se exige la simultaneidad basada en turnos dentro de un actor y no para todos los actores.</span><span class="sxs-lookup"><span data-stu-id="734ef-214">This is because turn-based concurrency is enforced only within an actor and not across actors.</span></span>
* <span data-ttu-id="734ef-215">En algunas de las ejecuciones de devolución de llamada/método hello, Hola `Task`(C#) o `CompletableFuture`(Java) devuelto por Hola/devolución de llamada de método termina después de que vuelva el método hello.</span><span class="sxs-lookup"><span data-stu-id="734ef-215">In some of hello method/callback executions, hello `Task`(C#) / `CompletableFuture`(Java) returned by hello method/callback finishes after hello method returns.</span></span> <span data-ttu-id="734ef-216">En otros, la operación asincrónica de Hola ya ha terminado por tiempo Hola Hola método/devolución de llamada devuelve.</span><span class="sxs-lookup"><span data-stu-id="734ef-216">In some others, hello asynchronous operation has already finished by hello time hello method/callback returns.</span></span> <span data-ttu-id="734ef-217">En ambos casos, se libera el bloqueo por actor Hola solo después de que devuelve ambos método/devolución de llamada de Hola y Hola de operación asincrónica finalice.</span><span class="sxs-lookup"><span data-stu-id="734ef-217">In both cases, hello per-actor lock is released only after both hello method/callback returns and hello asynchronous operation finishes.</span></span>

#### <a name="reentrancy"></a><span data-ttu-id="734ef-218">Reentrada</span><span class="sxs-lookup"><span data-stu-id="734ef-218">Reentrancy</span></span>
<span data-ttu-id="734ef-219">en tiempo de ejecución de Hello actores permite reentrada de forma predeterminada.</span><span class="sxs-lookup"><span data-stu-id="734ef-219">hello Actors runtime allows reentrancy by default.</span></span> <span data-ttu-id="734ef-220">Esto significa que si un método de actor de *Actor A* llama a un método en *Actor B*, que a su vez llama a otro método en *Actor A*, que se permite método toorun.</span><span class="sxs-lookup"><span data-stu-id="734ef-220">This means that if an actor method of *Actor A* calls a method on *Actor B*, which in turn calls another method on *Actor A*, that method is allowed toorun.</span></span> <span data-ttu-id="734ef-221">Esto es porque es parte de hello mismo contexto de cadena de llamada lógico.</span><span class="sxs-lookup"><span data-stu-id="734ef-221">This is because it is part of hello same logical call-chain context.</span></span> <span data-ttu-id="734ef-222">Todas las llamadas de temporizador y un aviso iniciar con el nuevo contexto de llamada lógico Hola.</span><span class="sxs-lookup"><span data-stu-id="734ef-222">All timer and reminder calls start with hello new logical call context.</span></span> <span data-ttu-id="734ef-223">Vea hello [reentrada Reliable Actors](service-fabric-reliable-actors-reentrancy.md) para obtener más detalles.</span><span class="sxs-lookup"><span data-stu-id="734ef-223">See hello [Reliable Actors reentrancy](service-fabric-reliable-actors-reentrancy.md) for more details.</span></span>

#### <a name="scope-of-concurrency-guarantees"></a><span data-ttu-id="734ef-224">Ámbito de garantías de simultaneidad</span><span class="sxs-lookup"><span data-stu-id="734ef-224">Scope of concurrency guarantees</span></span>
<span data-ttu-id="734ef-225">en tiempo de ejecución de Hello actores proporciona estas garantías de simultaneidad en situaciones donde controla la invocación de Hola de estos métodos.</span><span class="sxs-lookup"><span data-stu-id="734ef-225">hello Actors runtime provides these concurrency guarantees in situations where it controls hello invocation of these methods.</span></span> <span data-ttu-id="734ef-226">Por ejemplo, proporciona estas garantías para las invocaciones de método de Hola que se efectúan en la solicitud de cliente de respuesta tooa, así como para las devoluciones de llamada de temporizador y un aviso.</span><span class="sxs-lookup"><span data-stu-id="734ef-226">For example, it provides these guarantees for hello method invocations that are done in response tooa client request, as well as for timer and reminder callbacks.</span></span> <span data-ttu-id="734ef-227">Sin embargo, si el código de hello actor invoca directamente estos métodos fuera de los mecanismos de hello proporcionados por el tiempo de ejecución de hello actores, hello en tiempo de ejecución no puede proporcionar las garantías de simultaneidad.</span><span class="sxs-lookup"><span data-stu-id="734ef-227">However, if hello actor code directly invokes these methods outside of hello mechanisms provided by hello Actors runtime, then hello runtime cannot provide any concurrency guarantees.</span></span> <span data-ttu-id="734ef-228">Por ejemplo, si se invoca el método hello en contexto de Hola de algunas tareas que no esté asociado con la tarea hello devuelto por métodos de actor hello, hello en tiempo de ejecución no proporciona garantías de simultaneidad.</span><span class="sxs-lookup"><span data-stu-id="734ef-228">For example, if hello method is invoked in hello context of some task that is not associated with hello task returned by hello actor methods, then hello runtime cannot provide concurrency guarantees.</span></span> <span data-ttu-id="734ef-229">Si se invoca el método hello desde un subproceso actor Hola crea por sí mismo, a continuación, en tiempo de ejecución de hello también proporcionan garantías de simultaneidad.</span><span class="sxs-lookup"><span data-stu-id="734ef-229">If hello method is invoked from a thread that hello actor creates on its own, then hello runtime also cannot provide concurrency guarantees.</span></span> <span data-ttu-id="734ef-230">Por lo tanto, deben usar los actores de operaciones en segundo plano tooperform, [temporizadores de actor y recordatorios de actor](service-fabric-reliable-actors-timers-reminders.md) que respeta la simultaneidad basada en el turno.</span><span class="sxs-lookup"><span data-stu-id="734ef-230">Therefore, tooperform background operations, actors should use [actor timers and actor reminders](service-fabric-reliable-actors-timers-reminders.md) that respect turn-based concurrency.</span></span>

## <a name="next-steps"></a><span data-ttu-id="734ef-231">Pasos siguientes</span><span class="sxs-lookup"><span data-stu-id="734ef-231">Next steps</span></span>
* <span data-ttu-id="734ef-232">Para empezar, cree su primer servicio de Reliable Actors:</span><span class="sxs-lookup"><span data-stu-id="734ef-232">Get started by building your first Reliable Actors service:</span></span>
   * [<span data-ttu-id="734ef-233">Introducción a Reliable Actors en .NET</span><span class="sxs-lookup"><span data-stu-id="734ef-233">Getting started with Reliable Actors on .NET</span></span>](service-fabric-reliable-actors-get-started.md)
   * [<span data-ttu-id="734ef-234">Introducción a Reliable Actors en Java</span><span class="sxs-lookup"><span data-stu-id="734ef-234">Getting started with Reliable Actors on Java</span></span>](service-fabric-reliable-actors-get-started-java.md)

<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-introduction/concurrency.png
[2]: ./media/service-fabric-reliable-actors-introduction/distribution.png
[3]: ./media/service-fabric-reliable-actors-introduction/actor-communication.png
